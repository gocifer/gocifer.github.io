(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{492:function(t,_,e){"use strict";e.r(_);var d=e(6),v=Object(d.a)({},(function(){var t=this,_=t.$createElement,e=t._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("blockquote",[e("p",[t._v("本文由 "),e("a",{attrs:{href:"http://ksria.com/simpread/",target:"_blank",rel:"noopener noreferrer"}},[t._v("简悦 SimpRead"),e("OutboundLink")],1),t._v(" 转码， 原文地址 http://www.jinbuguo.com/kernel/longterm-linux-kernel-options.html")])]),t._v(" "),e("h1",{attrs:{id:"linux-4-4-x86-64-内核配置选项简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#linux-4-4-x86-64-内核配置选项简介"}},[t._v("#")]),t._v(" Linux-4.4-x86_64 内核配置选项简介")]),t._v(" "),e("h2",{attrs:{id:"作者：金步国"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作者：金步国"}},[t._v("#")]),t._v(" 作者："),e("strong",[e("a",{attrs:{href:"http://www.jinbuguo.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("金步国"),e("OutboundLink")],1)])]),t._v(" "),e("hr"),t._v(" "),e("h3",{attrs:{id:"版权声明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#版权声明"}},[t._v("#")]),t._v(" 版权声明")]),t._v(" "),e("p",[t._v("本文作者是一位开源理念的坚定支持者，所以本文虽然不是软件，但是遵照开源的精神发布。")]),t._v(" "),e("ul",[e("li",[t._v("无担保：本文作者不保证作品内容准确无误，亦不承担任何由于使用此文档所导致的损失。")]),t._v(" "),e("li",[t._v("自由使用：任何人都可以自由的"),e("u",[t._v("阅读 / 链接 / 打印")]),t._v("此文档，无需任何附加条件。")]),t._v(" "),e("li",[t._v("名誉权：任何人都可以自由的"),e("u",[t._v("转载 / 引用 / 再创作")]),t._v("此文档，但必须保留作者署名并注明出处。")])]),t._v(" "),e("h3",{attrs:{id:"其他作品"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#其他作品"}},[t._v("#")]),t._v(" 其他作品")]),t._v(" "),e("p",[t._v("本文作者十分愿意与他人分享劳动成果，如果你对我的其他翻译作品或者技术文章有兴趣，可以在如下位置查看现有的作品集：")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"http://www.jinbuguo.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("金步国作品集"),e("OutboundLink")],1),t._v(" [ "),e("a",{attrs:{href:"http://www.jinbuguo.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://www.jinbuguo.com/"),e("OutboundLink")],1),t._v(" ]")])]),t._v(" "),e("h3",{attrs:{id:"联系方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#联系方式"}},[t._v("#")]),t._v(" 联系方式")]),t._v(" "),e("p",[t._v("由于作者水平有限，因此不能保证作品内容准确无误。如果你发现了作品中的错误 (哪怕是错别字也好)，请来信指出，任何提高作品质量的建议我都将虚心接纳。")]),t._v(" "),e("ul",[e("li",[t._v("Email(QQ)：70171448 在 QQ 邮箱")])]),t._v(" "),e("hr"),t._v(" "),e("center",[t._v("Last Update: 2016-10-24")]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"gentoo-linux"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gentoo-linux"}},[t._v("#")]),t._v(" Gentoo Linux")]),t._v(" "),e("p",[t._v("Gentoo 内核 ("),e("a",{attrs:{href:"http://packages.gentoo.org/package/sys-kernel/gentoo-sources",target:"_blank",rel:"noopener noreferrer"}},[t._v("gentoo-sources"),e("OutboundLink")],1),t._v(") 特有的选项")]),t._v(" "),e("dl",[e("dt",[t._v("Gentoo Linux support\nCONFIG_GENTOO_LINUX")]),t._v(" "),e("dd",[t._v('选 "Y" 后, 将会自动选中那些在 Gentoo 环境中必须开启的内核选项, 以避免用户遗漏某些必要的选项, 减轻一些用户配置内核的难度. 建议选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Linux dynamic and persistent device naming (userspace devfs) support\nCONFIG_GENTOO_LINUX_UDEV")]),t._v(" "),e("dd",[t._v('目前此项的作用仅是开启 CONFIG_TMPFS 和 CONFIG_DEVTMPFS 及其所依赖的选项. CONFIG_TMPFS 是为了在 "/dev/shm","/run","/sys/fs/cgroup" 三个目录中挂载 tmpfs 文件系统, CONFIG_DEVTMPFS 是为了在 "/dev" 目录挂载 devtmpfs 文件系统. 建议选 "Y".')]),t._v(" "),e("dt",[t._v("Select options required by Portage features\nCONFIG_GENTOO_LINUX_PORTAGE")]),t._v(" "),e("dd",[t._v('自动选中各种 Portage 特性 (FEATURES="cgroup ipc-sandbox network-sandbox") 所依赖的内核选项. 由于这些 FEATURES 即将变为默认开启, 所以建议选 "Y".')])])]),t._v(" "),e("dt",[t._v("Support for init systems, system and service managers")]),t._v(" "),e("dd",[t._v('"init" 系统 (系统与服务管理器)."init" 是内核启动的第一个用户空间程序(PID=1), 也是所有用户态进程的 "大总管"([提示] 所有内核态进程的大总管是 PID=2 的[kthreadd]).')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("OpenRC, runit and other script based systems and managers\nCONFIG_GENTOO_LINUX_INIT_SCRIPT")]),t._v(" "),e("dd",[t._v('[OpenRC](http://www.gentoo.org/doc/en/openrc-migration.xml) 是 Gentoo 传统的 "init" 系统, 使用基于 [SysVinit](https://wiki.archlinux.org/index.php/SysVinit_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29) 的传统启动脚本技术. 选 "Y" 后, 所有 OpenRC 所必需的内核选项 (目前仅有 CONFIG_BINFMT_SCRIPT) 都会被自动选中. 不确定的选 "Y".')]),t._v(" "),e("dt",[t._v("systemd\nCONFIG_GENTOO_LINUX_INIT_SYSTEMD")]),t._v(" "),e("dd",[t._v('尽管倍受争议, 但是 [systemd](http://linuxtoy.org/archives/more-than-upstart-systemd.html) 确实是目前风头最劲的 "init" 系统, 大有在 Linux 世界一统江湖的霸气和潜力. 仅在你打算[从 OpenRC 迁移到 systemd](http://rca.is-programmer.com/2013/7/17/from-openrc-to-systemd.40004.html) 时选 "Y". 选 "Y" 后, 内核中所有被 [systemd](http://fedoraproject.org/wiki/Systemd/zh-cn) 依赖的选项都将被自动选中, 包括 [systemd](http://zh.wikipedia.org/wiki/Systemd) 建议的 (而非必须的) 选项, 总计约 20 项.[systemd](http://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html) 官方的 [README](https://github.com/systemd/systemd/blob/master/README) 文件也列出了必须 / 推荐 / 可选的内核选项.')])])])]),t._v(" "),e("hr"),t._v(" "),e("hr"),t._v(" "),e("dl",[e("dt",[t._v("64-bit kernel\nCONFIG_64BIT")]),t._v(" "),e("dd",[t._v("编译 64 位内核. 本文仅讲述 x86_64(AMD64) 平台的内核编译, 所以这个是必选项.")])]),t._v(" "),e("h2",{attrs:{id:"general-setup"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#general-setup"}},[t._v("#")]),t._v(" General setup")]),t._v(" "),e("p",[t._v("常规设置")]),t._v(" "),e("dl",[e("dt",[t._v("Cross-compiler tool prefix\nCONFIG_CROSS_COMPILE")]),t._v(" "),e("dd",[t._v('交叉编译工具前缀 (比如 "arm-linux-" 相当于使用 "make CROSS_COMPILE=arm-linux-" 进行编译). 除非你想配置后默认自动进行交叉编译, 否则不要使用此选项.')]),t._v(" "),e("dt",[t._v("Compile also drivers which will not load\nCONFIG_COMPILE_TEST")]),t._v(" "),e("dd",[t._v('显示专属于其他平台 (非 x86 平台) 的驱动选项(需要交叉编译), 仅供驱动开发者使用, 普通的发行版制作者应该选 "N".')]),t._v(" "),e("dt",[t._v("Local version - append to kernel release\nCONFIG_LOCALVERSION")]),t._v(" "),e("dd",[t._v('在内核版本后面加上自定义的版本字符串 (最大 64 字符), 可以用 "uname -a" 命令看到')]),t._v(" "),e("dt",[t._v("Automatically append version information to the version string\nCONFIG_LOCALVERSION_AUTO")]),t._v(" "),e("dd",[t._v('自动在版本字符串 (CONFIG_LOCALVERSION) 后面添加版本信息(类似 "-gxxxxxxxx" 格式), 需要有 perl 以及 git 仓库支持')]),t._v(" "),e("dt",[t._v("Kernel compression mode")]),t._v(" "),e("dd",[t._v("内核镜像的压缩格式, 可选 Gzip/Bzip2/LZMA/XZ/LZO 格式之一, 推荐使用 XZ 格式. 你的系统中需要有相应的压缩工具.")]),t._v(" "),e("dt",[t._v("Default hostname\nCONFIG_DEFAULT_HOSTNAME")]),t._v(" "),e("dd",[t._v('设置默认主机名, 默认值是 "(none)". 用户可以随后使用系统调用 sethostname() 来修改主机名.')]),t._v(" "),e("dt",[t._v("Support for paging of anonymous memory (swap)\nCONFIG_SWAP")]),t._v(" "),e("dd",[t._v("使用交换分区或者交换文件来做为虚拟内存")]),t._v(" "),e("dt",[t._v("System V IPC\nCONFIG_SYSVIPC")]),t._v(" "),e("dd",[t._v('System V [进程间通信 (IPC)](http://www.ibm.com/developerworks/cn/linux/l-ipc/) 支持, 用于进程间同步和交换数据, 许多程序需要这个功能. 选 "Y", 除非你确实知道自己在做什么')]),t._v(" "),e("dt",[t._v("POSIX Message Queues\nCONFIG_POSIX_MQUEUE")]),t._v(" "),e("dd",[t._v('[POSIX 消息队列](http://www.cppblog.com/marv/archive/2012/03/21/168541.aspx)是 POSIX IPC 的一部分, 如果你想编译和运行那些使用 "mq_*" 系统调用的程序 (比如为 Solaris 开发的程序), 或者需要使用 Docker 容器, 就必须开启此选项. POSIX 消息队列可以作为 "mqueue" 文件系统挂载以方便用户对队列进行操作. 不确定的选 "Y".')]),t._v(" "),e("dt",[t._v("open by fhandle syscalls\nCONFIG_FHANDLE")]),t._v(" "),e("dd",[t._v('用户程序可以使用句柄 (而非文件名) 来追踪文件 (使用 open_by_handle_at(2)/name_to_handle_at(2) 系统调用), 即使某文件被重命名, 用户程序依然可定位那个文件. 此特性有助于实现用户空间文件服务器(userspace file server). 建议选 "Y", 因为 systemd 和 udev 依赖于它.')]),t._v(" "),e("dt",[t._v("uselib syscall\nCONFIG_USELIB")]),t._v(" "),e("dd",[t._v('启用老旧的 uselib() 系统接口支持, 仅在你需要使用基于 libc5 的古董级程序时才需要, 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Auditing support\nCONFIG_AUDIT")]),t._v(" "),e("dd",[t._v("内核审计 (跟踪每个进程的活动情况) 支持, 某些安全相关的内核子系统 (例如 SELinux) 需要它. 但是它会与 systemd 冲突, 所以在使用 systemd 的系统上必须关闭.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable system-call auditing support\nCONFIG_AUDITSYSCALL")]),t._v(" "),e("dd",[t._v("对系统调用进行审计. 既可独立使用, 也可被其他内核子系统 (例如 SELinux) 使用.")]),t._v(" "),e("dt",[t._v("Make audit loginuid immutable\nCONFIG_AUDIT_LOGINUID_IMMUTABLE")]),t._v(" "),e("dd",[t._v("审计时使用固定的 loginuid. 在使用 [systemd](http://zh.wikipedia.org/wiki/Systemd) 之类的系统上应该开启 (login 服务由 init 进程负责重启), 在使用 [SysVinit](https://wiki.archlinux.org/index.php/SysVinit_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29) 或 [Upstart](http://wangxu.me/blog/p/tag/init) 之类的系统上应该关闭 (login 服务由系统管理员手动重启).[OpenRC](http://en.wikipedia.org/wiki/OpenRC) 就是一个基于 SysVinit 的系统.")])])]),t._v(" "),e("dt",[t._v("IRQ subsystem")]),t._v(" "),e("dd",[t._v("IRQ(中断请求) 子系统")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Expose hardware/virtual IRQ mapping via debugfs\nCONFIG_IRQ_DOMAIN_DEBUG")]),t._v(" "),e("dd",[t._v("通过 debugfs 中的 irq_domain_mapping 文件向用户显示硬件 IRQ 号 / Linux IRQ 号之间的对应关系. 仅用于开发调试.")]),t._v(" "),e("dt",[t._v("Support sparse irq numbering\nCONFIG_SPARSE_IRQ")]),t._v(" "),e("dd",[t._v('稀疏 IRQ 号支持. 它允许在小型设备上 (例如嵌入式设备) 定义一个很高的 CONFIG_NR_CPUS 值, 但仍然不希望占用太多内核 "[memory footprint](http://en.wikipedia.org/wiki/Memory_footprint)"(一段可以被操作或被管理的内存区域) 的场合. 稀疏 IRQ 也更适合 NUMA 平台, 因为它以一种对 NUMA 更友好的方式分发中断描述符. 不确定的选"N".')])])]),t._v(" "),e("dt",[t._v("Timers subsystem")]),t._v(" "),e("dd",[t._v("[Linux 内核时钟子系统](http://www.ibm.com/developerworks/cn/linux/l-cn-timerm/)")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Timer tick handling")]),t._v(" "),e("dd",[t._v('内核时钟滴答处理程序, 更多信息可以参考内核源码树下的 "[Documentation/timers/NO_HZ.txt](https://www.kernel.org/doc/Documentation/timers/NO_HZ.txt)" 文件')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Periodic timer ticks (constant rate, no dynticks)\nCONFIG_HZ_PERIODIC")]),t._v(" "),e("dd",[t._v("无论 CPU 是否需要, 都强制按照固定频率不断触发时钟中断. 这是最耗电的方式, 不推荐使用")]),t._v(" "),e("dt",[t._v("Idle dynticks system (tickless idle)\nCONFIG_NO_HZ_IDLE")]),t._v(" "),e("dd",[t._v("CPU 在空闲状态时不产生不必要的时钟中断, 以使处理器能够在较低能耗状态下运行以节约电力, 适合于大多数场合")]),t._v(" "),e("dt",[t._v("Full dynticks system (tickless)\nCONFIG_NO_HZ_FULL")]),t._v(" "),e("dd",[t._v('[完全无滴嗒](http://www.cnbeta.com/articles/238600.htm): 即使 CPU 在忙碌状态也尽可能关闭所有时钟中断, 适用于 CPU 在同一时间仅运行一个任务, 或者用户空间程序极少与内核交互的场合. 即使开启此选项, 也需要额外设置 "nohz_full=?" 内核命令行参数才能真正生效.')])])]),t._v(" "),e("dt",[t._v("Full dynticks system on all CPUs by default\nCONFIG_NO_HZ_FULL_ALL")]),t._v(" "),e("dd",[t._v('即使没有设置 "nohz_full" 引导参数, 也默认对所有 CPU(boot CPU 除外) 开启完全无滴答特性.')]),t._v(" "),e("dt",[t._v("Old Idle dynticks config\nCONFIG_NO_HZ")]),t._v(" "),e("dd",[t._v("等价于 CONFIG_NO_HZ_IDLE, 临时用来兼容老版本内核选项, 未来会被删除.")]),t._v(" "),e("dt",[t._v("High Resolution Timer Support\nCONFIG_HIGH_RES_TIMERS")]),t._v(" "),e("dd",[t._v('[高精度定时器](http://www.ibm.com/developerworks/cn/linux/1308_liuming_linuxtime4/index.html) (hrtimer) 是从 2.6.16 开始引入, 用于取代传统 timer wheel([基于 jiffies 定时器](http://www.ibm.com/developerworks/cn/linux/1308_liuming_linuxtime3/index.html))的时钟子系统. 可以降低与内核其他模块的耦合性, 还可以提供比 1 毫秒更高的精度 (因为它可以读取 HPET/TSC 等新型硬件时钟源), 可以更好的支持音视频等对时间精度要求较高的应用. 建议选 "Y".[提示] 这里说的 "定时器" 是指 "软件定时器", 而不是主板或 CPU 上集成的[硬件时钟发生器](http://www.ibm.com/developerworks/cn/linux/1307_liuming_linuxtime2/index.html) (ACPI PM Timer/HPET Timer/TSC Timer).')])])]),t._v(" "),e("dt",[t._v("CPU/Task time and stats accounting")]),t._v(" "),e("dd",[t._v("CPU / 进程的时间及状态统计")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Cputime accounting")]),t._v(" "),e("dd",[t._v("CPU 时间统计方式")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Simple tick based cputime accounting\nCONFIG_TICK_CPU_ACCOUNTING")]),t._v(" "),e("dd",[t._v("简单的基于滴答的统计, 适用于大多数场合")]),t._v(" "),e("dt",[t._v("Deterministic task and CPU time accounting\nCONFIG_VIRT_CPU_ACCOUNTING_NATIVE")]),t._v(" "),e("dd",[t._v("通过读取 CPU 计数器进行统计, 可以提供更精确的统计, 但是对性能有一些不利影响.")]),t._v(" "),e("dt",[t._v("Full dynticks CPU time accounting\nCONFIG_VIRT_CPU_ACCOUNTING_GEN")]),t._v(" "),e("dd",[t._v("利用上下文跟踪子系统, 通过观察每一个内核与用户空间的边界进行统计. 该选项对性能有显著的不良影响, 目前仅用于完全无滴答子系统 (CONFIG_NO_HZ_FULL) 的调试")]),t._v(" "),e("dt",[t._v("Fine granularity task level IRQ time accounting\nCONFIG_IRQ_TIME_ACCOUNTING")]),t._v(" "),e("dd",[t._v("通过读取 TSC 时间戳进行统计, 这是统计进程 IRQ 时间的更细粒度的统计方式, 但对性能有些不良影响 (特别是在 RDTSC 指令速度较慢的 CPU 上).")])])]),t._v(" "),e("dt",[t._v("BSD Process Accounting\nCONFIG_BSD_PROCESS_ACCT")]),t._v(" "),e("dd",[t._v('BSD 进程记账支持. 用户空间程序可以要求内核将进程的统计信息写入一个指定的文件, 主要包括进程的创建时间 / 创建者 / 内存占用等信息. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("BSD Process Accounting version 3 file format\nCONFIG_BSD_PROCESS_ACCT_V3")]),t._v(" "),e("dd",[t._v("使用新的 v3 版文件格式, 可以包含每个进程的 PID 和其父进程的 PID, 但是不兼容老版本的文件格式. 比如 [GNU Accounting Utilities](http://www.gnu.org/software/acct/) 这样的工具可以识别 v3 格式")])])]),t._v(" "),e("dt",[t._v("Export task/process statistics through netlink\nCONFIG_TASKSTATS")]),t._v(" "),e("dd",[t._v("通过 [netlink](http://zh.wikipedia.org/wiki/Netlink) 接口向用户空间导出进程的统计信息, 与 BSD Process Accounting 的不同之处在于这些统计信息在整个进程生存期都是可用的.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable per-task delay accounting\nCONFIG_TASK_DELAY_ACCT")]),t._v(" "),e("dd",[t._v("在统计信息中包含进程等候系统资源 (cpu,IO 同步, 内存交换等) 所花费的时间")]),t._v(" "),e("dt",[t._v("Enable extended accounting over taskstats\nCONFIG_TASK_XACCT")]),t._v(" "),e("dd",[t._v('在统计信息中包含进程的更多扩展信息. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable per-task storage I/O accounting\nCONFIG_TASK_IO_ACCOUNTING")]),t._v(" "),e("dd",[t._v("在统计信息中包含进程在存储设备上的 I/O 字节数.")])])])])])])]),t._v(" "),e("dt",[t._v("RCU Subsystem")]),t._v(" "),e("dd",[t._v("[RCU(Read-Copy Update) 子系统](http://www.ibm.com/developerworks/cn/linux/l-rcu/). 它允许程序查看到正在被修改 / 更新的文件. 在读多写少的情况下, 这是一个高性能的锁机制, 对于被 RCU 保护的共享数据结构, 读者不需要获得任何锁就可以访问它 (速度非常快), 但写者在访问它时首先拷贝一个副本, 然后对副本进行修改, 最后使用一个回调机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据, 速度非常慢. RCU 只适用于读多写少的情况: 如网络路由表的查询更新, 设备状态表的维护, 数据结构的延迟释放以及多径 I/O 设备的维护等.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("RCU Implementation")]),t._v(" "),e("dd",[t._v("RCU 的实现方式")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Tree-based hierarchical RCU\nCONFIG_TREE_RCU")]),t._v(" "),e("dd",[t._v("基于树型分层结构的实现. 最适用于多 CPU 的非实时系统.")]),t._v(" "),e("dt",[t._v("Preemptible tree-based hierarchical RCU\nCONFIG_TREE_PREEMPT_RCU")]),t._v(" "),e("dd",[t._v("抢占式基于树型分层结构的实现. 最适用于那些要求快速响应的多 CPU 实时系统.")]),t._v(" "),e("dt",[t._v("UP-only small-memory-footprint RCU\nCONFIG_TINY_RCU")]),t._v(" "),e("dd",[t._v("最简单的实现, 能够大幅降低 RCU 系统的内存占用. 最适用于单 CPU 的非实时系统.")]),t._v(" "),e("dt",[t._v("Preemptible UP-only small-memory-footprint RCU\nCONFIG_TINY_PREEMPT_RCU")]),t._v(" "),e("dd",[t._v("抢占式简单实现, 能够大幅降低 RCU 系统的内存占用. 最适用于那些要求快速响应的单 CPU 实时系统.")])])]),t._v(" "),e("dt",[t._v("Consider userspace as in RCU extended quiescent state\nCONFIG_RCU_USER_QS")]),t._v(" "),e("dd",[t._v("在内核和用户边界设置钩子函数, 将运行在用户态的 CPU 从全局 RCU 状态机制中移除, 这样就不会在 RCU 系统中维护此 CPU 的时钟滴答. 除非你想要帮助开发 CONFIG_NO_HZ_FULL 模块, 否则不要打开此选项, 而且它还会对性能有不利影响.")]),t._v(" "),e("dt",[t._v("Force context tracking\nCONFIG_CONTEXT_TRACKING_FORCE")]),t._v(" "),e("dd",[t._v("默认在内核和用户边界进行探测 (上下文跟踪), 以便测试依赖于此特性的各种功能 (比如用户空间的 RCU extended quiescent state), 这个特性目前仅用于调试目的, 未来也许会用于为 CONFIG_NO_HZ_FULL 模块提供支持")]),t._v(" "),e("dt",[t._v("Tree-based hierarchical RCU fanout value\nCONFIG_RCU_FANOUT")]),t._v(" "),e("dd",[t._v("这个选项控制着树形 RCU 层次结构的端点数 (fanout), 以允许 RCU 子系统在拥有海量 CPU 的系统上高效工作. 这个值必须至少等于 CONFIG_NR_CPUS 的 1/4 次方 (4 次根号). 生产系统上应该使用默认值 (64). 仅在你想调试 RCU 子系统时才需要减小此值.")]),t._v(" "),e("dt",[t._v("Tree-based hierarchical RCU leaf-level fanout value\nCONFIG_RCU_FANOUT_LEAF")]),t._v(" "),e("dd",[t._v("这个选项控制着树形 RCU 层次结构的叶子层的端点数 (leaf-level fanout). 对于期望拥有更高能耗比(更节能) 的系统, 请保持其默认值(16). 对于拥有成千上万个 CPU 的系统来说, 应该考虑将其设为最大值(CONFIG_RCU_FANOUT).")]),t._v(" "),e("dt",[t._v("Disable tree-based hierarchical RCU auto-balancing\nCONFIG_RCU_FANOUT_EXACT")]),t._v(" "),e("dd",[t._v("强制按照 CONFIG_RCU_FANOUT_LEAF 的值, 而不是使用自动平衡树结构来实现 RCU 子系统. 目前仅用于调试目的. 未来也许会用于增强 NUMA 系统的性能.")]),t._v(" "),e("dt",[t._v("Accelerate last non-dyntick-idle CPU's grace periods\nCONFIG_RCU_FAST_NO_HZ")]),t._v(" "),e("dd",[t._v("即使 CPU 还在忙碌, 也允许进入 dynticks-idle 状态, 并且阻止 RCU 每 4 个滴答就唤醒一次该 CPU, 这样能够更有效的使用电力, 同时也拉长了 RCU grace period 的时间, 造成性能降低. 如果能耗比对你而言非常重要 (你想节省每一分电力), 并且你不在乎系统性能的降低 (CPU 唤醒时间增加), 可以开启此选项. 台式机和服务器建议关闭此选项.")]),t._v(" "),e("dt",[t._v("Enable RCU priority boosting\nCONFIG_RCU_BOOST")]),t._v(" "),e("dd",[t._v('允许提升 RCU 子系统的实时优先级 (包括读操作与写操作), 以避免 RCU 操作被阻塞太长时间. 如果系统的 CPU 负载经常很重, 或者你需要快速的实时响应系统, 那么就选 "Y", 否则应该选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Real-time priority to boost RCU readers to\nCONFIG_RCU_BOOST_PRIO")]),t._v(" "),e("dd",[t._v('允许提升被长时间抢占 (阻塞) 的 RCU 读操作的实时优先级到什么程度. 取值范围是 [1,99]. 默认值 "1" 适用于实时应用程序中不包含 CPU 密集型(CPU-bound) 线程的常规场合(例如大多数桌面系统). 但是如果你的实时应用程序拥有一个或多个 CPU 密集型线程, 那么可能需要增加这个值, 具体可以参考内核帮助的说明. 仅在你确实理解了的情况下再改变默认值.')]),t._v(" "),e("dt",[t._v("Milliseconds to delay boosting after RCU grace-period start\nCONFIG_RCU_BOOST_DELAY")]),t._v(" "),e("dd",[t._v('在提升 RCU 读操作的优先级之前, 允许有多长时间潜伏期 (阻塞), 取值范围是 [0,3000], 单位是毫秒, 默认值是 "500". 不确定的请使用默认值.')])])]),t._v(" "),e("dt",[t._v("Offload RCU callback processing from boot-selected CPUs\nCONFIG_RCU_NOCB_CPU")]),t._v(" "),e("dd",[t._v("如果你想帮助调试内核可以开启, 否则请关闭.")]),t._v(" "),e("dt",[t._v("Build-forced no-CBs CPUs")]),t._v(" "),e("dd",[t._v('在开启 CONFIG_RCU_NOCB_CPU 选项的情况下, 指定哪些 CPU 是 No-CB CPU, 相当于预先设置 "rcu_nocbs=" 内核引导参数.')])])]),t._v(" "),e("dt",[t._v("Kernel .config support\nCONFIG_IKCONFIG")]),t._v(" "),e("dd",[t._v("把内核的配置信息编译进内核中, 以后可以通过 scripts/extract-ikconfig 脚本从内核镜像中提取这些信息")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable access to .config through /proc/config.gz\nCONFIG_IKCONFIG_PROC")]),t._v(" "),e("dd",[t._v("允许通过 /proc/config.gz 文件访问内核的配置信息")])])]),t._v(" "),e("dt",[t._v("Kernel log buffer size\nCONFIG_LOG_BUF_SHIFT")]),t._v(" "),e("dd",[t._v("设置内核日志缓冲区的最小尺寸 (合理的设置应该等于 CONFIG_LOG_CPU_MAX_BUF_SHIFT * 最大 CPU 数量): 12(最小值)=4KB,...,16=64KB,17=128KB,18=256KB,...,25(最大值)")]),t._v(" "),e("dt",[t._v("CPU kernel log buffer size contribution\nCONFIG_LOG_CPU_MAX_BUF_SHIFT")]),t._v(" "),e("dd",[t._v("每个 CPU 的内核日志缓存大小 (通常只有几行文字, 但在报告故障时可能会产生大量文字). 例如在最大 CPU 数量(包含热插拔 CPU) 为 64 的系统上, 如果 CONFIG_LOG_BUF_SHIFT=18, 那么该值应该设为 12")]),t._v(" "),e("dt",[t._v("Memory placement aware NUMA scheduler\nCONFIG_NUMA_BALANCING")]),t._v(" "),e("dd",[t._v('允许自动根据 NUMA 系统的节点分布状况进行进程 / 内存均衡 (方法很原始, 就是简单的内存移动). 这个选项对 UMA 系统无效.[提示]UMA 系统的例子:(1) 只有一颗物理 CPU(即使是多核)的电脑,(2)不支持 "虚拟 NUMA", 或 "虚拟 NUMA" 被禁用的虚拟机(即使所在的物理机是 NUMA 系统)')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Automatically enable NUMA aware memory/task placement\nCONFIG_NUMA_BALANCING_DEFAULT_ENABLED")]),t._v(" "),e("dd",[t._v("在 [NUMA(Non-Uniform Memory Access Architecture)](http://www.ibm.com/developerworks/cn/linux/l-numa/) 系统上自动启用进程 / 内存均衡, 也就是自动开启 CONFIG_NUMA_BALANCING 特性.")])])]),t._v(" "),e("dt",[t._v("Control Group support\nCONFIG_CGROUPS")]),t._v(" "),e("dd",[t._v('[Cgroup(Control Group)](http://www.cnblogs.com/lisperl/archive/2012/04/17/2453838.html) 是一种进程管理机制, 可以针对一组进程进行系统资源的分配和管理, 可用于 Cpusets,CFS(完全公平调度器), 内存管理等子系统. 此外, systemd 与 Docker/LXC 等容器也依赖于它. 更多细节可以参考内核的 "[Documentation/cgroups/cgroups.txt](https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt)" 文件')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Example debug cgroup subsystem\nCONFIG_CGROUP_DEBUG")]),t._v(" "),e("dd",[t._v("导出 cgroups 框架的调试信息, 仅用于调试目的.")]),t._v(" "),e("dt",[t._v("Freezer cgroup subsystem\nCONFIG_CGROUP_FREEZER")]),t._v(" "),e("dd",[t._v("允许冻结 / 解冻 cgroup 内所有进程. Docker 依赖于它.")]),t._v(" "),e("dt",[t._v("PIDs cgroup subsystem\nCONFIG_CGROUP_PIDS")]),t._v(" "),e("dd",[t._v("允许限制同一 cgroup 内所有进程的数量, 超出限制后将无法 fork() 出新进程.")]),t._v(" "),e("dt",[t._v("Device controller for cgroups\nCONFIG_CGROUP_DEVICE")]),t._v(" "),e("dd",[t._v("允许为 cgroup 建立设备白名单, 这样 cgroup 内的进程将仅允许对白名单中的设备进行 mknod/open 操作. Docker 依赖于它.")]),t._v(" "),e("dt",[t._v("Cpuset support\nCONFIG_CPUSETS")]),t._v(" "),e("dd",[t._v("[CPUSET](http://www.cc.ntu.edu.tw/chinese/epaper/0015/20101220_1508.htm) 支持: 允许将 CPU 和内存进行分组, 并指定某些进程只能运行于特定的分组. Docker 依赖于它. 这里有一篇 [CPUSET 的用法](http://book.2cto.com/201302/16297.html)")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Include legacy /proc/"),e("pid",[t._v("/cpuset file\nCONFIG_PROC_PID_CPUSET")])],1),t._v(" "),e("dd",[t._v("提供过时的 /proc/"),e("pid",[t._v("/cpuset 文件接口")])],1)])]),t._v(" "),e("dt",[t._v("Simple CPU accounting cgroup subsystem\nCONFIG_CGROUP_CPUACCT")]),t._v(" "),e("dd",[t._v("提供一个简单的资源控制器 (Resource Controller, 用于实现一组任务间的资源共享), 以监控 cgroup 内所有进程的总 CPU 使用量. Docker 依赖于它.")]),t._v(" "),e("dt",[t._v("Resource counters\nCONFIG_RESOURCE_COUNTERS")]),t._v(" "),e("dd",[t._v("为 cgroup 提供独立于 controller 资源计数器")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Memory Resource Controller for Control Groups\nCONFIG_MEMCG")]),t._v(" "),e("dd",[t._v('为 cgroup 添加内存资源控制器, 包含匿名内存和页面缓存 ([Documentation/cgroups/memory.txt](https://www.kernel.org/doc/Documentation/cgroups/memory.txt)). 开启此选项后, 将会增加关联到每个内存页 fixed memory 大小, 具体在 64 位系统上是 40bytes/PAGE_SIZE. 仅在你确实明白什么是 [memory resource controller](https://www.kernel.org/doc/Documentation/cgroups/memory.txt) 并且确实需要的情况下才开启此选项. 此功能可以通过命令行选项 "cgroup_disable=memory" 进行关闭. Docker 依赖于它.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Memory Resource Controller Swap Extension\nCONFIG_MEMCG_SWAP")]),t._v(" "),e("dd",[t._v("给 [Memory Resource Controller](https://www.kernel.org/doc/Documentation/cgroups/memory.txt) 添加对 swap 的管理功能. 这样就可以针对每个 cgroup 限定其使用的 mem+swap 总量. 如果关闭此选项, memory resource controller 将仅能限制 mem 的使用量, 而无法对 swap 进行控制 (进程有可能耗尽 swap). 开启此功能会对性能有不利影响, 并且为了追踪 swap 的使用也会消耗更多的内存 (如果 swap 的页面大小是 4KB, 那么每 1GB 的 swap 需要额外消耗 512KB 内存), 所以在内存较小的系统上不建议开启.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Memory Resource Controller Swap Extension enabled by default\nCONFIG_MEMCG_SWAP_ENABLED")]),t._v(" "),e("dd",[t._v('如果开启此选项, 那么将默认开启 CONFIG_MEMCG_SWAP 特性, 否则将默认关闭. 即使默认开启也可以通过内核引导参数 "swapaccount=0" 禁止此特性.')])])]),t._v(" "),e("dt",[t._v("Memory Resource Controller Kernel Memory accounting\nCONFIG_MEMCG_KMEM")]),t._v(" "),e("dd",[t._v("为 Memory Resource Controller 添加对内核对象所占用内存的管理功能. 和标准的 Memory Resource Controller 对内存的控制不一样之处在于: 这些内核对象所占用的内存是基于每个内存页的, 并且可以被 swap 到硬盘. 使用这个功能可以确保 cgroup 中的进程不会单独耗尽所有内核资源.")])])]),t._v(" "),e("dt",[t._v("HugeTLB Resource Controller for Control Groups\nCONFIG_CGROUP_HUGETLB")]),t._v(" "),e("dd",[t._v("为 cgroup 添加对 [HugeTLB](http://www.ibm.com/developerworks/cn/linux/l-cn-hugetlb/) 页的资源控制功能. 开启此选项之后, 你就可以针对每个 cgroup 限定其对 [HugeTLB](http://www.ibm.com/developerworks/cn/linux/1305_zhangli_hugepage/index.html) 的使用. Docker 依赖于它.")])])]),t._v(" "),e("dt",[t._v("Enable perf_event per-cpu per-container group (cgroup) monitoring\nCONFIG_CGROUP_PERF")]),t._v(" "),e("dd",[t._v("将 per-cpu 模式进行扩展, 使其可以监控属于特定 cgroup 并运行于特定 CPU 上的线程.")]),t._v(" "),e("dt",[t._v("Group CPU scheduler\nCONFIG_CGROUP_SCHED")]),t._v(" "),e("dd",[t._v("让 CPU 调度程序可以在不同的 cgroup 之间分配 CPU 的带宽. Docker 依赖于它. systemd 资源控制单元 (resource control unit) 的 CPUShares 功能依赖于它.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Group scheduling for SCHED_OTHER\nCONFIG_FAIR_GROUP_SCHED")]),t._v(" "),e("dd",[t._v('公平 CPU 调度策略, 也就是在多个 cgroup 之间平均分配 CPU 带宽." [鸡血补丁](http://linuxtoy.org/archives/small-patch-but-huge-improvement.html) "CONFIG_SCHED_AUTOGROUP(自动分组调度功能)依赖于它. Docker 依赖于它. systemd 资源控制单元 (resource control unit) 的 CPUShares 功能也依赖于它.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("CPU bandwidth provisioning for FAIR_GROUP_SCHED\nCONFIG_CFS_BANDWIDTH")]),t._v(" "),e("dd",[t._v("允许用户为运行在 CONFIG_FAIR_GROUP_SCHED 中的进程定义 CPU 带宽限制. 对于没有定义 CPU 带宽限制的 cgroup 而言, 可以无限制的使用 CPU 带宽. 详情参见 [Documentation/scheduler/sched-bwc.txt](https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt) 文件. systemd 资源控制单元 (resource control unit) 的 CPUQuota 功能也依赖于它.")])])]),t._v(" "),e("dt",[t._v("Group scheduling for SCHED_RR/FIFO\nCONFIG_RT_GROUP_SCHED")]),t._v(" "),e("dd",[t._v('允许用户为 cgroup 分配实时 CPU 带宽, 还可以对非特权用户的实时进程组进行调度. 详情参见 [Documentation/scheduler/sched-rt-group.txt](https://www.kernel.org/doc/Documentation/scheduler/sched-rt-group.txt) 文档. 使用 systemd 的系统应该选 "N".')])])]),t._v(" "),e("dt",[t._v("Block IO controller\nCONFIG_BLK_CGROUP")]),t._v(" "),e("dd",[t._v('通用的块 IO 控制器接口, 可以用于实现各种不同的控制策略. 目前, IOSCHED_CFQ 用它来在不同的 cgroup 之间分配磁盘 IO 带宽 (需要额外开启 CONFIG_CFQ_GROUP_IOSCHED),[block io throttle](http://blog.tao.ma/?p=43) 也会用它来针对特定块设备限制 IO 速率上限 (需要额外开启 CONFIG_BLK_DEV_THROTTLING). 更多信息可以参考 "[Documentation/cgroups/blkio-controller.txt](https://www.kernel.org/doc/Documentation/cgroups/blkio-controller.txt)" 文件.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable Block IO controller debugging\nCONFIG_DEBUG_BLK_CGROUP")]),t._v(" "),e("dd",[t._v("仅用于调试 Block IO controller 目的.")])])])])]),t._v(" "),e("dt",[t._v("Checkpoint/restore support\nCONFIG_CHECKPOINT_RESTORE")]),t._v(" "),e("dd",[t._v('在内核中添加 "检查点 / 恢复" 支持. 也就是添加一些辅助的代码用于设置进程的 text, data, heap 段, 并且在 /proc 文件系统中添加一些额外的条目. 用于检测两个进程是否共享同一个内核资源的 [kcmp()](http://www.man7.org/linux/man-pages/man2/kcmp.2.html) 系统调用依赖于它. 使用 systemd 的建议开启此项.')]),t._v(" "),e("dt",[t._v("Namespaces support\nCONFIG_NAMESPACES")]),t._v(" "),e("dd",[t._v("[命名空间](http://www.cnblogs.com/lisperl/archive/2012/05/03/2480316.html)支持. 主要用于支持基于容器的轻量级虚拟化技术 (比如 [LXC](http://www.cnblogs.com/lisperl/archive/2012/04/15/2450183.html) 和 [Linux-VServer](http://en.wikipedia.org/wiki/Linux-VServer) 以及 [Docker](http://www.docker.org.cn/book/docker.html)).")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("UTS namespace\nCONFIG_UTS_NS")]),t._v(" "),e("dd",[t._v("uname() 系统调用的命名空间支持")]),t._v(" "),e("dt",[t._v("IPC namespace\nCONFIG_IPC_NS")]),t._v(" "),e("dd",[t._v("进程间通信对象 ID 的命名空间支持")]),t._v(" "),e("dt",[t._v("User namespace\nCONFIG_USER_NS")]),t._v(" "),e("dd",[t._v('允许容器使用 user 命名空间. 如果开启此项, 建议同时开启 CONFIG_MEMCG 和 CONFIG_MEMCG_KMEM 选项, 以允许用户空间使用 "memory cgroup" 限制非特权用户的内存使用量. 不确定的选 "N", 如果你打算构建一个 [VPS 服务器](http://baike.baidu.com/view/698769.htm)就必须选 "Y".')]),t._v(" "),e("dt",[t._v("PID Namespaces\nCONFIG_PID_NS")]),t._v(" "),e("dd",[t._v("进程 PID 命名空间支持")]),t._v(" "),e("dt",[t._v("Network namespace\nCONFIG_NET_NS")]),t._v(" "),e("dd",[t._v('网络协议栈的命名空间支持. systemd 服务单元 (service unit) 中的 "PrivateNetwork/PrivateDevices" 依赖于它.')])])]),t._v(" "),e("dt",[t._v("Require conversions between uid/gids and their internal representation\nCONFIG_UIDGID_STRICT_TYPE_CHECKS")]),t._v(" "),e("dd",[t._v('强制将 uid/gid 转换为内部表示形式, 以让那些未对 uid/gid 进行转换的内核子系统代码也能正常编译. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Automatic process group scheduling\nCONFIG_SCHED_AUTOGROUP")]),t._v(" "),e("dd",[t._v('每个 TTY 动态地创建任务分组 (cgroup), 这样就可以降低高负载情况下的桌面延迟. 也就是传说中的桌面 " [鸡血补丁](http://wowubuntu.com/kernel-patch.html) ", 桌面用户建议开启. 但服务器建议关闭.')]),t._v(" "),e("dt",[t._v("Enable deprecated sysfs features to support old userspace tools\nCONFIG_SYSFS_DEPRECATED")]),t._v(" "),e("dd",[t._v("为了兼容旧版本的应用程序而保留过时的 sysfs 特性. 仅当在使用 2008 年以前的发行版时才需要开启, 2009 年之后的发行版中必须关闭. 此外, 使用 udev 或 systemd 的系统也必须关闭.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable deprecated sysfs features by default\nCONFIG_SYSFS_DEPRECATED_V2")]),t._v(" "),e("dd",[t._v("默认开启上述特性")])])]),t._v(" "),e("dt",[t._v("Kernel->user space relay support (formerly relayfs)\nCONFIG_RELAY")]),t._v(" "),e("dd",[t._v("在某些文件系统 (比如 debugfs) 中提供[中继 (relay)](http://www.ibm.com/developerworks/cn/linux/l-cn-relay/) 支持 (从内核空间向用户空间传递大批量数据). 主要用于调试内核.")]),t._v(" "),e("dt",[t._v("Initial RAM filesystem and RAM disk (initramfs/initrd) support\nCONFIG_BLK_DEV_INITRD")]),t._v(" "),e("dd",[t._v('初始内存文件系统 ([initramfs](http://linux.chinaunix.net/techdoc/net/2009/06/24/1120335.shtml),2.6 以上内核的新机制, 使用 cpio 格式, 占据的内存随数据的增减自动增减) 与初始内存盘 ([initrd](http://zh.wikipedia.org/wiki/Initrd),2.4 以前内核遗留的老机制, 使用 loop 设备, 占据一块固定的内存, 需要额外开启 CONFIG_BLK_DEV_RAM 选项才生效) 支持, 一般通过 lilo/grub 的 initrd 指令加载. 更多细节可以参考 "[Documentation/initrd.txt](https://www.kernel.org/doc/Documentation/initrd.txt)" 文件, 关于 [initrd 到 initramfs 的进化](http://blog.linux.org.tw/~jserv/archives/001954.html) ([墙内镜像](http://hi.baidu.com/toniya/item/da1a25453b6da135fa8960a6)), 可以参考 IBM 上的两篇文章:[Linux2.6 内核的 Initrd 机制解析](http://www.ibm.com/developerworks/cn/linux/l-k26initrd/)和 [Linux 初始 RAM 磁盘（initrd）概述](http://www.ibm.com/developerworks/cn/linux/l-initrd.html).')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Initramfs source file(s)\nCONFIG_INITRAMFS_SOURCE")]),t._v(" "),e("dd",[t._v('如果你想[将 initramfs 镜像直接嵌入内核](http://www.arm9home.net/read.php?tid=5645) (比如嵌入式环境或者想使用 EFI stub kernel), 而不是通过 lilo/grub 这样的引导管理器加载, 可以使用此选项, 否则请保持空白. 这个选项指明用来制作 initramfs 镜像的原料, 可以是一个. cpio 文件, 或一个 Initramfs 虚根目录 (其下包含 "bin,dev,etc,lib,proc,sys" 等子目录), 或一个描述文件. 细节可以参考 "[Documentation/early-userspace/README](https://www.kernel.org/doc/Documentation/early-userspace/README)" 文档.[注意] 内核帮助文档说可以指定多个目录或文件是错误的, 实际只能接受单一的目录或文件')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("User ID to map to 0 (user root)\nINITRAMFS_ROOT_UID")]),t._v(" "),e("dd",[t._v('此选项仅在 CONFIG_INITRAMFS_SOURCE 中包含目录时才有效, 将此值设为非零 (例如 "37"), 那么所有 UID=37 的文件在打包到 initramfs 镜像内时, 其 UID 都将被设为 "0".')]),t._v(" "),e("dt",[t._v("Group ID to map to 0 (group root)\nINITRAMFS_ROOT_GID")]),t._v(" "),e("dd",[t._v('此选项仅在 CONFIG_INITRAMFS_SOURCE 中包含目录时才有效, 将此值设为非零 (例如 "37"), 那么所有 GID=37 的文件在打包到 initramfs 镜像内时, 其 GID 都将被设为 "0".')])])]),t._v(" "),e("dt",[t._v("Support initial ramdisks compressed using gzip\nCONFIG_RD_GZIP")]),t._v(" "),e("dd",[t._v("支持经过 gzip 压缩的 ramdisk 或 cpio 镜像")]),t._v(" "),e("dt",[t._v("Support initial ramdisks compressed using bzip2\nCONFIG_RD_BZIP2")]),t._v(" "),e("dd",[t._v("支持经过 bzip2 压缩的 ramdisk 或 cpio 镜像")]),t._v(" "),e("dt",[t._v("Support initial ramdisks compressed using LZMA\nCONFIG_RD_LZMA")]),t._v(" "),e("dd",[t._v("支持经过 LZMA 压缩的 ramdisk 或 cpio 镜像")]),t._v(" "),e("dt",[t._v("Support initial ramdisks compressed using XZ\nCONFIG_RD_XZ")]),t._v(" "),e("dd",[t._v("支持经过 XZ 压缩的 ramdisk 或 cpio 镜像")]),t._v(" "),e("dt",[t._v("Support initial ramdisks compressed using LZO\nCONFIG_RD_LZO")]),t._v(" "),e("dd",[t._v("支持经过 LZO 压缩的 ramdisk 或 cpio 镜像")]),t._v(" "),e("dt",[t._v("Built-in initramfs compression mode")]),t._v(" "),e("dd",[t._v('选择 initramfs 镜像的压缩格式."gzip" 是兼容性最好的格式, 但是压缩率却最低."XZ" 是目前渐渐流行的格式, 压缩率高, 解压速度也不慢.')])])]),t._v(" "),e("dt",[t._v("Optimize for size\nCONFIG_CC_OPTIMIZE_FOR_SIZE")]),t._v(" "),e("dd",[t._v('编译时优化内核尺寸 (使用 GCC 的 "-Os" 而不是 "-O2" 参数编译), 这会得到更小的内核, 但是运行速度可能会更慢. 主要用于嵌入式环境.')]),t._v(" "),e("dt",[t._v("Configure standard kernel features (expert users)\nCONFIG_EXPERT")]),t._v(" "),e("dd",[t._v('配置标准的内核特性 (仅供专家使用). 这个选项允许你改变内核的 "标准" 特性 (比如用于需要 "非标准" 内核的特定环境中), 仅在你确实明白自己在干什么的时候才开启.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable 16-bit UID system calls\nCONFIG_UID16")]),t._v(" "),e("dd",[t._v("允许对 UID 系统调用进行过时的 16-bit 包装, 建议关闭")]),t._v(" "),e("dt",[t._v("Multiple users, groups and capabilities support\nCONFIG_MULTIUSER")]),t._v(" "),e("dd",[t._v('多用户 (组) 支持. 若选 "N", 则所有进程都将以 "UID=0,GID=0" 运行(也就是禁止存在非 root 用户). 选 "Y", 除非你确实知道自己在干什么.')]),t._v(" "),e("dt",[t._v("sgetmask/ssetmask syscalls support\nCONFIG_SGETMASK_SYSCALL")]),t._v(" "),e("dd",[t._v('是否开启已被反对使用的 sys_sgetmask/sys_ssetmask 系统调用 (已不再被 libc 支持). 建议选 "N".')]),t._v(" "),e("dt",[t._v("Sysfs syscall support\nCONFIG_SYSFS_SYSCALL")]),t._v(" "),e("dd",[t._v('是否开启已被反对使用的 sys_sysfs 系统调用 (已不再被 libc 支持). 建议选 "N".')]),t._v(" "),e("dt",[t._v("Sysctl syscall support\nCONFIG_SYSCTL_SYSCALL")]),t._v(" "),e("dd",[t._v("二进制 sysctl 接口支持. 由于现在流行直接通过 / proc/sys 以 ASCII 明码方式修改内核参数 (需要开启 CONFIG_PROC_SYSCTL 选项), 所以已经不需要再通过二进制接口去控制内核参数, 建议关闭它以减小内核尺寸.")]),t._v(" "),e("dt",[t._v("Load all symbols for debugging/ksymoops\nCONFIG_KALLSYMS")]),t._v(" "),e("dd",[t._v("装载所有的调试符号表信息, 会增大内核体积, 仅供调试时选择")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Include all symbols in kallsyms\nCONFIG_KALLSYMS_ALL")]),t._v(" "),e("dd",[t._v("在 [/proc/kallsyms](http://blog.csdn.net/diy534/article/details/6941001) 中包含内核知道的所有符号, 内核将会增大 300K, 仅在你确实需要的时候再开启")])])]),t._v(" "),e("dt",[t._v("Enable support for printk\nCONFIG_PRINTK")]),t._v(" "),e("dd",[t._v('允许内核向终端打印字符信息. 任何由 printk 显示的字符串通常记录在 / var/log/messages 文件里. 如果关闭, 内核在初始化过程中将不会输出字符信息, 这会导致很难诊断系统故障, 并且 "dmesg" 命令也会失效. 仅在你确实不想看到任何内核信息时选 "N". 否则请选 "Y".')]),t._v(" "),e("dt",[t._v("BUG() support\nCONFIG_BUG")]),t._v(" "),e("dd",[t._v("显示故障和失败条件 (BUG 和 WARN), 禁用它将可能导致隐含的错误被忽略. 建议仅在嵌入式设备或者无法显示故障信息的系统上关闭")]),t._v(" "),e("dt",[t._v("Enable ELF core dumps\nCONFIG_ELF_CORE")]),t._v(" "),e("dd",[t._v("内存转储支持, 可以帮助调试 ELF 格式的程序, 用于调试和开发用户态程序")]),t._v(" "),e("dt",[t._v("Enable PC-Speaker support\nCONFIG_PCSPKR_PLATFORM")]),t._v(" "),e("dd",[t._v('主板上的[蜂鸣器](http://blog.csdn.net/raptor/article/details/7636997)支持. [主板上的蜂鸣器](http://www.help315.com.cn/ask/htmldata/detail/2010/03/04/93.html)只能发出或长或短的 "滴" 或 "嘟嘟" 声, 一般用于系统报警. 不要和能够播放音乐的扬声器混淆. 如果你的主板上没有就关闭, 有的话 (开机自检完成后一般能听到 "滴" 的一声) 还是建议开启.')]),t._v(" "),e("dt",[t._v("Enable full-sized data structures for core\nCONFIG_BASE_FULL")]),t._v(" "),e("dd",[t._v("在内核中使用全尺寸的数据结构. 禁用它将使得某些内核的数据结构减小以节约内存, 但是将会降低性能")]),t._v(" "),e("dt",[t._v("Enable futex support\nCONFIG_FUTEX")]),t._v(" "),e("dd",[t._v("[快速用户空间互斥 (fast userspace mutexes)](http://hi.baidu.com/pbskasefcqcfjxr/item/8f0271c5a07d7c52ac00ef12) 可以使线程串行化以避免竞态条件, 也提高了响应速度. 禁用它将导致内核不能正确的运行基于 glibc 的程序")]),t._v(" "),e("dt",[t._v("Enable eventpoll support\nCONFIG_EPOLL")]),t._v(" "),e("dd",[t._v("[Epoll](http://blog.csdn.net/sparkliang/article/details/4770655) 系列系统调用 (epoll_*) 支持, 这是当前在 Linux 下开发大规模并发网络程序 (比如 Nginx) 的热门人选, 设计目的是取代既有 POSIX select(2)与 poll(2)系统接口, systemd 依赖于它. 建议开启.")]),t._v(" "),e("dt",[t._v("Enable signalfd() system call\nCONFIG_SIGNALFD")]),t._v(" "),e("dd",[t._v("[signalfd()](http://cpp.ezbty.org/import_doc/linux_manpage/signalfd4.2.html) 系统调用支持, 建议开启. 传统的处理信号的方式是注册信号处理函数, 由于信号是异步发生的, 要解决数据的并发访问和可重入问题. signalfd 可以将信号抽象为一个文件描述符, 当有信号发生时可以对其 read, 这样可以将信号的监听放到 select/poll/epoll 监听队列中. systemd 依赖于它.")]),t._v(" "),e("dt",[t._v("Enable timerfd() system call\nCONFIG_TIMERFD")]),t._v(" "),e("dd",[t._v("[timerfd()](http://blog.csdn.net/walkingman321/article/details/6162055) 系统调用支持, 建议开启. timerfd 可以实现定时器功能, 将定时器抽象为文件描述符, 当定时器到期时可以对其 read, 这样也可以放到 select/poll/epoll 监听队列中. 更多信息可以参考 [linux 新的 API signalfd、timerfd、eventfd 使用说明](http://blog.csdn.net/gdutliuyun827/article/details/8460417).systemd 依赖于它.")]),t._v(" "),e("dt",[t._v("Enable eventfd() system call\nCONFIG_EVENTFD")]),t._v(" "),e("dd",[t._v("[eventfd()](http://www.cppblog.com/peija/archive/2010/10/07/128941.html) 系统调用支持, 建议开启. eventfd 实现了线程之间事件通知的方式, eventfd 的缓冲区大小是 sizeof(uint64_t), 向其 write 可以递增这个计数器, read 操作可以读取, 并进行清零. eventfd 也可以放到 select/poll/epoll 监听队列中. 当计数器不是 0 时, 有可读事件发生, 可以进行读取.")])])]),t._v(" "),e("dt",[t._v("Enable bpf() system call\nCONFIG_BPF_SYSCALL")]),t._v(" "),e("dd",[t._v('开启内核的 [bpf()](http://www.man7.org/linux/man-pages/man2/bpf.2.html) 系统调用支持 (从 3.15 版本开始引入), 以支持 [eBPF](http://blog.csdn.net/ljy1988123/article/details/50444693) 功能. 可用于内核调试与网络包过滤 (tcpdump,libpcap,iptables). 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Use full shmem filesystem\nCONFIG_SHMEM")]),t._v(" "),e("dd",[t._v("完全使用 shmem 来代替 ramfs.shmem 是基于共享内存的文件系统 (可以使用 swap), 在启用 CONFIG_TMPFS 后可以挂载为 tmpfs 供用户空间使用, 它比简单的 ramfs 先进许多. 仅在微型嵌入式环境中且没有 swap 的情况下才可能会需要使用原始的 ramfs.")]),t._v(" "),e("dt",[t._v("Enable AIO support\nCONFIG_AIO")]),t._v(" "),e("dd",[t._v("开启 POSIX 异步 IO 支持. 它常常被高性能的多线程程序使用, 建议开启")]),t._v(" "),e("dt",[t._v("Enable madvise/fadvise syscalls\nCONFIG_ADVISE_SYSCALLS")]),t._v(" "),e("dd",[t._v('开启内核的 [madvise()](http://docs.oracle.com/cd/E19253-01/819-7052/lgroups-23/)/[fadvise()](http://blog.csdn.net/vah101/article/details/7317557) 系统调用支持 (2.6.16 版本开始引入). 以允许应用程序预先提示内核, 它将如何使用特定的内存与文件. 这种措施有助于提升应用程序的性能. 建议选 "Y".')]),t._v(" "),e("dt",[t._v("Enable userfaultfd() system call\nCONFIG_USERFAULTFD")]),t._v(" "),e("dd",[t._v("开启内核的 [userfaultfd()](http://xiaogr.com/?p=96) 系统调用支持 (从 4.3 版本开始引入). 该特性可以被诸如 QEMU/KVM 之类的虚拟化技术用来提高 GuestOS 热迁移性能.")]),t._v(" "),e("dt",[t._v("Enable PCI quirk workarounds\nCONFIG_PCI_QUIRKS")]),t._v(" "),e("dd",[t._v('开启针对多种 PCI 芯片组的错误规避功能, 仅在确定你的 PCI 芯片组确实没有没有任何 bug 时才关闭此功能. 至于究竟哪些芯片组有 bug, 你可以直接打开 "[drivers/pci/quirks.c](http://lxr.linux.no/linux/drivers/pci/quirks.c)"文件查看. 不确定的选"Y".')]),t._v(" "),e("dt",[t._v("Enable membarrier() system call\nCONFIG_MEMBARRIER")]),t._v(" "),e("dd",[t._v('开启内核的 [membarrier()](http://man7.org/linux/man-pages/man2/membarrier.2.html) 系统调用支持 (与 [Memory Barrier](http://blog.jobbole.com/53697/) 相关). 有助于提升多 CPU 场景下的并行计算性能. 建议选 "Y".')]),t._v(" "),e("dt",[t._v("Embedded system\nCONFIG_EMBEDDED")]),t._v(" "),e("dd",[t._v("如果你是为嵌入式系统编译内核, 可以开启此选项, 这样一些高级选项就会显示出来. 单独选中此项本身对内核并无任何改变.")]),t._v(" "),e("dt",[t._v("Kernel Performance Events And Counters\nCONFIG_PERF_EVENTS")]),t._v(" "),e("dd",[t._v('性能相关的事件和计数器支持 (既有硬件的支持也有软件的支持). 大多数现代 CPU 都会通过性能计数寄存器对特定类型的硬件事件(指令执行, 缓存未命中, 分支预测失败) 进行计数, 同时又丝毫不会减慢内核和应用程序的运行速度. 这些寄存器还会在某些事件计数到达特定的阈值时触发中断, 从而可以对代码进行性能分析. Linux Performance Event 子系统对上述特性进行了抽象, 提供了针对每个进程和每个 CPU 的计数器, 并可以被 tools/perf/ 目录中的 "perf" 工具使用.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Debug: use vmalloc to back perf mmap() buffers\nCONFIG_DEBUG_PERF_USE_VMALLOC")]),t._v(" "),e("dd",[t._v("主要用于调试 vmalloc 代码.")])])]),t._v(" "),e("dt",[t._v("Enable VM event counters for /proc/vmstat\nCONFIG_VM_EVENT_COUNTERS")]),t._v(" "),e("dd",[t._v('"[/proc/vmstat](http://blog.csdn.net/plusboy/article/details/1528252)" 中包含了从内核导出的虚拟内存的各种统计信息. 开启此项后可以显示较详细的信息 (包含各种事件计数器), 关闭此项则仅仅显示内存页计数. 主要用于调试和统计.')]),t._v(" "),e("dt",[t._v("Enable SLUB debugging support\nCONFIG_SLUB_DEBUG")]),t._v(" "),e("dd",[t._v("SLUB 调试支持, 禁用后可显著降低内核大小, 同时 / sys/kernel/slab 也将不复存在.")]),t._v(" "),e("dt",[t._v("Disable heap randomization\nCONFIG_COMPAT_BRK")]),t._v(" "),e("dd",[t._v('禁用堆随机化 (heap randomization) 功能. 堆随机化可以让针对堆溢出的攻击变得困难, 但是不兼容那些古董级的二进制程序(2000 年以前). 如果你不需要使用这些古董程序, 那么选 "N".')]),t._v(" "),e("dt",[t._v("Choose SLAB allocator")]),t._v(" "),e("dd",[t._v("选择内存分配管理器")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("SLAB\nCONFIG_SLAB")]),t._v(" "),e("dd",[t._v("久经考验的 slab 内存分配器, 在大多数情况下都具有良好的适应性.")]),t._v(" "),e("dt",[t._v("SLUB (Unqueued Allocator)\nCONFIG_SLUB")]),t._v(" "),e("dd",[t._v("[SLUB](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/) 与 SLAB 兼容, 但通过取消大量的队列和相关开销, 简化了 slab 的结构. 特别是在多核时拥有比 slab 更好的性能和更好的系统可伸缩性.")]),t._v(" "),e("dt",[t._v("SLOB (Simple Allocator)\nCONFIG_SLOB")]),t._v(" "),e("dd",[t._v("SLOB 针对小型系统设计, 做了非常激进的简化, 以适用于内存非常有限 (小于 64M) 的嵌入式环境.")])])]),t._v(" "),e("dt",[t._v("SLUB per cpu partial cache\nCONFIG_SLUB_CPU_PARTIAL")]),t._v(" "),e("dd",[t._v('让 SLUB 内存分配器使用基于每个 CPU 的局部缓存, 这样可以加速分配和释放属于此 CPU 范围内的对象, 但这样做的代价是增加对象释放延迟的不确定性. 因为当这些局部缓存因为溢出而要被清除时, 需要使用锁, 从而导致延迟尖峰. 对于需要快速响应的实时系统, 应该选 "N", 服务器则可以选 "Y".')]),t._v(" "),e("dt",[t._v("Provide system-wide ring of trusted keys\nCONFIG_SYSTEM_TRUSTED_KEYRING")]),t._v(" "),e("dd",[t._v('在内核中创建一个密钥环, 从而允许向密钥环上添加受信任的密钥, 主要用于内核模块的签名. 如果你开启了 CONFIG_MODULE_SIG, 此项将被自动选中. 不需要使用内核模块签名检查功能的应该选 "N"')]),t._v(" "),e("dt",[t._v("Profiling support\nCONFIG_PROFILING")]),t._v(" "),e("dd",[t._v("添加扩展的性能分析支持, 可以被 [OProfile](http://baike.baidu.com/view/2973608.htm) 之类的工具使用. 仅用于调试目的.")]),t._v(" "),e("dt",[t._v("OProfile system profiling\nCONFIG_OPROFILE")]),t._v(" "),e("dd",[t._v("[OProfile 性能分析工具](http://blog.csdn.net/yili_xie/article/details/4925648)支持, 仅用于调试目的.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("OProfile multiplexing support\nCONFIG_OPROFILE_EVENT_MULTIPLEX")]),t._v(" "),e("dd",[t._v("[OProfile multiplexing 技术](http://lwn.net/Articles/343812/)支持")])])]),t._v(" "),e("dt",[t._v("Kprobes\nCONFIG_KPROBES")]),t._v(" "),e("dd",[t._v("[Kprobes](http://www.ibm.com/developerworks/cn/linux/l-kprobes.html) 是一个轻量级的内核调试工具, 能在内核运行的几乎任意时间点进行暂停 / 读取 / 修改等操作的调试工具. 仅供调试使用.")]),t._v(" "),e("dt",[t._v("Optimize very unlikely/likely branches\nCONFIG_JUMP_LABEL")]),t._v(" "),e("dd",[t._v('针对内核中某些 "几乎总是为真" 或者 "几乎总是为假" 的条件分支判断使用 ["asm goto"](http://blog.csdn.net/dog250/article/details/6123517) 进行优化 (在分支预测失败时会浪费很多时间在回退上, 但是这种情况极少发生). 很多内核子系统都支持进行这种优化. 建议开启.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Static key selftest\nCONFIG_STATIC_KEYS_SELFTEST")]),t._v(" "),e("dd",[t._v("在内核启动时对上述分支优化补丁进行一次自我检查.")])])]),t._v(" "),e("dt",[t._v("Transparent user-space probes\nCONFIG_UPROBES")]),t._v(" "),e("dd",[t._v("[Uprobes](http://blog.csdn.net/badu_123/article/details/8302642) 与 Kprobes 类似, 但主要用于用户空间的调试.")]),t._v(" "),e("dt",[t._v("Stack Protector buffer overflow detection")]),t._v(" "),e("dd",[t._v('GCC 的 "stack-protector" 功能可以在函数开始执行时, 在函数的返回地址末端设置一个敏感值, 当函数执行完成要返回时, 检查这个敏感值, 看看是否存在溢出. 如果有溢出则表明可能受到了堆栈溢出攻击, 内核将通过 panic 来阻止可能的攻击. 选项中的 "None" 表示关闭此功能,"Regular" 表示启用此功能但是仅提供较弱的保护 (需要 GCC-4.2 及以上版本),"Strong" 则表示提供较强的保护 (需要 GCC-4.9 及以上版本)')]),t._v(" "),e("dt",[t._v("Enable GCOV-based kernel profiling\nCONFIG_GCOV_KERNEL")]),t._v(" "),e("dd",[t._v("基于 [GCC 的 gcov](http://gcc.gnu.org/onlinedocs/gcc/Gcov.html)([代码覆盖率测试](http://blog.linezing.com/2011/03/%E4%BD%BF%E7%94%A8gcov%E5%AE%8C%E6%88%90%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E7%9A%84%E6%B5%8B%E8%AF%95)工具) 的[代码分析](http://blog.csdn.net/livelylittlefish/article/details/6382489)支持, 仅用于调试")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Profile entire Kernel\nCONFIG_GCOV_PROFILE_ALL")]),t._v(" "),e("dd",[t._v("支持对整个内核进行分析. 内核体积将会显著增大, 并且运行速度显著减慢.")])])])]),t._v(" "),e("h2",{attrs:{id:"enable-loadable-module-support"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#enable-loadable-module-support"}},[t._v("#")]),t._v(" Enable loadable module support")]),t._v(" "),e("p",[t._v("可加载模块支持")]),t._v(" "),e("dl",[e("dt",[t._v("Enable loadable module support\nCONFIG_MODULES")]),t._v(" "),e("dd",[t._v('打开可加载模块支持, 可以通过 "make modules_install" 把内核模块安装在 / lib/modules / 中. 然后可以使用 modprobe, lsmod, modinfo, insmod, rmmod 等工具进行各种模块操作.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Forced module loading\nCONFIG_MODULE_FORCE_LOAD")]),t._v(" "),e("dd",[t._v('允许使用 "modprobe --force" 在不校验版本信息的情况下强制加载模块, 这绝对是个坏主意! 建议关闭.')]),t._v(" "),e("dt",[t._v("Module unloading\nCONFIG_MODULE_UNLOAD")]),t._v(" "),e("dd",[t._v("允许卸载已经加载的模块. 如果将模块静态编译进内核中, 那么内核的执行效率会更好. 如果代码作为动态模块加载, 那么不使用时可以减少内核的内存使用并减少启动的时间, 然而内核和模块在内存上相互独立又会影响内核的执行性能.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Forced module unloading\nCONFIG_MODULE_FORCE_UNLOAD")]),t._v(" "),e("dd",[t._v("允许强制卸载正在使用中的模块 (rmmod -f), 即使可能会造成系统崩溃. 这又是一个坏主意! 建议关闭.")])])]),t._v(" "),e("dt",[t._v("Module versioning support\nCONFIG_MODVERSIONS")]),t._v(" "),e("dd",[t._v("允许使用为其他内核版本编译的模块, 可会造成系统崩溃. 这同样是个坏主意! 建议关闭.")]),t._v(" "),e("dt",[t._v("Source checksum for all modules\nCONFIG_MODULE_SRCVERSION_ALL")]),t._v(" "),e("dd",[t._v('为模块添加 "srcversion" 字段, 以帮助模块维护者准确的知道编译此模块所需要的源文件, 从而可以校验源文件的变动. 仅内核模块开发者需要它.')]),t._v(" "),e("dt",[t._v("Module signature verification\nCONFIG_MODULE_SIG")]),t._v(" "),e("dd",[t._v('在[加载模块](http://lwn.net/Articles/470906/)时检查[模块签名](http://lwn.net/Articles/511720/), 详情参见 "[Documentation/module-signing.txt](https://www.kernel.org/doc/Documentation/module-signing.txt)" 文件.[!! 警告!!] 开启此选项后, 必须确保模块签名后没有被 strip(包括 rpmbuild 之类的打包工具).')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Require modules to be validly signed\nCONFIG_MODULE_SIG_FORCE")]),t._v(" "),e("dd",[t._v("仅加载已签名并且密钥正确的模块, 拒绝加载未签名或者签名密钥不正确的模块")]),t._v(" "),e("dt",[t._v("Automatically sign all modules\nCONFIG_MODULE_SIG_ALL")]),t._v(" "),e("dd",[t._v('在执行 "make modules_install" 安装模块的时候, 自动进行签名. 否则你必须手动使用 scripts/sign-file 工具进行签名.')])])]),t._v(" "),e("dt",[t._v("Which hash algorithm should modules be signed with?")]),t._v(" "),e("dd",[t._v('选择对模块签名时使用的散列函数. 建议使用强度最高的 "SHA-512" 算法. 注意: 所依赖的散列算法必须被静态编译进内核. 对于 "SHA-512" 来说, 就是 CONFIG_CRYPTO_SHA512 和 CONFIG_CRYPTO_SHA512_SSSE3(如果你的 CPU 支持 SSSE3 指令集的话).')]),t._v(" "),e("dt",[t._v("Compress modules on installation\nCONFIG_MODULE_COMPRESS")]),t._v(" "),e("dd",[t._v("在'make modules_install'时对内核模块进行压缩. 传统的 module-init-tools 工具可能支持 gzip 压缩, 而新式的 kmod 可能支持 gzip 与 xz 压缩. 使用 Kbuild 在内核树之外编译的模块也会同样在安装时被压缩. 不确定的选 \"N\".")])])])]),t._v(" "),e("h2",{attrs:{id:"enable-the-block-layer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#enable-the-block-layer"}},[t._v("#")]),t._v(" Enable the block layer")]),t._v(" "),e("p",[t._v("块设备支持")]),t._v(" "),e("dl",[e("dt",[t._v("Enable the block layer\nCONFIG_BLOCK")]),t._v(" "),e("dd",[t._v("块设备支持, 使用 SSD / 硬盘 / U 盘 / SCSI/SAS 设备者必选. 除非你是某些特殊的嵌入式系统, 否则没有理由不使用块设备.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Block layer SG support v4\nCONFIG_BLK_DEV_BSG")]),t._v(" "),e("dd",[t._v('为块设备启用第四版 [SG(SCSI generic](http://sg.danny.cz/sg/))支持. v4 相比 v3 能够支持更复杂的 SCSI 指令 (可变长度的命令描述块, 双向数据传输, 通用请求 / 应答协议), 而且 UDEV 也要用它来获取设备的序列号. 对于使用 systemd 的系统来说, 必须选 "Y". 对于不使用 systemd 的系统, 如果你需要通过 / dev/bsg/* 访问块设备, 建议开启此选项, 否则(通过 / dev/{sd*,st*,sr*}) 可以关闭.')]),t._v(" "),e("dt",[t._v("Block layer SG support v4 helper lib\nCONFIG_BLK_DEV_BSGLIB")]),t._v(" "),e("dd",[t._v("你不需要手动开启此选项, 如果有其他模块需要使用, 会被自动开启.")]),t._v(" "),e("dt",[t._v("Block layer data integrity support\nCONFIG_BLK_DEV_INTEGRITY")]),t._v(" "),e("dd",[t._v("某些块设备可以通过存储 / 读取额外的信息来保障[端到端的数据完整性](http://alanwu.blog.51cto.com/3652632/1093600), 这个选项为文件系统提供了相应的钩子函数来使用这个特性. 如果你的设备支持 [T10/SCSI Data Integrity Field](http://www.ibm.com/developerworks/cn/aix/library/au-T10E2E/) 或者 T13/ATA External Path Protection 特性, 那么可以开启此选项, 否则建议关闭.")]),t._v(" "),e("dt",[t._v("Block layer bio throttling support\nCONFIG_BLK_DEV_THROTTLING")]),t._v(" "),e("dd",[t._v('[Bio Throttling](http://lwn.net/Articles/403200/) 支持, 也就是允许限制每个 cgroup 对特定设备的 IO 速率. 细节可以参考 "[Documentation/cgroups/blkio-controller.txt](https://www.kernel.org/doc/Documentation/cgroups/blkio-controller.txt)".')]),t._v(" "),e("dt",[t._v("Block device command line partition parser\nCONFIG_BLK_CMDLINE_PARSER")]),t._v(" "),e("dd",[t._v("允许通过内核引导参数设定块设备的分区信息 ([Documentation/block/cmdline-partition.txt](https://www.kernel.org/doc/Documentation/block/cmdline-partition.txt)). 仅对某些嵌入式设备有意义.")]),t._v(" "),e("dt",[t._v("Advanced partition selection\nCONFIG_PARTITION_ADVANCED")]),t._v(" "),e("dd",[t._v("如果你想支持各种不同的磁盘分区格式 (特别是与 UEFI 配合使用的 [GPT](http://www.ibm.com/developerworks/cn/linux/l-gpt/index.html) 格式), 务必选中此项.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Acorn partition support\nCONFIG_ACORN_PARTITION")]),t._v(" "),e("dd",[t._v("Acorn 操作系统使用的分区格式, 请根据实际情况选择子项, 这里省略")]),t._v(" "),e("dt",[t._v("Alpha OSF partition support\nCONFIG_OSF_PARTITION")]),t._v(" "),e("dd",[t._v("Alpha 平台上使用的分区格式")]),t._v(" "),e("dt",[t._v("Amiga partition table support\nCONFIG_AMIGA_PARTITION")]),t._v(" "),e("dd",[t._v("AmigaOS 使用的分区格式")]),t._v(" "),e("dt",[t._v("Atari partition table support\nCONFIG_ATARI_PARTITION")]),t._v(" "),e("dd",[t._v("Atari OS 使用的分区格式")]),t._v(" "),e("dt",[t._v("Macintosh partition map support\nCONFIG_MAC_PARTITION")]),t._v(" "),e("dd",[t._v("苹果的 Macintosh 平台使用的分区格式")]),t._v(" "),e("dt",[t._v("PC BIOS (MSDOS partition tables) support\nCONFIG_MSDOS_PARTITION")]),t._v(" "),e("dd",[t._v("渐成历史垃圾, 但目前依然最常见的 DOS 分区格式. 除非你确信不使用此格式, 否则必选. 其下的子项根据实际情况选择.")]),t._v(" "),e("dt",[t._v("Windows Logical Disk Manager (Dynamic Disk) support\nCONFIG_LDM_PARTITION")]),t._v(" "),e("dd",[t._v('使用 Windows Logical Disk Manager 创建的分区格式. 参见 "[Documentation/ldm.txt](https://www.kernel.org/doc/Documentation/ldm.txt)"')]),t._v(" "),e("dt",[t._v("SGI partition support\nCONFIG_SGI_PARTITION")]),t._v(" "),e("dd",[t._v("SGI 平台上使用的分区格式")]),t._v(" "),e("dt",[t._v("Ultrix partition table support\nCONFIG_ULTRIX_PARTITION")]),t._v(" "),e("dd",[t._v("DEC/Compaq Ultrix 平台上使用的分区格式")]),t._v(" "),e("dt",[t._v("Sun partition tables support\nCONFIG_SUN_PARTITION")]),t._v(" "),e("dd",[t._v("SunOS 平台上使用的分区格式")]),t._v(" "),e("dt",[t._v("Karma Partition support\nCONFIG_KARMA_PARTITION")]),t._v(" "),e("dd",[t._v("Rio Karma MP3 player 使用的分区格式")]),t._v(" "),e("dt",[t._v("EFI GUID Partition support\nCONFIG_EFI_PARTITION")]),t._v(" "),e("dd",[t._v("代表未来趋势, 眼下正大红大紫的 EFI [GPT](http://www.ibm.com/developerworks/cn/linux/l-gpt/index.html)([GUID Partition Table](http://zh.wikipedia.org/zh-cn/GUID%E7%A3%81%E7%A2%9F%E5%88%86%E5%89%B2%E8%A1%A8)) 分区格式. 建议开启. 如果你在 UEFI 平台上安装则必须开启.")]),t._v(" "),e("dt",[t._v("SYSV68 partition table support\nCONFIG_SYSV68_PARTITION")]),t._v(" "),e("dd",[t._v("Motorola Delta 机器上使用的分区格式")])])]),t._v(" "),e("dt",[t._v("IO Schedulers")]),t._v(" "),e("dd",[t._v("[IO 调度器](http://liwei.life/2016/03/14/linux_io_scheduler/) ([另一篇文章](http://blog.hesey.net/2012/02/linux-io-scheduler.html))")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Deadline I/O scheduler\nCONFIG_IOSCHED_DEADLINE")]),t._v(" "),e("dd",[t._v("[deadline](http://blog.csdn.net/vanbreaker/article/details/8287002) 调度器. 简洁小巧 (只有 400 + 行代码), 提供了最小的读取延迟, 非常适合同一时间只有少数个别进程进行 IO 请求的情况. 如果你希望尽快读取磁盘, 而不介意写入延迟, 那它是最佳选择. 通常对于数据库工作负载有最佳的表现.")]),t._v(" "),e("dt",[t._v("CFQ I/O scheduler\nCONFIG_IOSCHED_CFQ")]),t._v(" "),e("dd",[t._v("[cfq](http://blog.csdn.net/vanbreaker/article/details/8299491)([Complete Fair Queuing](http://blog.csdn.net/vanbreaker/article/details/8308766)) 调度器. 努力在各内核线程间公平分配 IO 资源, 适用于系统中存在着大量内核线程同时进行 IO 请求的情况. 但对于只有少数内核线程进行密集 IO 请求的情况, 则会出现明显的性能下降.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("CFQ Group Scheduling support\nCONFIG_CFQ_GROUP_IOSCHED")]),t._v(" "),e("dd",[t._v('允许将 CFQ 和 cgroup 组合使用, 也就是将每个 cgroup 看成一个整体, 在各 cgroup 之间进行 IO 资源的分配. 参见 "[Documentation/cgroups/blkio-controller.txt](https://www.kernel.org/doc/Documentation/cgroups/blkio-controller.txt)"文件. 还可以参考一下《Linux 内核精髓》中的" [使用 Block I/O 控制器](http://book.51cto.com/art/201302/381375.htm) " 一章.')])])]),t._v(" "),e("dt",[t._v("BFQ I/O scheduler\nCONFIG_IOSCHED_BFQ")]),t._v(" "),e("dd",[t._v("[bfq(Budget Fair Queueing)](http://algo.ing.unimo.it/people/paolo/disk_sched/) 调度器. 这是一个基于 CFQ 调度器的改进版本, 更适合于对交互性要求比较高的场合, 比如桌面系统和实时系统. 如果静态编译进内核, 还支持和 cgroup 配合, 实现分层调度 (hierarchical scheduling).")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("BFQ hierarchical scheduling support\nCONFIG_CGROUP_BFQIO")]),t._v(" "),e("dd",[t._v('通过 cgroup 文件系统接口, 允许将 BFQ 分层使用 (类似 CONFIG_CFQ_GROUP_IOSCHED), 这个子系统的名字是 "bfqio".')])])]),t._v(" "),e("dt",[t._v("Default I/O scheduler")]),t._v(" "),e("dd",[t._v("[默认 IO 调度器](http://www.php-oa.com/2010/01/03/linux-io-elevator.html). 如果上述调度器都是模块, 那么将使用最简单的内置 NOOP 调度器.[NOOP(No Operation)](http://blog.csdn.net/vanbreaker/article/details/8278358) 调度器只是一个简单的 FIFO 队列, 不对 IO 请求做任何重新排序处理 (但还是会做一定程度的归并), 适合于 SSD/U 盘 / 内存 / 虚拟机硬盘 / SAN(Storage Area Networks) 等_无需寻道_的存储设备, 重点是可以节约 CPU 资源, 但不适用于普通硬盘这样的需要依靠磁头来定位的设备. 另外, 有人说拥有 [TCQ](http://hi.baidu.com/51raid/item/96e688b9217b85d285dd7918)/[NCQ](http://blog.sina.com.cn/s/blog_50aa6d5b0100o4hc.html) 技术 (能够自动重新排序) 的硬盘也适合用 NOOP 调度器, 这个说法其实并不那么合理, 但笔者在此不敢断言, 希望读者在严谨的测试之后再做定夺.")])])])])])]),t._v(" "),e("h2",{attrs:{id:"processor-type-and-features"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#processor-type-and-features"}},[t._v("#")]),t._v(" Processor type and features")]),t._v(" "),e("p",[t._v("中央处理器 (CPU) 类型及特性")]),t._v(" "),e("dl",[e("dt",[t._v("DMA memory allocation support\nCONFIG_ZONE_DMA")]),t._v(" "),e("dd",[t._v('允许为寻址宽度不足 32 位的设备 (也就是 ISA 和 [LPC](http://zh.wikipedia.org/wiki/LPC%E5%8C%AF%E6%B5%81%E6%8E%92) 总线设备) 在[物理内存](http://www.ibm.com/developerworks/cn/linux/l-memmod/)的前 16MB 范围内 (也就是传统上 x86_32 架构的 [ZONE_DMA](http://hfli0.blogspot.com/2010/04/why-cannt-we-remove-zonedma-from-linux.html) 区域)分配内存. 不确定的选 "N", 内核中若有其它驱动 (主要是某些老旧的声卡) 需要它会自动选中此项.[提示]LPC 总线通常和主板上的南桥物理相连, 通常连接了一系列的传统设备: BIOS,PS/2 键盘, PS/2 鼠标, 软盘, 并口设备, 串口设备, 某些集成声卡, TPM(可信平台模块), 等等.[题外话][x86_64 已经没有 ZONE_HIGHMEM 了](http://blog.nlogn.cn/why-does-x86_64-not-have-zone_highmem/)')]),t._v(" "),e("dt",[t._v("Symmetric multi-processing support\nCONFIG_SMP")]),t._v(" "),e("dd",[t._v("[SMP(对称多处理器)](https://www.ibm.com/developerworks/cn/linux/l-linux-smp/) 支持, 如果你有多个 CPU 或者使用的是多核 CPU 就选上.")]),t._v(" "),e("dt",[t._v("Processor feature human-readable names\nCONFIG_X86_FEATURE_NAMES")]),t._v(" "),e("dd",[t._v('让 /proc/cpuinfo 中的 CPU 特性标记更具可读性. 选 "Y".')]),t._v(" "),e("dt",[t._v("Support x2apic\nCONFIG_X86_X2APIC")]),t._v(" "),e("dd",[t._v('[x2apic](http://blog.csdn.net/defeattroy/article/details/8988570) 支持. 具有这个特性的 CPU 可以使用 32 位的 APIC ID(可以支持海量的 CPU), 并且可以使用 MSR 而不是 mmio 去访问 local APIC (更加高效). 可以通过 "grep x2apic /proc/cpuinfo" 命令检查你的 CPU 是否支持这个特性. 注意: 有时候还需要在 BIOS 中也开启此特性才真正生效.[提示] 在虚拟机中, 还需要 VMM 的支持 (例如 qemu-kvm).')]),t._v(" "),e("dt",[t._v("Enable MPS table\nCONFIG_X86_MPPARSE")]),t._v(" "),e("dd",[t._v("如果是不支持 acpi 特性的古董级 SMP 系统就选上. 但现今的 64 位系统早都已经支持 acpi 了, 所以可以安全的关闭.")]),t._v(" "),e("dt",[t._v("Support for extended (non-PC) x86 platforms\nCONFIG_X86_EXTENDED_PLATFORM")]),t._v(" "),e("dd",[t._v("支持非标准的 PC 平台: Numascale NumaChip, ScaleMP vSMP, SGI Ultraviolet. 绝大多数人都遇不见这些平台.")]),t._v(" "),e("dt",[t._v("Numascale NumaChip\nCONFIG_X86_NUMACHIP")]),t._v(" "),e("dd",[t._v("[Numascale NumaChip](http://www.numascale.com/numa_products.html) 平台支持")]),t._v(" "),e("dt",[t._v("ScaleMP vSMP\nCONFIG_X86_VSMP")]),t._v(" "),e("dd",[t._v("[ScaleMP vSMP](http://blog.csdn.net/china_world/article/details/6574690) 平台支持")]),t._v(" "),e("dt",[t._v("SGI Ultraviolet\nCONFIG_X86_UV")]),t._v(" "),e("dd",[t._v("[SGI Ultraviolet](http://www.visinfo.com.cn/vis4.html) 平台支持")]),t._v(" "),e("dt",[t._v("Intel Low Power Subsystem Support\nCONFIG_X86_INTEL_LPSS")]),t._v(" "),e("dd",[t._v("为 Intel [Lynx Point](http://ark.intel.com/zh-cn/products/codename/37530/Lynx-Point) [PCH](http://zh.wikipedia.org/wiki/PCH) 或更高级别芯片组中的 Intel Low Power Subsystem 技术提供支持. Lynx Point PCH 芯片组主要是为采用 LGA1150 的 [Haswell](http://zh.wikipedia.org/wiki/Intel_Haswell) 处理器提供支持.")]),t._v(" "),e("dt",[t._v("AMD ACPI2Platform devices support\nCONFIG_X86_AMD_PLATFORM_DEVICE")]),t._v(" "),e("dd",[t._v("为 [AMD Carrizo](http://digi.tech.qq.com/a/20150603/009450.htm) 以及后继架构的 I2C,UART,GPIO 提供支持.")]),t._v(" "),e("dt",[t._v("Intel SoC IOSF Sideband support for SoC platforms\nCONFIG_IOSF_MBI")]),t._v(" "),e("dd",[t._v('为主打低功耗的 Intel SoC 平台 CPU 开启 "sideband" 寄存器访问支持. 这些 CPU 包括:[BayTrail](http://diy.pconline.com.cn/608/6083956_all.html),[Braswell](http://www.techbang.com/posts/23775-intel-braswell-soc-comprehensive-evolution-as-low-price-low-temperatures-but-more-powerful),[Quark](http://ark.intel.com/zh-CN/products/family/79047/Intel-Quark-SoC)')]),t._v(" "),e("dt",[t._v("Single-depth WCHAN output\nCONFIG_SCHED_OMIT_FRAME_POINTER")]),t._v(" "),e("dd",[t._v("使用简化的 /proc/"),e("PID",[t._v('/wchan 值, 禁用此选项会使用更加精确的 wchan 值 (可以在 "ps -l" 结果的 WCHAN 域看到), 但会轻微增加调度器消耗.')])],1),t._v(" "),e("dt",[t._v("Linux guest support\nCONFIG_HYPERVISOR_GUEST")]),t._v(" "),e("dd",[t._v("如果这个内核将在[虚拟机](http://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E6%9C%BA)里面运行就开启, 否则就关闭.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable paravirtualization code\nCONFIG_PARAVIRT")]),t._v(" "),e("dd",[t._v("半虚拟化 (paravirtualization) 支持.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("paravirt-ops debugging\nCONFIG_PARAVIRT_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试.[paravirt-ops](http://www.chenjunlu.com/2013/05/a-common-paravirtualization-interface-paravirt_ops/) 是内核通用的半虚拟化接口.")]),t._v(" "),e("dt",[t._v("Paravirtualization layer for spinlocks\nCONFIG_PARAVIRT_SPINLOCKS")]),t._v(" "),e("dd",[t._v("半虚拟化的自旋锁支持. 开启之后运行在虚拟机里的内核速度会加快, 但是运行在物理 CPU 上的宿主内核运行效率会降低 (最多可能会降低 5%). 请根据实际情况选择.")]),t._v(" "),e("dt",[t._v("Xen guest support\nCONFIG_XEN")]),t._v(" "),e("dd",[t._v("[Xen](http://zh.wikipedia.org/wiki/Xen) 半虚拟化技术支持")])])]),t._v(" "),e("dt",[t._v("Enable Xen debug and tuning parameters in debugfs\nCONFIG_XEN_DEBUG_FS")]),t._v(" "),e("dd",[t._v("为 Xen 在 debugfs 中输出各种统计信息和调整选项. 对性能有严重影响. 仅供调试.")]),t._v(" "),e("dt",[t._v("KVM Guest support (including kvmclock)\nCONFIG_KVM_GUEST")]),t._v(" "),e("dd",[t._v("[KVM](http://wiki.ubuntu.com.cn/Kvm%E6%95%99%E7%A8%8B) 客户机支持 (包括 [kvmclock](http://blog.csdn.net/defeattroy/article/details/8849701)).")]),t._v(" "),e("dt",[t._v("Paravirtual steal time accounting\nCONFIG_PARAVIRT_TIME_ACCOUNTING")]),t._v(" "),e("dd",[t._v("允许进行更细粒度的 task steal time 统计. 会造成性能的略微降低. 仅在你确实需要的时候才开启.")])])]),t._v(" "),e("dt",[t._v("Memtest\nCONFIG_MEMTEST")]),t._v(" "),e("dd",[t._v('为内核添加[内存测试](http://www.memtest86.com/)功能, 也就是添加 "memtest" 内核引导参数以支持对内存进行 "体检". 仅在你确实知道这是什么东西并且确实需要的时候再开启. 否则请关闭.')]),t._v(" "),e("dt",[t._v("Processor family")]),t._v(" "),e("dd",[t._v('处理器系列, 请按照你实际使用的 CPU 选择."Generic-x86-64" 表示通用于所有 x86-64 平台, 而不是针对特定类型的 CPU 进行优化.')]),t._v(" "),e("dt",[t._v("Supported processor vendors\nCONFIG_PROCESSOR_SELECT")]),t._v(" "),e("dd",[t._v("支持的 CPU 厂商, 按实际情况选择.")]),t._v(" "),e("dt",[t._v("Enable DMI scanning\nCONFIG_DMI")]),t._v(" "),e("dd",[t._v('允许扫描 [DMI](http://www.symantec.com/zh/cn/security_response/glossary/define.jsp?letter=d&word=dmi-desktop-management-interface)([Desktop Management Interface](http://www.biosrepair.com/pic/pic46.htm))/[SMBIOS](http://blog.csdn.net/zhoudaxia/article/details/5919699)([System Management BIOS](https://sites.google.com/site/thebackofdaniel/computer/bios/smbios-introduction)) 以[获得机器的硬件配置](http://linux-wiki.cn/wiki/Dmidecode), 从而对已知的 bug bios 进行规避. 具体涉及到哪些机器可参见 "drivers/acpi/blacklist.c" 文件. 除非确定你的机器没有 bug, 否则请开启此项.')]),t._v(" "),e("dt",[t._v("GART IOMMU support\nCONFIG_GART_IOMMU")]),t._v(" "),e("dd",[t._v('为较旧的 AMD Athlon64/Opteron/Turion/Sempron CPU 提供 [GART](http://en.wikipedia.org/wiki/Graphics_address_remapping_table) [IOMMU](http://server.zdnet.com.cn/files/all-1836536.htm) 支持. 图形地址重映射表 ([Graphics Address Remapping Table](http://dri.freedesktop.org/wiki/GART/))可以将物理地址不连续的系统内存映射成看上去连续的图形内存交给 GPU 使用, 是一种挖 CPU 内存补 GPU 内存机制, 这种机制也可以被认为是一种 "伪 IOMMU"(缺乏地址空间隔离和访问控制). 开启此选项以后, 在内存大于 3G 的系统上, 传统的 32 位总线 (PCI/AGP) 的设备将可以使用完全 [DMA](http://blog.csdn.net/peasant_lee/article/details/5594753) 的方式直接访问原本超出 32 位寻址范围之外的系统内存区域. 具体方法是: 通过编程让设备在受 GART 控制的显存区域工作, 然后使用 GART 将这个地址映射为真实的物理地址 (4GB 以上) 来实现的. USB / 声卡 / IDE/SATA 之类的设备常常需要它. 开启此选项之后, 除非同时开启了 CONFIG_IOMMU_DEBUG 选项或者使用了 "iommu=force" 内核引导参数, 否则此特性仅在条件满足的情况下 (内存足够大且确有支持 GART 的设备) 激活. 由于较新的 AMD CPU 都已配备了 AMD IOMMU(应该使用 CONFIG_AMD_IOMMU), 故而仅建议在内存大于 3G 的老式 AMD 系统上选 "Y".')]),t._v(" "),e("dt",[t._v("IBM Calgary IOMMU support\nCONFIG_CALGARY_IOMMU")]),t._v(" "),e("dd",[t._v("IBM xSeries/pSeries 系列服务器的 [Calgary IOMMU](http://bitsup.blogspot.com/2008/03/calgary-iommu-at-what-price.html) 支持.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Should Calgary be enabled by default?\nCONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT")]),t._v(" "),e("dd",[t._v('开启此选项表示默认启用 Calgary 特性, 关闭此选项表示默认禁用 Calgary 特性 (可以使用 "iommu=calgary" 内核引导参数开启).')])])]),t._v(" "),e("dt",[t._v("Enable Maximum number of SMP Processors and NUMA Nodes\nCONFIG_MAXSMP")]),t._v(" "),e("dd",[t._v("让内核支持 x86_64 平台所能支持的最大 SMP 处理器数量和最大 NUMA 节点数量. 主要用于调试目的.")]),t._v(" "),e("dt",[t._v("Maximum number of CPUs\nCONFIG_NR_CPUS")]),t._v(" "),e("dd",[t._v('支持的最大 CPU 数量, 每个 CPU 要占 8KB 的内核镜像, 最小有效值是 "2", 最大有效值是 "512". 注意: 这里的 "CPU 数量" 是指 "逻辑 CPU 数量". 例如, 对于一颗带有超线程技术的 4 核 8 线程 CPU 来说, 相当于拥有 8 个 CPU.')]),t._v(" "),e("dt",[t._v("SMT (Hyperthreading) scheduler support\nCONFIG_SCHED_SMT")]),t._v(" "),e("dd",[t._v("Intel 超线程技术 ([HyperThreading](http://zh.wikipedia.org/wiki/%E8%B6%85%E5%9F%B7%E8%A1%8C%E7%B7%92)) 支持.")]),t._v(" "),e("dt",[t._v("Multi-core scheduler support\nCONFIG_SCHED_MC")]),t._v(" "),e("dd",[t._v("针对多核 CPU 进行调度策略优化")]),t._v(" "),e("dt",[t._v("Preemption Model")]),t._v(" "),e("dd",[t._v("内核抢占模式")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("No Forced Preemption (Server)\nCONFIG_PREEMPT_NONE")]),t._v(" "),e("dd",[t._v("禁止内核抢占, 这是 Linux 的传统模式, 可以得到最大的吞吐量, 适合服务器和科学计算环境")]),t._v(" "),e("dt",[t._v("Voluntary Kernel Preemption (Desktop)\nCONFIG_PREEMPT_VOLUNTARY")]),t._v(" "),e("dd",[t._v("自愿内核抢占, 通过在内核中设置明确的抢占点以允许明确的内核抢占, 可以提高响应速度, 但是对吞吐量有不利影响. 适合普通桌面环境的")]),t._v(" "),e("dt",[t._v("Preemptible Kernel (Low-Latency Desktop)\nCONFIG_PREEMPT")]),t._v(" "),e("dd",[t._v("主动内核抢占, 允许抢占所有内核代码, 对吞吐量有更大影响, 适合需要运行实时程序的场合或者追求最快响应速度的桌面环境.")])])]),t._v(" "),e("dt",[t._v("Reroute for broken boot IRQs\nCONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS")]),t._v(" "),e("dd",[t._v('这是一个对某些[芯片组 bug](http://article.gmane.org/gmane.linux.acpi.devel/36842)(在某些情况下会发送多余的 "[boot IRQ](http://lwn.net/Articles/284826/)") 的修复功能. 开启此选项之后, 仅对有此 bug 的芯片组生效. 要检查哪些芯片组有此 bug 可以查看"[drivers/pci/quirks.c](http://lxr.linux.no/linux/drivers/pci/quirks.c)"文件中的"quirk_reroute_to_boot_interrupts_intel" 函数.')]),t._v(" "),e("dt",[t._v("Machine Check / overheating reporting\nCONFIG_X86_MCE")]),t._v(" "),e("dd",[t._v("[MCE](http://ilinuxkernel.com/?p=303)([mcelog](http://h10025.www1.hp.com/ewfrf/wc/document?cc=cn&lc=zh-hans&doc>Machine Check Exception"),t._v(')支持. 让 CPU 检测到硬件故障 (过热 / 数据错误) 时通知内核, 以便内核采取相应的措施(如显示一条提示信息或关机等). 更多信息可以 )"看看. 可以通过"grep mce /proc/cpuinfo" 检查 CPU 是否支持此特性, 若支持建议选中, 否则请关闭. 当然, 如果你对自己的硬件质量很放心, 又是桌面系统的话, 不选也无所谓.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Intel MCE features\nCONFIG_X86_MCE_INTEL")]),t._v(" "),e("dd",[t._v("Intel CPU 支持")]),t._v(" "),e("dt",[t._v("AMD MCE features\nCONFIG_X86_MCE_AMD")]),t._v(" "),e("dd",[t._v("AMD CPU 支持")])])]),t._v(" "),e("dt",[t._v("Machine check injector support\nCONFIG_X86_MCE_INJECT")]),t._v(" "),e("dd",[t._v("MCE 注入支持, 仅用于调试")]),t._v(" "),e("dt",[t._v("Enable vsyscall emulation\nCONFIG_X86_VSYSCALL_EMULATION")]),t._v(" "),e("dd",[t._v('对过时的 [vsyscall](http://blog.tizgrape.com/lkd%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9Avsyscall%E5%92%8Cvdso/) 页提供仿真支持. 禁用此项大致相当于使用 "vsyscall=none" 内核引导参数 (差别在于当应用程序使用 vsyscall 时将直接崩溃(segfault) 而不会产生警告消息). 许多 2013 年之前编译的程序 (也可能包括某些新近编译的程序) 需要使用此特性.')]),t._v(" "),e("dt",[t._v("Enable support for 16-bit segments\nCONFIG_X86_16BIT")]),t._v(" "),e("dd",[t._v('如果你需要使用 Wine 运行那些古董级的 16 位保护模式程序, 就选 "Y", 否则选 "N"')]),t._v(" "),e("dt",[t._v("Dell laptop support\nCONFIG_I8K")]),t._v(" "),e("dd",[t._v("Dell Inspiron 8000 笔记本的 [System Management Mode](http://en.wikipedia.org/wiki/System_Management_Mode) 驱动 ([i8k](http://my.oschina.net/MinGKai/blog/138554)). 该驱动可以读取 CPU 温度和风扇转速, 进而帮助[上层工具](http://people.debian.org/~dz/i8k/)控制风扇转速. 该驱动仅针对 Dell Inspiron 8000 笔记本进行过测试, 所以不保证一定能适用于其他型号的 Dell 笔记本.")]),t._v(" "),e("dt",[t._v("CPU microcode loading support\nCONFIG_MICROCODE")]),t._v(" "),e("dd",[t._v('CPU 的[微代码更新](http://www.whitecell.org/list.php?id=42)支持, 建议选中. CPU 的微代码更新就像是给 CPU 打补丁, 用于纠正 CPU 的行为. 更新微代码的常规方法是升级 BIOS, 但是也可以在 Linux 启动后更新. 比如在 Gentoo 下, 可以使用 "emerge microcode-ctl" 安装 [microcode-ctl](http://wiki.gentoo.org/wiki/Intel_microcode) 服务, 再把这个服务加入 boot 运行级即可在每次开机时自动更新 CPU 微代码. 其他 Linux 系统可以参考[这个帖子](http://bbs.chinaunix.net/thread-2178586-1-1.html).')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Intel microcode loading support\nCONFIG_MICROCODE_INTEL")]),t._v(" "),e("dd",[t._v("[Intel CPU 微代码](http://www.intel.com/content/www/cn/zh/search.html?context=1047413&tab=767193&keyword=%E5%A4%84%E7%90%86%E5%99%A8%E5%BE%AE%E4%BB%A3%E7%A0%81%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6)支持")]),t._v(" "),e("dt",[t._v("AMD microcode loading support\nCONFIG_MICROCODE_AMD")]),t._v(" "),e("dd",[t._v("AMD CPU 微代码支持")])])]),t._v(" "),e("dt",[t._v("Early load microcode\nCONFIG_MICROCODE_INTEL_EARLY")]),t._v(" "),e("dd",[t._v('支持从 initrd 镜像首部加载微代码, 以便尽可能早的更新 CPU 微代码. 即使在 initrd 首部并未嵌入微代码也不会造成问题, 所以 "Y" 是安全的. 不过你真的需要吗? 笔者认为你一般并不需要:)')]),t._v(" "),e("dt",[t._v("/dev/cpu/*/msr - Model-specific register support\nCONFIG_X86_MSR")]),t._v(" "),e("dd",[t._v('允许用户空间的特权进程 (使用 rdmsr 与 wrmsr 指令) 访问 x86 的 [MSR 寄存器](http://blog.csdn.net/edonlii/article/details/8685713) ([Model-Specific Register](http://en.wikipedia.org/wiki/Model-specific_register)) 以访问 CPU 的很多重要的参数. MSR 是非标准寄存器, 主要用于读取 CPU 的工作状态 (频率 / 电压 / 功耗 / 温度 / 性能等), 以及设置 CPU 的工作参数 (触发特定的 CPU 特性, 依 CPU 的不同而不同).[msrtool](http://www.coreboot.org/Msrtool) 工具可以转储出 MSR 的内容. 不确定的可以选 "M".')]),t._v(" "),e("dt",[t._v("/dev/cpu/*/cpuid - CPU information support\nCONFIG_X86_CPUID")]),t._v(" "),e("dd",[t._v('允许用户空间的特权进程使用 [CPUID](http://www.cnblogs.com/fence/archive/2010/05/27/1745742.html) 指令获得详细的 [CPU 信息](http://wenku.baidu.com/view/4105c609bb68a98271fefaf8.html) ([CPUID](http://www.mouseos.com/arch/CPUID.html)):CPU 类型, 型号, 制造商信息, 商标信息, 序列号, 缓存等. 不确定的可以选 "M".')]),t._v(" "),e("dt",[t._v("Enable 1GB pages for kernel pagetables\nCONFIG_DIRECT_GBPAGES")]),t._v(" "),e("dd",[t._v('允许[内核页表](http://www.sigma.me/2011/01/22/mem-page-tlb.html)使用大小为 1GB 的 [Hugepages](http://wiki.debian.org/Hugepages) 并进行直线映射 (linear mapping), 需要高端 CPU 的支持 (可以用 "grep pdpe1gb /proc/cpuinfo" 命令检查). 这可以减小[页表缓存](http://zh.wikipedia.org/wiki/%E8%BD%89%E8%AD%AF%E5%BE%8C%E5%82%99%E7%B7%A9%E8%A1%9D%E5%8D%80) ([Translation Lookaside Buffer](http://en.wikipedia.org/wiki/Translation_lookaside_buffer))的压力, 从而提升系统的性能, 这对于拥有海量内存并且运行某些特定应用 (PosgreSQL,MySQL,Java,Memcached,KVM,Xen...) 的系统来说比较有意义. 如果你的 CPU 支持, 可以选 "Y".')]),t._v(" "),e("dt",[t._v("Numa Memory Allocation and Scheduler Support\nCONFIG_NUMA")]),t._v(" "),e("dd",[t._v('开启 [NUMA(Non Uniform Memory Access)](http://www.ibm.com/developerworks/cn/linux/l-numa/index.html) 支持. 虽然说集成了内存控制器的 CPU 都属于 NUMA 架构. 但事实上, 对于大多数只有一颗物理 CPU 的个人电脑而言, 即使支持 NUMA 架构, 也没必要开启此特性. 可以参考 [SMP/NUMA/MPP 体系结构对比](http://www.cnblogs.com/yubo/archive/2010/04/23/1718810.html). 此外, 对于不支持 "虚拟 NUMA", 或 "虚拟 NUMA" 被禁用的虚拟机 (即使所在的物理机是 NUMA 系统), 也应该关闭此项.')]),t._v(" "),e("dt",[t._v("Old style AMD Opteron NUMA detection\nCONFIG_AMD_NUMA")]),t._v(" "),e("dd",[t._v("因为 AMD 使用一种旧式的方法读取 NUMA 配置信息 (新式方法是 CONFIG_X86_64_ACPI_NUMA), 所以如果你使用的是 AMD 多核 CPU, 建议开启. 不过, 即使开启此选项, 内核也会优先尝试 CONFIG_X86_64_ACPI_NUMA 方法, 仅在失败后才会使用此方法, 所以即使你不能确定 CPU 的类型也可以安全的选中此项.")]),t._v(" "),e("dt",[t._v("ACPI NUMA detection\nCONFIG_X86_64_ACPI_NUMA")]),t._v(" "),e("dd",[t._v("使用基于 ACPI SRAT(System Resource Affinity Table) 技术的 NUMA 节点探测方法. 这也是检测 NUMA 节点信息的首选方法, 建议选中.")]),t._v(" "),e("dt",[t._v("NUMA emulation\nCONFIG_NUMA_EMU")]),t._v(" "),e("dd",[t._v("仅供开发调试使用")]),t._v(" "),e("dt",[t._v("Maximum NUMA Nodes (as a power of 2)\nCONFIG_NODES_SHIFT")]),t._v(" "),e("dd",[t._v("允许的最大 NUMA 节点数. 需要注意其计算方法: 最大允许节点数 = 2"),e("sup",[t._v("CONFIG_NODES_SHIFT")]),t._v(". 也就是说这里设置的值会被当做 2 的指数使用. 取值范围是 [1,10], 也就最多允许 1024 个节点.")]),t._v(" "),e("dt",[t._v("Memory model")]),t._v(" "),e("dd",[t._v('[内存模式](http://wangcong.org/blog/archives/2043)."Sparse Memory" 主要用来支持内存热插拔, 相比其他两个旧有的内存模式, 代码复杂性也比较低, 而且还拥有一些性能上的优势, 对某些架构而言是唯一的可选项. 其他两个旧有的内存模式是:"[Discontiguous Memory](http://www.technovelty.org/linux/discontiguous-memory.html)"和"[Flat Memory](http://zh.wikipedia.org/wiki/%E5%B9%B3%E9%9D%A2%E8%A8%98%E6%86%B6%E9%AB%94%E6%A8%A1%E5%BC%8F)".')]),t._v(" "),e("dt",[t._v("Sparse Memory virtual memmap\nCONFIG_SPARSEMEM_VMEMMAP")]),t._v(" "),e("dd",[t._v("对于 64 位 CPU 而言, 开启此选项可以简化 pfn_to_page/page_to_pfn 的操作, 从而提高内核的运行效率. 但是在 32 位平台则建议关闭. 更多细节可以参考[这个帖子](http://markmail.org/message/x3hpe4sapu4iegga).")]),t._v(" "),e("dt",[t._v("Enable to assign a node which has only movable memory\nCONFIG_MOVABLE_NODE")]),t._v(" "),e("dd",[t._v("允许对一个完整的 NUMA 节点 (CPU 和对应的内存) 进行热插拔. 一般的服务器和个人电脑不需要这么高级的特性.")]),t._v(" "),e("dt",[t._v("Allow for memory hot-add\nCONFIG_MEMORY_HOTPLUG")]),t._v(" "),e("dd",[t._v("支持向运行中的系统添加内存. 也就是内存热插支持.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Allow for memory hot remove\nCONFIG_MEMORY_HOTREMOVE")]),t._v(" "),e("dd",[t._v("支持从运行中的系统移除内存. 也就是内存热拔支持.")])])]),t._v(" "),e("dt",[t._v("Allow for balloon memory compaction/migration\nCONFIG_BALLOON_COMPACTION")]),t._v(" "),e("dd",[t._v("允许压缩 / 合并气球内存 ([balloon memory](http://smilejay.com/2012/11/kvm-ballooning-overview/)). [内存气球技术](http://delxu.blog.51cto.com/975660/288682)是指虚拟机在运行时动态地调整它所占用的宿主机内存资源, 该技术在节约内存和灵活分配内存方面有明显的优势, 目前所有主流虚拟化方案都支持这项技术 (前提是客户机操作系统中必须安装有相应的 balloon 驱动). 由于内存的动态增加和减少会导致内存过度碎片化, 特别是对于 2M 尺寸的连续大内存页来说更加严重, 从而严重降低内存性能. 允许 balloon 内存压缩和合并可以很好的解决在客户机中使用大内存页时内存过度碎片化问题. 如果你打算在虚拟机中使用大内存页 (huge page), 那么建议开启, 否则建议关闭.")]),t._v(" "),e("dt",[t._v("Allow for memory compaction\nCONFIG_COMPACTION")]),t._v(" "),e("dd",[t._v("允许对[大内存页 (huge pages)](http://www.dbafan.com/blog/?p=435) 进行[压缩](http://lwn.net/Articles/368869/). 主要是为了解决大内存页的碎片问题. 建议在使用大内存页的情况下开启此项, 否则建议关闭.")]),t._v(" "),e("dt",[t._v("Page migration\nCONFIG_MIGRATION")]),t._v(" "),e("dd",[t._v("允许在保持虚拟内存页地址不变的情况下移动其所对应的物理内存页的位置. 这主要是为了解决两个问题:(1) 在 NUMA 系统上, 将物理内存转移到相应的节点上, 以加快 CPU 与内存之间的访问速度.(2) 在分配大内存页的时候, 可以避免碎片问题.")]),t._v(" "),e("dt",[t._v("Enable bounce buffers\nCONFIG_BOUNCE")]),t._v(" "),e("dd",[t._v("为那些不能直接访问所有内存范围的驱动程序开启 [bounce buffer](http://blog.csdn.net/force_eagle/article/details/7723772) 支持. 当 CONFIG_ZONE_DMA 被开启后, 这个选项会被默认开启 (当然, 你也可以在这里手动关闭). 这主要是为了那些不具备 [IOMMU](http://blog.csdn.net/force_eagle/article/details/7744896) 功能的 PCI/ISA 设备而设, 但它对性能有些不利影响. 在支持 IOMMU 的设备上, 应该关闭它而是用 IOMMU 来代替.")]),t._v(" "),e("dt",[t._v("Enable KSM for page merging\nCONFIG_KSM")]),t._v(" "),e("dd",[t._v('[KSM](http://buycloud.com.cn/wordpress/?p=348)([Kernel Samepage Merging](http://blog.chinaunix.net/uid-20794164-id-3601786.html)) 支持: 周期性的扫描那些被应用程序标记为 "可合并" 的地址空间, 一旦发现有内容完全相同的页面, 就将它们合并为同一个页面, 这样就可以节约内存的使用, 但对性能有不利影响. 推荐和内核虚拟机 KVM([Documentation/vm/ksm.txt](https://www.kernel.org/doc/Documentation/vm/ksm.txt)) 或者其他支持 "MADV_MERGEABLE" 特性的应用程序一起使用. KSM 并不默认开启, 仅在应用程序设置了 "MADV_MERGEABLE" 标记, 并且 /sys/kernel/mm/ksm/run 被设为 "1" 的情况下才会生效.')]),t._v(" "),e("dt",[t._v("Low address space to protect from user allocation\nCONFIG_DEFAULT_MMAP_MIN_ADDR")]),t._v(" "),e("dd",[t._v('2009 年, 内核曾经爆过一个严重的 [NULL 指针漏洞](http://baoz.net/linux-sockops-wrap-proto-ops-local-root-exploit/), 由于其根源是将 NULL 指针映射到地址 "0" 所致, 所以从 2.6.32 版本以后, 为了防止此类漏洞再次造成严重后果, 特别设置了此选项, 用于指定受保护的内存低端地址范围 (可以在系统运行时通过 [/proc/sys/vm/mmap_min_addr](http://wiki.debian.org/mmap_min_addr) 进行调整), 这个范围内的地址禁止任何用户态程序的写入, 以从根本上堵死此类漏洞可能对系统造成的损害. 但内核这种强加的限制, 对于需要使用 vm86 系统调用 (用于在保护模式的进程中模拟 8086 的实模式) 或者需要映射此低端地址空间的程序 (bitbake,dosemu,qemu,wine,...) 来说, 则会造成不兼容, 不过目前这些程序的新版本都进行了改进, 以适应内核的这种保护. 一般情况下,"65536" 是个明智的选择.')]),t._v(" "),e("dt",[t._v("Enable recovery from hardware memory errors\nCONFIG_MEMORY_FAILURE")]),t._v(" "),e("dd",[t._v("在具备 [MCA(Machine Check Architecture)](http://en.wikipedia.org/wiki/Machine_check_architecture) 恢复机制的系统上, 允许内核在物理内存中的发生数据错误的情况下, 依然坚强的纠正错误并恢复正常运行. 这需要有相应的硬件 (通常是 ECC 内存) 支持. 有 [ECC 内存](http://www.zzec.cn/help/html/?138.html)的选, 没有的就别选了.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("HWPoison pages injector\nCONFIG_HWPOISON_INJECT")]),t._v(" "),e("dd",[t._v("仅用于调试.")])])]),t._v(" "),e("dt",[t._v("Transparent Hugepage Support\nCONFIG_TRANSPARENT_HUGEPAGE")]),t._v(" "),e("dd",[t._v('大多数现代计算机体系结构都支持多种不同的[内存页面](http://en.wikipedia.org/wiki/Page_%28computer_memory%29)大小 (比如 x86_64 支持 4K 和 2M 以及 1G[需要 cpu-flags 中含有 "pdpe1gb"]). 大于 4K 的内存页被称为 " [大页](http://www.ibm.com/developerworks/cn/linux/1305_zhangli_hugepage/) "([Hugepage](https://wiki.debian.org/Hugepages)).[TLB](http://en.wikipedia.org/wiki/Translation_lookaside_buffer)([页表缓存](http://zh.wikipedia.org/wiki/%E8%BD%89%E8%AD%AF%E5%BE%8C%E5%82%99%E7%B7%A9%E8%A1%9D%E5%8D%80)) 是位于 CPU 内部的[分页表](http://zh.wikipedia.org/wiki/%E5%88%86%E9%A0%81%E8%A1%A8) (虚拟地址到物理地址的映射表)缓冲区, 既高速又很宝贵 (尺寸很小). 如果系统内存很大(大于 4G) 又使用 4K 的内存页, 那么分页表将会变得很大而难以在 CPU 内缓存, 从而导致较高的 TLB 不命中概率, 进而降低系统的运行效率. 开启大内存页支持之后, 就可以使用大页(2M 或 1G), 从而大大缩小分页表的尺寸以大幅提高 TLB 的命中率, 进而[优化系统性能](http://kenwublog.com/tune-large-page-for-jvm-optimization). 传统上使用大内存页的方法是通过 Hugetlbfs 虚拟文件系统 (CONFIG_HUGETLBFS), 但是 hugetlbfs 需要专门进行配置以及应用程序的特别支持. 所以从 2.6.38 版本开始引入了 [THP](http://lp007819.wordpress.com/2011/03/23/kernel-2-6-38-%E7%89%B9%E6%80%A7-transparent-huge-pages/)([Transparent Hugepages](http://blog.chinaunix.net/uid-26489617-id-3205109.html)), 目标是替代先前的 Hugetlbfs 虚拟文件系统 (CONFIG_HUGETLBFS).THP 允许内核在可能的条件下, 透明的 (对应用程序来说) [使用大页](http://lenky.info/2012/03/03/linux%E4%B8%8Bhugetlbpage%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/) ([huge pages](http://www.dbaleet.org/tag/hugepages/)) 与 [HugeTLB](http://www.ibm.com/developerworks/cn/linux/l-cn-hugetlb/),THP 不像 hugetlbfs 那样需要专门进行配置以及应用程序的特别支持. THP 将这一切都交给操作系统来完成, 也不再需要额外的配置, 对于应用程序完全透明, 因而可用于更广泛的应用程序. 这对于数据库 / KVM 等需要使用大量内存的应用来说, 可以提升其效能, 但对于内存较小 (4G 或更少) 的个人 PC 来说就没啥必要了. 详见 "[Documentation/vm/transhuge.txt](https://www.kernel.org/doc/Documentation/vm/transhuge.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Transparent Hugepage Support sysfs defaults")]),t._v(" "),e("dd",[t._v('设置 /sys/kernel/mm/transparent_hugepage/enabled 文件的默认值."always" 表示总是对所有应用程序启用透明大内存页支持,"madvise" 表示仅对明确要求该特性的程序启用. 建议选 "always".')])])]),t._v(" "),e("dt",[t._v("Cross Memory Support[Enable process_vm_readv/writev syscalls]\nCONFIG_CROSS_MEMORY_ATTACH")]),t._v(" "),e("dd",[t._v("[交叉内存](http://lwn.net/Articles/405284/)支持, 也就是 [process_vm_readv() 和 process_vm_writev() 系统调用](http://bookjovi.iteye.com/blog/1229689)支持. 从而允许有权限的进程直接读取 / 写入另外一个进程的地址空间. 现在它们只用于 [openMPI](http://www.cnblogs.com/jpcflyer/archive/2012/03/04/2379048.html) 快速进程通信, 也可以用于调试程序. 未来也许还会有其他用途.")]),t._v(" "),e("dt",[t._v("Enable cleancache driver to cache clean pages if tmem is present\nCONFIG_CLEANCACHE")]),t._v(" "),e("dd",[t._v('[Cleancache](http://lwn.net/Articles/386090/) 是内核 VFS 层新增的特性, 可以被看作是内存页的 "[Victim Cache](http://memcache.drivehq.com/memparam/Bench/Other/VictimCache.htm)"([受害者缓存](http://sse.tongji.edu.cn/arch/arch_course/architecture/chapter4/lecture4/htm/lecture4_6.htm)), 当回收内存页时, 先不把它清空, 而是把其加入到内核不能直接访问的 "[transcendent memory](http://sohulinux.blog.sohu.com/183867412.html)"中, 这样支持 Cleancache 的文件系统再次访问这个页时可以直接从"transcendent memory" 加载它, 从而减少磁盘 IO 的损耗. 目前只有 [zcache](http://lwn.net/Articles/397574/) 和 [XEN](http://zh.wikipedia.org/zh-cn/Xen) 支持 "transcendent memory", 不过将来会有越来越多的应用支持. 开启此项后即使此特性不能得到利用, 也仅对性能有微小的影响, 所以建议开启. 更多细节请参考 "[Documentation/vm/cleancache.txt](https://www.kernel.org/doc/Documentation/vm/cleancache.txt)" 文件.')]),t._v(" "),e("dt",[t._v("Enable frontswap to cache swap pages if tmem is present\nCONFIG_FRONTSWAP")]),t._v(" "),e("dd",[t._v('[Frontswap](http://lwn.net/Articles/386090/) 是和 Cleancache 非常类似的东西, 在传统的 swap 前加一道内存缓冲 (同样位于 "transcendent memory" 中). 目的也是减少 swap 时的磁盘读写. CONFIG_ZSWAP 依赖于它, 建议开启.')]),t._v(" "),e("dt",[t._v("Contiguous Memory Allocator\nCONFIG_CMA")]),t._v(" "),e("dd",[t._v('这是一个分配连续物理内存页面的分配器. 一些比较低端的 DMA 设备只能访问连续的物理内存, 同时透明大内存页也需要连续的物理内存. 传统的解决办法是在系统启动时, 在内存还很充足的时候, 先预留一部分连续物理内存页面, 留作后用, 但这部分内存就无法被挪作他用了, 为了可能的分配需求, 预留这么一大块内存, 并不是一个明智的方法. 而[连续内存分配器](http://blog.csdn.net/21cnbao/article/details/7309757) ([Contiguous Memory Allocator](http://lwn.net/Articles/447405/)) 可以做到允许这部分预留的内存被正常使用, 仅在确实需要的时候才将大块的连续物理内存分配给相应的驱动程序. 这个机制对于那些不支持 I/O map 和 scatter-gather 的设备很有作用. 详情参见 "include/linux/dma-contiguous.h" 文件. 此选项仅对嵌入式系统有意义, 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Track memory changes\nCONFIG_MEM_SOFT_DIRTY")]),t._v(" "),e("dd",[t._v('在内核页表的 PTE(Page Table Entry) 数据结构上添加一个 "soft-dirty" 位以追踪内存页内容的变化. 此特性基本上专用于 [CRIU(Checkpoint/Restore In Userspace)](http://criu.org) 项目 (可以帮助容器进行热迁移). 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Compressed cache for swap pages\nCONFIG_ZSWAP")]),t._v(" "),e("dd",[t._v('[ZSWAP](http://blog.druggo.org/post/2014/05/02/ZSWAP-ZRAM) 是一个放置在 swap 前面的压缩缓存, 它可以将需要换出的页压缩存放在内存中的压缩池里, 这样在压缩池没有满的时候, 可以避免使用真正的 swap 设备. 当压缩池满的时候, 则把最老的页解压后写入 swap 设备. 压缩池默认是内存总量的 20%(/sys/module/zswap/parameters/max_pool_percent).[ZSWAP](https://zh.wikipedia.org/wiki/Zswap) 不仅提升了 swap 的整体性能, 也变相的增加了 swap 空间. 选中此项后, 可以通过 "zswap.enabled=1" 内核引导参数开启此功能.')]),t._v(" "),e("dt",[t._v("Common API for compressed memory storage\nCONFIG_ZPOOL")]),t._v(" "),e("dd",[t._v('通用的[内存压缩 API](http://kernel.taobao.org/index.php?title=%E5%86%85%E6%A0%B8%E6%9C%88%E6%8A%A52013-04#In-kernel_memory_compression), 主要用于给 zbud(zswap) 或 zsmalloc 提供支持. 不确定的选 "N", 如果内核有其他选项依赖于它会自动选中.')]),t._v(" "),e("dt",[t._v("Low density storage for compressed pages\nCONFIG_ZBUD")]),t._v(" "),e("dd",[t._v('专用于 zswap 内部的低密度内存压缩 API, 最多允许将两个物理内存页压缩为一个压缩内存页, 这既有优势 (简单的空间收集及空闲空间复用) 也有劣势(潜在的低内存利用率). 此种算法还能确保压缩后的内存页不会比最初未压缩页数多. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Memory allocator for compressed pages\nCONFIG_ZSMALLOC")]),t._v(" "),e("dd",[t._v("[zsmalloc](http://lwn.net/Articles/477067/) 压缩内存分配器主要用于给 [zram](http://zh.wikipedia.org/zh-cn/Zram) 提供支持, 建议与 CONFIG_ZRAM 同开关. 参考:[3 种内存压缩方案对比](http://kernel.taobao.org/index.php/%E5%86%85%E6%A0%B8%E6%9C%88%E6%8A%A52013-04#In-kernel_memory_compression).")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Use page table mapping to access object in zsmalloc\nCONFIG_PGTABLE_MAPPING")]),t._v(" "),e("dd",[t._v('zsmalloc 默认使用基于内存复制的对象映射方法来访问跨越不同页面的区域, 但如果某些架构 (例如 ARM) 执行虚拟内存映射的速度快于内存复制, 那么应该将此项选 "Y", 这将导致 zsmalloc 使用页表映射而不是内存复制来进行对象的映射. 你可以在你的系统上使用 "https://github.com/spartacus06/zsmapbench" 脚本来测试这两种方法的速度差异. 在 x86_64 平台上, Debian8 与 Fedora22 与 openSUSE13 此项默认为 "N", 而 Ubuntu15 此项默认为 "Y", 作者本人未测试过哪个更合理.')])])]),t._v(" "),e("dt",[t._v("Enable idle page tracking\nCONFIG_IDLE_PAGE_TRACKING")]),t._v(" "),e("dd",[t._v('此特性跟踪哪些用户页面需要被工作负载使用, 哪些用户页面处于闲置状态. 此信息 (/sys/kernel/mm/page_idle) 可用于确定工作负载需要的用户内存大小. 从而帮助调优内存 cgroup 限制以及决定将此任务放置到集群中的那台机器上. 参见 [Documentation/vm/idle_page_tracking.txt](https://www.kernel.org/doc/Documentation/vm/idle_page_tracking.txt) 文档. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Support non-standard NVDIMMs and ADR protected memory\nCONFIG_X86_PMEM_LEGACY")]),t._v(" "),e("dd",[t._v("支持 Intel Sandy Bridge-EP 处理器使用的不符合 [NVDIMM](http://servers.pconline.com.cn/522/5222919.html) 规范的[非易失内存](http://alanwu.blog.51cto.com/3652632/1618303) (以电容做后备电力且掉电后不会丢失数据的内存). 仅有某些高端服务器才会使用这种外带电容供电的内存.")]),t._v(" "),e("dt",[t._v("Check for low memory corruption\nCONFIG_X86_CHECK_BIOS_CORRUPTION")]),t._v(" "),e("dd",[t._v('低位内存脏数据检查, 即使开启此选项, 默认也不会开启此功能 (需要明确使用 "memory_corruption_check=1" 内核引导选项). 这些脏数据通常被认为是有 bug 的 BIOS 引起的, 默认每 60 秒(可以通过 memory_corruption_check_period 内核参数进行调整) 扫描一次 0-64k(可以通过 memory_corruption_check_size 内核参数进行调整)之间的区域. 这种检查所占用的开销非常小, 基本可以忽略不计. 如果始终检查到错误, 则可以通过 "memmap=" 内核引导参数来避免使用这段内存. 一般没必要选中, 如果你对 BIOS 不放心, 带着它试运行一段时间, 确认没问题之后再去掉.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Set the default setting of memory_corruption_check\nCONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK")]),t._v(" "),e("dd",[t._v('设置 memory_corruption_check 的默认值, 选中表示默认开启 (相当于使用 "memory_corruption_check=1" 内核引导选项), 不选中表示默认关闭.')])])]),t._v(" "),e("dt",[t._v("Amount of low memory, in kilobytes, to reserve for the BIOS\nCONFIG_X86_RESERVE_LOW")]),t._v(" "),e("dd",[t._v('为 BIOS 设置保留的低端地址 (默认是 64K). 内存的第一页(4K) 存放的必定是 BIOS 数据, 内核不能使用, 所以必须要保留. 但是有许多 BIOS 还会在 suspend/resume / 热插拔等事件发生的时候使用更多的页(一般在 0-64K 范围), 所以默认保留 0-64K 范围. 如果你确定自己的 BIOS 不会越界使用内存的话, 可以设为 "4", 否则请保持默认值. 但是也有一些很奇葩的 BIOS 会使用更多的低位内存, 这种情况下可以考虑设为 "640" 以保留所有 640K 的低位内存区域.')]),t._v(" "),e("dt",[t._v("MTRR (Memory Type Range Register) support\nCONFIG_MTRR")]),t._v(" "),e("dd",[t._v("[MTRR](http://blog.csdn.net/arethe/article/details/6248448)([Memory type range registers](http://blog.chinaunix.net/uid-25871104-id-3140904.html))是 CPU 内的一组 MSR(Model-specific registers), 其作用是告诉 CPU 以哪种模式 (write-back/uncachable/...) 存取各内存区段效率最高. 这对于 AGP/PCI 显卡意义重大, 因为 write-combining 技术可以将若干个总线写传输捆绑成一次较大的写传输操作, 可以将图像写操作的性能提高 2.5 倍或者更多. 这段代码有着通用的接口, 其他 CPU 的寄存器同样能够使用该功能. 简而言之, 开启此选项是个明智的选择.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("MTRR cleanup support\nCONFIG_MTRR_SANITIZER")]),t._v(" "),e("dd",[t._v('[MTRR cleanup](http://www.linuxquestions.org/questions/linux-kernel-70/what-is-mtrr-cleanup-spare-reg-num-about-814410/) 的功能是将 MTRR 中的内存布局由连续布局转化为离散布局, 这样 X 驱动就可以在其中添加 writeback 项 (也就是一个内存段), 算是一种优化措施. 建议开启. 可以使用 "mtrr_chunk_size" 来限制每段内存的最大尺寸.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("MTRR cleanup enable value (0-1)\nCONFIG_MTRR_SANITIZER_ENABLE_DEFAULT")]),t._v(" "),e("dd",[t._v('"1" 表示默认开启 CONFIG_MTRR_SANITIZER 特性, 相当于使用 "enable_mtrr_cleanup","0" 表示默认关闭 CONFIG_MTRR_SANITIZER 特性, 相当于使用 "disable_mtrr_cleanup". 建议图形界面用户设为 "1". 仅在开启后导致无法正常启动或者显卡驱动不能正常工作的情况下才需要关闭.')]),t._v(" "),e("dt",[t._v("MTRR cleanup spare reg num (0-7)\nCONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT")]),t._v(" "),e("dd",[t._v('这里设定的值等价于使用内核引导参数 "mtrr_spare_reg_nr=N" 中的 "N". 也就是告诉内核有多少个内存段 (reg) 可以被清理或改写(参见 "/proc/mtrr" 文件). 在多数情况下默认值是 "1", 其含义是最多允许使用 1 个空闲的 "reg". 一般保持其默认值即可. 修改此项的值通常是为了解决某些 [MTRR 故障](http://my-fuzzy-logic.de/blog/index.php?/archives/41-Solving-linux-MTRR-problems.html).')])])]),t._v(" "),e("dt",[t._v("x86 PAT support\nCONFIG_X86_PAT")]),t._v(" "),e("dd",[t._v("[PAT](http://blog.csdn.net/arethe/article/details/6238335)([Page Attribute Table](https://wiki.gentoo.org/wiki/MTRR_and_PAT)) 是对 MTRR 的补充, 且比 MTRR 更灵活. 如果你的 CPU 支持 PAT(grep pat /proc/cpuinfo), 那么建议开启. 仅在开启后导致无法正常启动或者显卡驱动不能正常工作的情况下才需要关闭.")])])]),t._v(" "),e("dt",[t._v("x86 architectural random number generator\nCONFIG_ARCH_RANDOM")]),t._v(" "),e("dd",[t._v('Intel 从 [Ivy Bridge](http://zh.wikipedia.org/wiki/Intel_Ivy_Bridge) 微架构开始 (对于 Atom 来说是从 Silvermont 开始), 在 CPU 中集成了一个高效的硬件随机数生成器 (称为 "Bull Mountain" 技术), 并引入了一个新的 x86 指令 "[RDRAND](http://en.wikipedia.org/wiki/RdRand)", 可以非常高效的产生随机数. 此选项就是对此特性的支持.')]),t._v(" "),e("dt",[t._v("Supervisor Mode Access Prevention\nCONFIG_X86_SMAP")]),t._v(" "),e("dd",[t._v("[SMAP(Supervisor Mode Access Prevention)](http://lwn.net/Articles/517475/) 是 Intel 从 [Haswell](http://zh.wikipedia.org/wiki/Intel_Haswell) 微架构开始引入的一种新特征, 它在 CR4 寄存器上引入一个新标志位 SMAP, 如果这个标志为 1, 内核访问用户进程的地址空间时就会触发一个页错误, 目的是为了防止内核因为自身错误意外访问用户空间, 这样就可以避免一些内核漏洞所导致的安全问题. 但是由于内核在有些时候仍然需要访问用户空间, 因此 intel 提供了两条指令 STAC 和 CLAC 用于临时打开 / 关闭这个功能, 反复使用 STAC 和 CLAC 会带来一些轻微的性能损失, 但考虑到增加的安全性, 还是建议开启.")]),t._v(" "),e("dt",[t._v("Intel MPX (Memory Protection Extensions)\nCONFIG_X86_INTEL_MPX")]),t._v(" "),e("dd",[t._v('[Intel MPX](https://software.intel.com/en-us/taxonomy/term/43113)(内存保护扩展) 是一种用于检测缓冲区溢出 bug 的硬件特性. 此选项并非用于保护内核自身, 而是用于允许应用程序利用 MPX 特性. 可以通过 "grep mpx /proc/cpuinfo" 检查你的 CPU 是否支持 MPX 特性. 详见 [Documentation/x86/intel_mpx.txt](https://www.kernel.org/doc/Documentation/x86/intel_mpx.txt) 文档. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("EFI runtime service support\nCONFIG_EFI")]),t._v(" "),e("dd",[t._v('[EFI/UEFI](http://baike.baidu.com/view/196503.htm) 支持. 如果你打算[在 UEFI/EFI 平台上安装 Linux](http://wiki.gentoo.org/wiki/UEFI_Gentoo_Quick_Install_Guide)(2010 年之后的机器基本都已经是 UEFI 规格了), 那么就必须开启此项 (开启后也依然可以在传统的 BIOS 机器上启动).[UEFI 启动流程](http://blog.woodelf.org/2014/05/28/how-uefi-works-translated/)与传统的 BIOS 相差很大. 虽然 Linux 受到了所谓 " [安全启动](http://blogs.msdn.com/b/b8_cn/archive/2011/09/27/uefi.aspx) " 问题的阻挠 (已经[解决](http://news.mydrivers.com/1/254/254690.htm)), 但是 UEFI 依然将迅速一统江湖.[提示] 在 UEFI 平台上安装 Linux 的关键之一是首先要用一个支持 UEFI 启动的 LiveCD 以 UEFI 模式启动机器.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("EFI stub support\nCONFIG_EFI_STUB")]),t._v(" "),e("dd",[t._v('[EFI stub](http://wiki.gentoo.org/wiki/EFI_stub_kernel) 支持. 如果开启此项, 就可以不通过 GRUB2 之类的引导程序来加载内核, 而直接由 EFI 固件进行加载, 这样就可以不必安装引导程序了. 不过这是一个看上去很美的特性, 由于 EFI 固件灵活性比 GRUB2 差许多, 所以缺点有三:(1)不能在传统的 BIOS 机器上启动.(2)给内核传递引导参数很麻烦 (需要使用 "efibootmgr -u").(3) 不能使用 intrd. 不过, 针对后两点的解决办法是: 使用 CONFIG_CMDLINE 和 CONFIG_INITRAMFS_SOURCE. 更多细节可参考 "[Documentation/x86/efi-stub.txt](https://www.kernel.org/doc/Documentation/x86/efi-stub.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("EFI mixed-mode support\nCONFIG_EFI_MIXED")]),t._v(" "),e("dd",[t._v('允许在 32 位固件上启动 64 位内核. 选 "N".')])])])])]),t._v(" "),e("dt",[t._v("Enable seccomp to safely compute untrusted bytecode\nCONFIG_SECCOMP")]),t._v(" "),e("dd",[t._v("允许使用 [SECCOMP](http://plaintext.blog.edu.cn/2010/553458.html) 技术安全地运算非信任代码. 通过使用管道或其他进程可用的通信方式作为文件描述符 (支持读 / 写调用), 就可以利用 SECCOMP 把这些应用程序隔离在它们自己的地址空间. 这是一种有效的安全沙盒技术. systemd 也强烈建议开启它. 除非你是嵌入式系统, 否则不要关闭.")]),t._v(" "),e("dt",[t._v("Enable -fstack-protector buffer overflow detection\nCONFIG_CC_STACKPROTECTOR")]),t._v(" "),e("dd",[t._v('开启 GCC 的 "-fstack-protector" 命令行选项, 以使用 [GCC 中的编译器堆栈保护技术](http://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/). 这样可以有效的防御以堆栈溢出为代表的缓冲区溢出攻击, 不过系统的运行速度也会受到一些影响. 服务器之类强调安全的场合建议开启, 个人 PC 之类的就不是很有必要了.')]),t._v(" "),e("dt",[t._v("Timer frequency")]),t._v(" "),e("dd",[t._v("内核时钟频率. 对于要求快速响应的场合, 比如桌面环境, 建议使用 1000Hz, 而对于不需要快速响应的 SMP/NUMA 服务器, 建议使用 250Hz 或 100Hz 或 300Hz(主要处理多媒体数据).")]),t._v(" "),e("dt",[t._v("kexec system call\nCONFIG_KEXEC")]),t._v(" "),e("dd",[t._v("提供 [kexec](http://www.ibm.com/developerworks/cn/linux/l-kexec/) 系统调用, 可以[不必重启而切换到另一个内核](http://www.linuxsir.org/bbs/thread335331.html) (不一定必须是 Linux 内核), 不过这个特性并不总是那么可靠. 如果你不确定是否需要它, 那么就是不需要.")]),t._v(" "),e("dt",[t._v("kernel crash dumps\nCONFIG_CRASH_DUMP")]),t._v(" "),e("dd",[t._v('当内核崩溃时自动导出运行时信息的功能, 主要用于调试目的. 更多信息请参考 "[Documentation/kdump/kdump.txt](https://www.kernel.org/doc/Documentation/kdump/kdump.txt)" 文件.')]),t._v(" "),e("dt",[t._v("kexec jump\nCONFIG_KEXEC_JUMP")]),t._v(" "),e("dd",[t._v("[kexec jump](http://lwn.net/Articles/263286/) 支持. 这是对 CONFIG_KEXEC 的增强功能, 仅在你确实明白这是干啥的情况下再开启, 否则请关闭.")]),t._v(" "),e("dt",[t._v("Physical address where the kernel is loaded\nCONFIG_PHYSICAL_START")]),t._v(" "),e("dd",[t._v("加载内核的物理地址. 如果内核不是可重定位的 (CONFIG_RELOCATABLE=n), 那么 bzImage 会将自己解压到该物理地址并从此地址开始运行, 否则, bzImage 将忽略此处设置的值, 而从引导装载程序将其装入的物理地址开始运行. 仅在你确实知道自己是在干什么的情况下才可以改变该值, 否则请保持默认.")]),t._v(" "),e("dt",[t._v("Build a relocatable kernel\nCONFIG_RELOCATABLE")]),t._v(" "),e("dd",[t._v("使内核可以[在浮动的物理内存位置加载](http://tsecer.blog.163.com/blog/static/1501817201199871326/), 主要用于调试目的. 仅在你确实知道为什么需要的时候再开启, 否则请关闭.")]),t._v(" "),e("dt",[t._v("Support for hot-pluggable CPUs\nCONFIG_HOTPLUG_CPU")]),t._v(" "),e("dd",[t._v("热插拔 CPU 支持 (通过 /sys/devices/system/cpu 进行控制).")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Set default setting of cpu0_hotpluggable\nCONFIG_BOOTPARAM_HOTPLUG_CPU0")]),t._v(" "),e("dd",[t._v('开启 / 关闭此项的意思是设置 "cpu0_hotpluggable" 的默认值为 "on/off". 开启此项表示默认将 CPU0 设置为允许热插拔.')]),t._v(" "),e("dt",[t._v("Debug CPU0 hotplug\nCONFIG_DEBUG_HOTPLUG_CPU0")]),t._v(" "),e("dd",[t._v("仅用于调试目的.")])])]),t._v(" "),e("dt",[t._v("Compat VDSO support\nCONFIG_COMPAT_VDSO")]),t._v(" "),e("dd",[t._v('是否将 [VDSO](http://blog.csdn.net/juana1/article/details/6904932)(Virtual Dynamic Shared Object) 映射到旧式的确定性地址. 如果 Glibc 版本大于等于 2.3.3 选 "N", 否则就选 "Y".')]),t._v(" "),e("dt",[t._v("vsyscall table for legacy applications")]),t._v(" "),e("dd",[t._v('设置内核引导参数 "vsyscall=[native|emulate|none]" 的值. 对于使用 Glibc-2.14 以上版本的系统来说, 如果不需要使用特别老旧的静态二进制程序, 应该将此项设为 "None" 以提升性能与安全性.')]),t._v(" "),e("dt",[t._v("Built-in kernel command line\nCONFIG_CMDLINE_BOOL")]),t._v(" "),e("dd",[t._v("将内核引导参数直接编进来. 在无法向内核传递引导参数的情况下 (比如在嵌入式系统上, 或者想使用 EFI stub kernel), 这就是唯一的救命稻草了. 如果你使用 grub 之类的引导管理器, 那么就可以不需要此特性.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Built-in kernel command string\nCONFIG_CMDLINE")]),t._v(" "),e("dd",[t._v("将要编译进内核的引导参数字符串.")]),t._v(" "),e("dt",[t._v("Built-in command line overrides boot loader arguments\nCONFIG_CMDLINE_OVERRIDE")]),t._v(" "),e("dd",[t._v("开启此项表示完全忽略引导加载器传递过来的参数, 并仅仅只使用 CONFIG_CMDLINE 所指定的参数. 通常情况下建议关闭此项, 除非你确定引导加载器在传递内核引导参数的时候不能正常工作.")])])]),t._v(" "),e("dt",[t._v("Enable the LDT (local descriptor table)\nCONFIG_MODIFY_LDT_SYSCALL")]),t._v(" "),e("dd",[t._v('Linux 允许用户空间的应用程序使用 [modify_ldt(2)](http://man7.org/linux/man-pages/man2/modify_ldt.2.html) 系统调用针对每个 CPU 安装 [Local Descriptor Table (LDT)](http://www.csie.ntu.edu.tw/~wcchen/asm98/asm/proj/b85506061/chap2/segment.html). 某些老旧的程序或者运行在 DOSEMU/Wine 中的程序需要使用此接口. 不确定的选 "N"(尤其是嵌入式系统与服务器).')])]),t._v(" "),e("h2",{attrs:{id:"power-management-and-acpi-options"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#power-management-and-acpi-options"}},[t._v("#")]),t._v(" Power management and ACPI options")]),t._v(" "),e("p",[t._v("电源管理和 ACPI 选项")]),t._v(" "),e("dl",[e("dt",[t._v("Suspend to RAM and standby\nCONFIG_SUSPEND")]),t._v(" "),e("dd",[t._v('"休眠到内存"(ACPI S3) 支持. 也就是系统休眠后, 除了内存之外, 其他所有部件都停止工作, 重开机之后可以直接从内存中恢复运行状态. 要使用此功能, 你需要执行 "echo mem > /sys/power/state" 命令, 还需要在 BIOS 中开启 S3 支持, 否则可能会有问题.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable freezer for suspend to RAM/standby\nCONFIG_SUSPEND_FREEZER")]),t._v(" "),e("dd",[t._v('选 "Y". 除非你知道自己在做什么')])])]),t._v(" "),e("dt",[t._v("Hibernation (aka 'suspend to disk')\nCONFIG_HIBERNATION")]),t._v(" "),e("dd",[t._v('"休眠到硬盘"(ACPI S4) 支持. 也就是将内存的内容保存到硬盘 (hibernation), 所有部件全都停止工作. 要使用此功能, 你首先需要使用内核引导参数 "resume=/dev/swappartition", 然后执行 "echo disk > /sys/power/state" 命令. 如果你不想从先前的休眠状态中恢复, 那么可以使用 "noresume" 内核引导参数. 更多信息, 可以参考 "[Documentation/power/swsusp.txt](https://www.kernel.org/doc/Documentation/power/swsusp.txt)" 文件.')]),t._v(" "),e("dt",[t._v("Default resume partition\nCONFIG_PM_STD_PARTITION")]),t._v(" "),e("dd",[t._v("默认的休眠分区. 这个分区必须是 swap 分区. 不过这里设置的值会被明确的内核引导参数中的值覆盖.")]),t._v(" "),e("dt",[t._v("Opportunistic sleep\nCONFIG_PM_AUTOSLEEP")]),t._v(" "),e("dd",[t._v('这是一种从[安卓借鉴过来的休眠方式](https://lwn.net/Articles/479841/). 这个特性在安卓系统上被称为 "suspend blockers" 或 "wakelocks". 这是一种更激进的电源管理模式, 以尽可能节约电力为目的. 系统默认就处于休眠状态, 仅为内存和少数唤醒系统所必须的设备供电, 当有任务 (唤醒源) 需要运行的时候才唤醒相关组件工作, 工作完成后又立即进入休眠状态. 不过这些特性需要相应的设备驱动程序的支持. 目前除了安卓设备, 在 PC 和服务器领域, 能够利用此特性的驱动还比较少, 不过这是一项非常有前途的电源技术, 喜欢尝鲜的可以考虑开启.')]),t._v(" "),e("dt",[t._v("User space wakeup sources interface\nCONFIG_PM_WAKELOCKS")]),t._v(" "),e("dd",[t._v('允许用户空间的程序通过 sys 文件系统接口, 创建 / 激活 / 撤销系统的 "唤醒源". 需要与 CONFIG_PM_AUTOSLEEP 配合使用.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Maximum number of user space wakeup sources (0 = no limit)\nCONFIG_PM_WAKELOCKS_LIMIT")]),t._v(" "),e("dd",[t._v('用户空间程序允许使用的 "唤醒源" 数量,"0" 表示无限, 最大值是 "100000".')]),t._v(" "),e("dt",[t._v("Garbage collector for user space wakeup sources\nCONFIG_PM_WAKELOCKS_GC")]),t._v(" "),e("dd",[t._v('对 "唤醒源" 对象使用垃圾回收. 主要用于调试目的和 Android 环境.')])])]),t._v(" "),e("dt",[t._v("Run-time PM core functionality[Device power management core functionality]\nCONFIG_PM_RUNTIME\nCONFIG_PM")]),t._v(" "),e("dd",[t._v('允许 IO 设备 (比如硬盘 / 网卡 / 声卡) 在系统运行时进入省电模式, 并可在收到 (硬件或驱动产生的) 唤醒信号后恢复正常. 此功能通常需要硬件的支持. 建议在笔记本 / 嵌入式等需要节约电力的设备上选 "Y".')]),t._v(" "),e("dt",[t._v("Power Management Debug Support\nCONFIG_PM_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Enable workqueue power-efficient mode by default\nCONFIG_WQ_POWER_EFFICIENT_DEFAULT")]),t._v(" "),e("dd",[t._v('因为 "per-cpu workqueue" 的缓存更靠近对应的 CPU, 所以它比 "unbound workqueue" 拥有更好的性能, 但另一方面 "per-cpu workqueue" 通常又比 "unbound workqueue" 需要消耗更多的电能. 选中此项表示默认开启 "workqueue.power_efficient" 内核引导参数, 以使用 "unbound workqueue" 而不是 "per-cpu workqueue" 以降低功耗, 但是性能会有微小的损失.')]),t._v(" "),e("dt",[t._v("ACPI (Advanced Configuration and Power Interface) Support\nCONFIG_ACPI")]),t._v(" "),e("dd",[t._v("[高级配置与电源接口](http://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%94%B5%E6%BA%90%E6%8E%A5%E5%8F%A3) ([Advanced Configuration and Power Interface](http://www.xiaofeng.org/Article/20090422220.htm)) 包括了软件和硬件方面的规范, 目前已被软硬件厂商广泛支持, 并且取代了许多过去的配置与电源管理接口, 包括 PnP BIOS (Plug-and-Play BIOS), MPS(CONFIG_X86_MPPARSE), APM(Advanced Power Management) 等. 总之, ACPI 已经成为 x86 平台必不可少的组件, 如果你没有特别的理由, 务必选中此项.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("AML debugger interface (EXPERIMENTAL)\nCONFIG_ACPI_DEBUGGER")]),t._v(" "),e("dd",[t._v("仅供调试使用.")]),t._v(" "),e("dt",[t._v("Deprecated /proc/acpi files\nCONFIG_ACPI_PROCFS")]),t._v(" "),e("dd",[t._v("过时的 /proc/acpi 接口支持, 建议关闭.")]),t._v(" "),e("dt",[t._v("Deprecated power /proc/acpi directories\nCONFIG_ACPI_PROCFS_POWER")]),t._v(" "),e("dd",[t._v("过时的 /proc/acpi 接口支持, 建议关闭.")]),t._v(" "),e("dt",[t._v("Allow supported ACPI revision to be overriden\nCONFIG_ACPI_REV_OVERRIDE_POSSIBLE")]),t._v(" "),e("dd",[t._v('某些笔记本固件会根据操作系统支持的 ACPI 版本决定硬件的工作模式. 例如 Dell XPS 13 (2015) 期望操作系统支持 "ACPI v5" 规范, 但 Linux 实际上只支持 "ACPI v4" 规范, 此时固件会将声卡的工作模式从 HDA 模式 (Linux 支持此模式, 且为首选模式) 转换成 I2S 模式(次选模式). 选中此项后, 将强制 Linux 内核哄骗固件说它支持 "ACPI v5" 规范, 相当于使用了 "acpi_rev_override" 内核引导参数.')]),t._v(" "),e("dt",[t._v("EC read/write access through /sys/kernel/debug/ec\nCONFIG_ACPI_EC_DEBUGFS")]),t._v(" "),e("dd",[t._v("仅供调试使用.")]),t._v(" "),e("dt",[t._v("Deprecated /proc/acpi/event support\nCONFIG_ACPI_PROC_EVENT")]),t._v(" "),e("dd",[t._v("过时的 /proc/acpi/event 接口支持, 建议关闭.")]),t._v(" "),e("dt",[t._v("AC Adapter\nCONFIG_ACPI_AC")]),t._v(" "),e("dd",[t._v("允许在外接交流电源和内置电池之间进行切换.")]),t._v(" "),e("dt",[t._v("Battery\nCONFIG_ACPI_BATTERY")]),t._v(" "),e("dd",[t._v("允许通过 /proc/acpi/battery 接口查看电池信息.")]),t._v(" "),e("dt",[t._v("Button\nCONFIG_ACPI_BUTTON")]),t._v(" "),e("dd",[t._v("允许守护进程通过 /proc/acpi/event 接口捕获 power/sleep/lid(合上笔记本)按钮事件, 并执行相应的动作, 软关机 (poweroff) 也需要它的支持.")]),t._v(" "),e("dt",[t._v("Video\nCONFIG_ACPI_VIDEO")]),t._v(" "),e("dd",[t._v("对主板上的集成显卡提供 ACPI 支持. 注意: 仅支持集成显卡.")]),t._v(" "),e("dt",[t._v("Fan\nCONFIG_ACPI_FAN")]),t._v(" "),e("dd",[t._v("允许用户层的程序对风扇进行控制 (开 / 关 / 查询状态)")]),t._v(" "),e("dt",[t._v("Dock\nCONFIG_ACPI_DOCK")]),t._v(" "),e("dd",[t._v("支持兼容 ACPI 规范的扩展坞 (比如 IBM Ultrabay 和 Dell Module Bay) 支持.")]),t._v(" "),e("dt",[t._v("Processor\nCONFIG_ACPI_PROCESSOR")]),t._v(" "),e("dd",[t._v("在支持 ACPI C2/C3 的 CPU 上, 将 ACPI 安装为 idle 处理程序. 有几种 CPU 频率调节驱动依赖于它. 而且目前的 CPU 都已经支持 ACPI 规范, 建议开启此项.")]),t._v(" "),e("dt",[t._v("IPMI\nCONFIG_ACPI_IPMI")]),t._v(" "),e("dd",[t._v("允许 ACPI 使用 [IPMI](http://zh.wikipedia.org/wiki/IPMI)(智能平台管理接口) 的请求 / 应答消息访问 BMC(主板管理控制器).IPMI 通常出现在服务器中, 以允许通过诸如 [ipmitool](http://www.ibm.com/developerworks/cn/linux/l-ipmi/) 这样的工具监视服务器的物理健康特征 (温度 / 电压 / 风扇状态 / 电源状态).")]),t._v(" "),e("dt",[t._v("Processor Aggregator\nCONFIG_ACPI_PROCESSOR_AGGREGATOR")]),t._v(" "),e("dd",[t._v('支持 ACPI 4.0 加入的处理器聚合器 ([processor Aggregator](http://lwn.net/Articles/355934/))功能, 以允许操作系统对系统中所有的 CPU 进行统一的配置和控制. 目前只支持逻辑处理器 (也就是利用 Intel 超线程技术虚拟出来的 CPU)idling 功能, 其目标是降低耗电量. 不确定的应该选 "N". 在某些服务器上此驱动(acpi_pad) 可能[与 BIOS 中的节能功能冲突](http://zh.community.dell.com/techcenter/b/weblog/archive/2012/10/23/ubuntu-on-dell-12g-poweredge-servers)')]),t._v(" "),e("dt",[t._v("Thermal Zone\nCONFIG_ACPI_THERMAL")]),t._v(" "),e("dd",[t._v("ACPI thermal zone 支持. 系统温度过高时可以及时调整风扇的工作状态以避免你的 CPU 被烧毁. 目前所有 CPU 都支持此特性. 务必开启. 参见 CONFIG_THERMAL 选项.")]),t._v(" "),e("dt",[t._v("NUMA support\nCONFIG_ACPI_NUMA")]),t._v(" "),e("dd",[t._v("通过读取系统固件中的 ACPI 表, 获得 NUMA 系统的 CPU 及物理内存分布信息. NUMA 系统必选.")]),t._v(" "),e("dt",[t._v("Custom DSDT Table file to include\nCONFIG_ACPI_CUSTOM_DSDT_FILE")]),t._v(" "),e("dd",[t._v('允许将一个定制过的 DSDT 编译进内核. 详情参见 "[Documentation/acpi/dsdt-override.txt](https://www.kernel.org/doc/Documentation/acpi/dsdt-override.txt)" 文档. 看不懂的请保持空白.')]),t._v(" "),e("dt",[t._v("ACPI tables override via initrd\nCONFIG_ACPI_INITRD_TABLE_OVERRIDE")]),t._v(" "),e("dd",[t._v('允许 initrd 更改 [ACPI tables](http://www.cnblogs.com/junzhkevin/archive/2013/02/25/2932801.html) 中的任意内容. ACPI tables 是 BIOS 提供给 OS 的硬件配置数据, 包括系统硬件的电源管理和配置管理. 详情参见 "[Documentation/acpi/initrd_table_override.txt](https://www.kernel.org/doc/Documentation/acpi/initrd_table_override.txt)" 文件.')]),t._v(" "),e("dt",[t._v("Debug Statements\nCONFIG_ACPI_DEBUG")]),t._v(" "),e("dd",[t._v("详细的 ACPI 调试信息, 不搞开发就别选.")]),t._v(" "),e("dt",[t._v("PCI slot detection driver\nCONFIG_ACPI_PCI_SLOT")]),t._v(" "),e("dd",[t._v('将每个 PCI 插槽都作为一个单独的条目列在 /sys/bus/pci/slots/ 目录中, 有助于将设备的物理插槽位置与逻辑的 PCI 总线地址进行对应. 不确定的选 "No".')]),t._v(" "),e("dt",[t._v("Power Management Timer Support\nCONFIG_X86_PM_TIMER")]),t._v(" "),e("dd",[t._v('[ACPI PM Timer](http://www.biosren.com/viewthread.php?tid=2895), 简称 "ACPI Timer", 是一种集成在主板上的硬件时钟发生器, 提供 3.579545MHz 固定频率. 这是比较传统的硬件时钟发生器 (HPET 则是比较新型的硬件时钟发生器), 目前所有的主板都支持, 而且是 ACPI 规范不可分割的部分. 除非你确定不需要, 否则必选.')]),t._v(" "),e("dt",[t._v("Container and Module Devices\nCONFIG_ACPI_CONTAINER")]),t._v(" "),e("dd",[t._v('支持 NUMA 节点 / CPU / 内存 的热插拔. Device ID: ACPI0004, PNP0A05, PNP0A06 (find /sys/devices/ -name "PNP0A0[56]*" -or -name "ACPI0004*")')]),t._v(" "),e("dt",[t._v("Memory Hotplug\nCONFIG_ACPI_HOTPLUG_MEMORY")]),t._v(" "),e("dd",[t._v('内存热插拔支持. Device ID: PNP0C80 (find /sys/devices/ -name "PNP0C80*")')]),t._v(" "),e("dt",[t._v("Smart Battery System\nCONFIG_ACPI_SBS")]),t._v(" "),e("dd",[t._v("[智能电池系统](http://baike.baidu.com/view/1938623.htm) ([Smart Battery System](http://wenku.baidu.com/view/9388cf93daef5ef7ba0d3c7e.html)) 可以让笔记型电脑显示及管理详细精确的电池状态信息.[](http://h10025.www1.hp.com/ewfrf/wc/document?cc=cn&lc=zh-hans&dlc=zh-hans&doc>使用锂电池"),t._v("的笔记本电脑必备利器. 但遗憾的是并不是所有笔记本都支持这项特性.")]),t._v(" "),e("dt",[t._v("Hardware Error Device"),e("br"),t._v("CONFIG_ACPI_HED")]),e("dd",[t._v("Hardware Error Device (Device ID: PNP0C33) 能够通过 SCI 报告一些硬件错误 (通常是已经被纠正的错误). 如果你的系统中有设备 ID 为 )")]),t._v(" "),e("dt",[t._v("[Allow ACPI methods to be inserted/replaced at run time\nCONFIG_ACPI_CUSTOM_METHOD](http://h10025.www1.hp.com/ewfrf/wc/document?cc=cn&lc=zh-hans&dlc=zh-hans&doc>使用锂电池"),t._v("的笔记本电脑必备利器. 但遗憾的是并不是所有笔记本都支持这项特性.")])])]),t._v(" "),e("dt",[t._v("Hardware Error Device"),e("br"),t._v("CONFIG_ACPI_HED")]),e("dd",[t._v("Hardware Error Device (Device ID: PNP0C33) 能够通过 SCI 报告一些硬件错误 (通常是已经被纠正的错误). 如果你的系统中有设备 ID 为 )")]),e("dd",[t._v("[允许在不断电的情况下直接对 ACPI 的功能进行删改, 包含一定危险性, 它允许 root 任意修改内存中内核空间的内容. 仅用于调试.](http://h10025.www1.hp.com/ewfrf/wc/document?cc=cn&lc=zh-hans&dlc=zh-hans&doc>使用锂电池"),t._v("的笔记本电脑必备利器. 但遗憾的是并不是所有笔记本都支持这项特性.")]),t._v(" "),e("dt",[t._v("Hardware Error Device"),e("br"),t._v("CONFIG_ACPI_HED")]),e("dd",[t._v("Hardware Error Device (Device ID: PNP0C33) 能够通过 SCI 报告一些硬件错误 (通常是已经被纠正的错误). 如果你的系统中有设备 ID 为 )")]),t._v(" "),e("p",[t._v("[")]),e("dt",[t._v("Boottime Graphics Resource Table support\nCONFIG_ACPI_BGRT")]),e("p"),t._v(" "),e("dd",[t._v("在 /sys/firmware/acpi/bgrt/ 中显示 ACPI Boottime Graphics Resource Table , 以允许操作系统获取固件中的启动画面 (splash).")]),t._v(" "),e("dt",[t._v("Hardware-reduced ACPI support only\nCONFIG_ACPI_REDUCED_HARDWARE_ONLY")]),t._v(" "),e("dd",[t._v('以 "reduced hardware" 模式编译内核的 ACPI 代码, 从而获得体积更小的内核但仅能运行在 ACPI "reduced hardware" 模式的硬件上. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("ACPI NVDIMM Firmware Interface Table (NFIT)\nCONFIG_ACPI_NFIT")]),t._v("](http://h10025.www1.hp.com/ewfrf/wc/document?cc=cn&lc=zh-hans&dlc=zh-hans&doc>使用锂电池"),t._v("的笔记本电脑必备利器. 但遗憾的是并不是所有笔记本都支持这项特性."),t._v(" "),e("dt",[t._v("Hardware Error Device"),e("br"),t._v("CONFIG_ACPI_HED")]),e("dd",[t._v("Hardware Error Device (Device ID: PNP0C33) 能够通过 SCI 报告一些硬件错误 (通常是已经被纠正的错误). 如果你的系统中有设备 ID 为 ) \n")]),e("dd",[t._v("[](http://h10025.www1.hp.com/ewfrf/wc/document?cc=cn&lc=zh-hans&dlc=zh-hans&doc>使用锂电池"),t._v("的笔记本电脑必备利器. 但遗憾的是并不是所有笔记本都支持这项特性.")]),t._v(" "),e("dt",[t._v("Hardware Error Device"),e("br"),t._v("CONFIG_ACPI_HED")]),e("dd",[t._v("Hardware Error Device (Device ID: PNP0C33) 能够通过 SCI 报告一些硬件错误 (通常是已经被纠正的错误). 如果你的系统中有设备 ID 为 )[非易失性内存](http://baike.baidu.com/item/NVDIMM) ([NVDIMM](http://baike.baidu.com/pic/NVDIMM/7475977/0/908fa0ec08fa513d43b893993f6d55fbb2fbd963)) 支持. 此种内存使用超级电容作为后备电力, 并且使用非挥发性的 flash 存储介质来保存数据, 以使数据能够在掉电之后依然保存. 这是一种很有前途的技术, 但是目前笔记本与普通服务器并不使用这种内存.")]),t._v(" "),e("dt",[t._v("ACPI Platform Error Interface (APEI)\nCONFIG_ACPI_APEI")]),t._v(" "),e("dd",[t._v("[高级平台错误接口 (ACPI Platform Error Interface)](http://www.ibm.com/developerworks/cn/linux/l-cn-apei/) 是 [RAS(Reliability, Availability and Serviceability)](http://www.ibm.com/developerworks/cn/linux/l-cn-ras/) 的一部分, 是定义在 ACPI 4.0 规范中的一个面向硬件错误管理的接口, 主要是为了统一 firmware/BIOS 和 OS 之间的错误交互机制, 使用标准的错误接口进行管理, 同时也扩展了错误接口的内容以便实现更加灵活丰富的功能.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("APEI Generic Hardware Error Source\nCONFIG_ACPI_APEI_GHES")]),t._v(" "),e("dd",[t._v('"Firmware First Mode" 支持. 由于 BIOS/FIRMWARE 是平台相关的, 因此 BIOS/FIRMWARE 比 OS 更清楚硬件平台的配置情况, 甚至包含各种必须的修正 / 定制 / 优化. 这样, 在 "Firmware First" 模式下, BIOS/FIRMWARE 利用这一优势, 可以有针对性的对发生的硬件错误进行分析 / 处理 / 分发, 也可以更准确的记录错误的现场信息. 这样, 不但对硬件错误可以做出更准确, 更复杂的处理, 而且可以降低 OS 的复杂性和冗余度. 建议开启.')]),t._v(" "),e("dt",[t._v("APEI PCIe AER logging/recovering support\nCONFIG_ACPI_APEI_PCIEAER")]),t._v(" "),e("dd",[t._v("让 PCIe AER errors 首先通过 APEI firmware 进行报告.")]),t._v(" "),e("dt",[t._v("APEI memory error recovering support\nCONFIG_ACPI_APEI_MEMORY_FAILURE")]),t._v(" "),e("dd",[t._v("让 Memory errors 首先通过 APEI firmware 进行报告.")]),t._v(" "),e("dt",[t._v("APEI Error INJection (EINJ)\nCONFIG_ACPI_APEI_EINJ")]),t._v(" "),e("dd",[t._v("仅供调试使用.")]),t._v(" "),e("dt",[t._v("APEI Error Record Serialization Table (ERST) Debug Support\nCONFIG_ACPI_APEI_ERST_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")])])]),t._v(" "),e("dt",[t._v("Extended Error Log support\nCONFIG_ACPI_EXTLOG")]),t._v(" "),e("dd",[t._v('服务器 CPU 一般都会在非核心寄存器中记录比 CONFIG_X86_MCE 故障更详细的额外信息, 诸如 [PFA(Predictive Failure Analysis)](https://en.wikipedia.org/wiki/Predictive_failure_analysis) 之类的故障预警系统需要收集这些信息. 但由于这些非核心寄存器的位置差别很大没有统一标准, 系统软件难以直接读取这些扩展的错误信息. 此驱动可以在 MCE 或 CMCI 机制之外, 将系统固件提供的这些额外扩展错误信息导出到用户空间. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("PMIC (Power Management Integrated Circuit) operation region support\nCONFIG_PMIC_OPREGION")]),t._v(" "),e("dd",[t._v("[电源管理芯片](http://baike.baidu.com/view/7765458.htm) ([PMIC](https://zh.wikipedia.org/zh-cn/%E9%9B%BB%E6%BA%90%E7%AE%A1%E7%90%86IC)) 支持. 此种芯片常用于以电池作为电源的嵌入式装置.")])]),t._v(" "),e("dt",[t._v("SFI (Simple Firmware Interface) Support\nCONFIG_SFI")]),t._v(" "),e("dd",[t._v('简单固件接口规范 ([Simple Firmware Interface](http://en.wikipedia.org/wiki/Simple_Firmware_Interface))使用一种轻量级的简单方法 (通过内存中的一张静态表格) 从 firmware 向操作系统传递信息. 目前这个规范仅用于第二代 Intel Atom 平台, 其核心名称是 "[Moorestown](http://news.mydrivers.com/1/163/163402.htm)".')]),t._v(" "),e("dt",[t._v("CPU Frequency scaling\nCONFIG_CPU_FREQ")]),t._v(" "),e("dd",[t._v("[CPUfreq](http://www.ibm.com/developerworks/cn/linux/l-cpufreq-1/) 子系统允许动态改变 CPU 主频, 达到省电和降温的目的. 现如今的 CPU 都已经支持动态频率调整, 建议开启. 不过, 如果你是为虚拟机编译内核, 就没有必要开启了, 由宿主机内核去控制就 OK 了.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("CPU frequency translation statistics\nCONFIG_CPU_FREQ_STAT")]),t._v(" "),e("dd",[t._v("通过 sysfs 文件系统输出 CPU 频率变化的统计信息")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("CPU frequency translation statistics details\nCONFIG_CPU_FREQ_STAT_DETAILS")]),t._v(" "),e("dd",[t._v("输出更详细的 CPU 频率变化统计信息")])])]),t._v(" "),e("dt",[t._v("Default CPUFreq governor")]),t._v(" "),e("dd",[t._v("默认的 CPU 频率[调节策略](http://www.ibm.com/developerworks/cn/linux/l-cpufreq-2/). 不同策略拥有不同的[调节效果](http://www.ibm.com/developerworks/cn/linux/l-cpufreq-3/).")]),t._v(" "),e("dt",[t._v("'performance' governor\nCONFIG_CPU_FREQ_GOV_PERFORMANCE")]),t._v(" "),e("dd",[t._v("'性能'优先, 静态的将频率设置为 cpu 支持的最高频率. 最耗电, 发热量最大, 性能 / 效率比最低. 不建议使用.")]),t._v(" "),e("dt",[t._v("'powersave' governor\nCONFIG_CPU_FREQ_GOV_POWERSAVE")]),t._v(" "),e("dd",[t._v("'节能'优先, 静态的将频率设置为 cpu 支持的最低频率, 严重影响性能.[注意] 此调节器实际上并不能真正节省电能, 因为系统需要花更长的时间才能进入空闲状态 (C1E,C3,C6). 但对于 CONFIG_X86_INTEL_PSTATE 驱动来说, 这是效果最佳的调节器.")]),t._v(" "),e("dt",[t._v("'userspace' governor for userspace frequency scaling\nCONFIG_CPU_FREQ_GOV_USERSPACE")]),t._v(" "),e("dd",[t._v("既允许手动调整 cpu 频率, 也允许用户空间程序动态调整 cpu 频率 (需要额外的调频软件). 比较麻烦, 不建议使用.")]),t._v(" "),e("dt",[t._v("'ondemand' cpufreq policy governor\nCONFIG_CPU_FREQ_GOV_ONDEMAND")]),t._v(" "),e("dd",[t._v('\'随需应变\', 内核周期性的考察 CPU 负载, 当 CPU 负载超过 / 低于设定的百分比阈值 (/sys/devices/system/cpu/cpufreq/ondemand/up_threshold) 时, 就自动将 cpu 频率设为最高 / 最低值 (也就是仅在最高和最低频率间切换), 比较适合台式机.[优化建议] 将 "up_threshold" 设为 95 左右, 可以获得更高的 "性能 / 瓦特" 比.')]),t._v(" "),e("dt",[t._v("'conservative' cpufreq governor\nCONFIG_CPU_FREQ_GOV_CONSERVATIVE")]),t._v(" "),e("dd",[t._v("'保守', 和'ondemand'相似, 内核同样周期性的考察 CPU 负载, 但是频率的升降是渐变式的 (通常只在相邻的两档频率间切换, 但具体取决于 \"/sys/devices/system/cpu/cpufreq/conservative/freq_step\" 的百分比设置, 设为 \"100\" 则等价于仅允许在最高和最低频率间切换): 当 CPU 负载超过百分比上限(/sys/devices/system/cpu/cpufreq/conservative/up_threshold) 时, 就自动提升一档 CPU 频率; 当 CPU 负载低于百分比下限 (/sys/devices/system/cpu/cpufreq/conservative/down_threshold) 时, 就自动降低一档 CPU 频率. 更适合用于笔记本 / PDA/x86_64 环境.[优化建议]'conservative'在默认设置下的 \"性能 / 瓦特\" 比通常不如'ondemand'优秀, 但是优化设置之后情况则可能反转. 例如, 在 \"down_threshold=93,up_threshold=97\" 的情况下, 可以比 \"up_threshold=95\" 的'ondemand'略有优势.")]),t._v(" "),e("dt",[t._v("x86 CPU frequency scaling drivers")]),t._v(" "),e("dd",[t._v("CPU 频率调节器驱动")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Intel P state control\nCONFIG_X86_INTEL_PSTATE")]),t._v(" "),e("dd",[t._v('此驱动是专用于 Intel 的 "[Sandy Bridge](http://zh.wikipedia.org/wiki/Sandy_Bridge%E5%BE%AE%E6%9E%B6%E6%A7%8B)"/"[Ivy Bridge](http://zh.wikipedia.org/wiki/Intel_Ivy_Bridge)"/"[Haswell](http://zh.wikipedia.org/wiki/Intel_Haswell)"/"[Broadwell](http://baike.baidu.com/view/5565083.htm)"/"[SkyLake](http://baike.baidu.com/view/9294118.htm)"或更新 CPU 微架构的首选驱动, 可以更好的支持"[Turbo Boost 2.0](http://www.expreview.com/13254-all.html)"技术.[注意]此驱动仅支持"performance"与"powersave"(首选)两种频率调节策略 (但两者都支持动态频率调整), 且" 性能 / 瓦特 "比都优于传统的\'ondemand\'.[提示] 可以通过"echo 1 > /sys/devices/system/cpu/intel_pstate/no_turbo" 关闭睿频加速, 进一步降低 CPU 温度与性能.')]),t._v(" "),e("dt",[t._v("Processor Clocking Control interface driver\nCONFIG_X86_PCC_CPUFREQ")]),t._v(" "),e("dd",[t._v('PCC(Processor Clocking Control) 接口支持. 此种接口仅对某些 HP Proliant 系列服务器有意义. 更多细节可以参考 "[Documentation/cpu-freq/pcc-cpufreq.txt](https://www.kernel.org/doc/Documentation/cpu-freq/pcc-cpufreq.txt)" 文件.')]),t._v(" "),e("dt",[t._v("ACPI Processor P-States driver\nCONFIG_X86_ACPI_CPUFREQ")]),t._v(" "),e("dd",[t._v('此驱动同时支持 Intel 和 AMD 的 CPU, 这是较老的 intel cpu 与非 intel cpu 首选的驱动 (除非你的 CPU 是古董级别).[注意] 对于可以使用 P-state 驱动的 Intel CPU 来说, 应该选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Legacy cpb sysfs knob support for AMD CPUs\nCONFIG_X86_ACPI_CPUFREQ_CPB")]),t._v(" "),e("dd",[t._v("为了兼容旧的用户空间程序而设置, 建议关闭.")])])]),t._v(" "),e("dt",[t._v("AMD Opteron/Athlon64 PowerNow!\nCONFIG_X86_POWERNOW_K8")]),t._v(" "),e("dd",[t._v("过时的驱动, 仅为老旧的 [K8](http://zh.wikipedia.org/wiki/AMD_K8) 核心的 AMD 处理器提供支持.[K10](http://zh.wikipedia.org/wiki/AMD_K10) 以及更新的 CPU 应该使用 CONFIG_X86_ACPI_CPUFREQ 驱动.")]),t._v(" "),e("dt",[t._v("AMD frequency sensitivity feedback powersave bias\nCONFIG_X86_AMD_FREQ_SENSITIVITY")]),t._v(" "),e("dd",[t._v('如果你使用 AMD Family 16h 或者更高级别的处理器, 同时又使用 "ondemand" 频率调节器, 开启此项可以更有效的进行频率调节 (在保证性能的前提下更节能).')]),t._v(" "),e("dt",[t._v("Intel Enhanced SpeedStep (deprecated)\nCONFIG_X86_SPEEDSTEP_CENTRINO")]),t._v(" "),e("dd",[t._v("已被时代抛弃的驱动, 仅对老旧的迅驰平台 Intel Pentium M / XEON 处理器有意义.")]),t._v(" "),e("dt",[t._v("Intel Pentium 4 clock modulation\nCONFIG_X86_P4_CLOCKMOD")]),t._v(" "),e("dd",[t._v("已被时代抛弃的驱动, 仅对支持老旧的 Speedstep 技术的 Intel Pentium 4 / XEON 处理器有意义. 而且即便是在这样的 CPU 上, 因为种种兼容性问题可能导致的不稳定, 也不建议开启.")])])])])]),t._v(" "),e("dt",[t._v("CPU idle PM support\nCONFIG_CPU_IDLE")]),t._v(" "),e("dd",[t._v('[CPU idle](http://en.wikipedia.org/wiki/Idle_%28CPU%29) 指令支持, 该指令可以让 CPU 在空闲时 "打盹" 以节约电力和减少发热. 只要是支持 ACPI 的 CPU 就应该开启. 由于所有 64 位 CPU 都已支持 ACPI, 所以不必犹豫, 开启![提示] 为虚拟机编译的内核就没有必要开启了, 由宿主机内核去控制就 OK 了.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Support multiple cpuidle drivers\nCONFIG_CPU_IDLE_MULTIPLE_DRIVERS")]),t._v(" "),e("dd",[t._v("允许 CONFIG_CPU_IDLE 为每个不同的 CPU 使用不同的驱动. 仅在你的系统由多个不同型号的 CPU 组成, 并且具有不同的唤醒潜伏时间和状态的时候才需要开启.")])])]),t._v(" "),e("dt",[t._v("Cpuidle Driver for Intel Processors\nCONFIG_INTEL_IDLE")]),t._v(" "),e("dd",[t._v("专用于 Intel CPU 的 cpuidle 驱动. 而 CONFIG_CPU_IDLE 则可用于非 Intel 的 CPU.")]),t._v(" "),e("dt",[t._v("Memory power savings")]),t._v(" "),e("dd",[t._v("内存节能")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Intel chipset idle memory power saving driver\nCONFIG_I7300_IDLE")]),t._v(" "),e("dd",[t._v('在某些具备内存节能特性的 intel 服务器芯片组上, 让内存也可以在空闲时通过 idle 指令 "打盹". 这些[芯片组](http://blog.chinaunix.net/uid-15089195-id-3561594.html)必须具备 [I/O AT](http://tech.sina.com.cn/h/2007-04-18/1957292094.shtml) 支持 (例如 Intel 7300). 同时内存也需要支持此特性.')])])]),t._v(" "),e("h2",{attrs:{id:"bus-options-pci-etc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bus-options-pci-etc"}},[t._v("#")]),t._v(" Bus options (PCI etc.)")]),t._v(" "),e("p",[t._v("总线选项")]),t._v(" "),e("dl",[e("dt",[t._v("PCI support\nCONFIG_PCI")]),t._v(" "),e("dd",[t._v('[PCI](http://blog.csdn.net/fudan_abc/article/category/345294) 是最重要的内部总线, 不但 PCI 与 PCI Express 设备依赖于它, 而且 USB/IDE/SATA/SCSI / 火线 (IEEE 1394)/PCMCIA/CardBus 等各种内部和外部总线也都依赖于它. 所以必须选 "Y", 除非你知道自己在干什么.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Support mmconfig PCI config space access\nCONFIG_PCI_MMCONFIG")]),t._v(" "),e("dd",[t._v("允许通过 mmconfig 方式访问 [PCI config space](http://en.wikipedia.org/wiki/PCI_configuration_space), 这种访问方式比传统的 IO 方式速度更快. 建议开启. MMCONFIG 的意思是 \"Memory-Mapped config\", 它是 PCI Express 引入的新[总线枚举](http://blog.csdn.net/fudan_abc/article/details/1888773)方式. 背景知识: PCI 设备都有一组叫做'Configuration Space'的寄存器, PCI-E 设备在 PCI 的基础上又增加了一组叫做'Extended Configuration Space'的寄存器. 这些寄存器都被映射到了内存中 (Memory-Mapped), 操作系统理应提供相应的 API 供设备驱动和诊断程序访问这些'Configuration Space'. 但如果操作系统没有提供 Memory-Mapped 方式的 API 的话, 这些驱动程序和诊断程序就必须自己根据操作系统的底层规则(IO 方式) 去访问, 这显然就增加了开发难度. 这个选项的目的就是提供 Memory-Mapped 方式的 API.")]),t._v(" "),e("dt",[t._v("Read CNB20LE Host Bridge Windows\nCONFIG_PCI_CNB20LE_QUIRK")]),t._v(" "),e("dd",[t._v("CNB20LE 芯片组 PCI 热插拔支持. 除非你非常明确的知道你需要它, 否则请关闭此项.")]),t._v(" "),e("dt",[t._v("PCI Express support\nCONFIG_PCIEPORTBUS")]),t._v(" "),e("dd",[t._v('[PCI Express](http://zh.wikipedia.org/wiki/PCI_Express) 是 PCI 的升级版并在软件层与 PCI 兼容, 其目标是统一电脑内部总线. 基本上只要不是古董机, 都早已支持 PCI-E 了. 选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("PCI Express Hotplug driver\nCONFIG_HOTPLUG_PCI_PCIE")]),t._v(" "),e("dd",[t._v("如果你的主板和设备都支持 PCI Express 热插拔就可以选上.")]),t._v(" "),e("dt",[t._v("Root Port Advanced Error Reporting support\nCONFIG_PCIEAER")]),t._v(" "),e("dd",[t._v("[PCI Express Root Port Advanced Error Reporting (AER)](http://stuff.mit.edu/afs/sipb/contrib/linux/Documentation/PCI/pcieaer-howto.txt) 驱动支持. 这样, 发送到 Root Port 的 Error reporting messages 就会由 PCI Express AER 处理. 建议开启. 背景知识: PCI Express 定义了两种错误报告范例:(1)baseline, 所有 PCI-E 组件都必须要支持, 功能也比较基础.(2)AER(Advanced Error Reporting), 功能比较高级, 也更可靠, 但并不要求所有组件都支持.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("PCI Express ECRC settings control\nCONFIG_PCIE_ECRC")]),t._v(" "),e("dd",[t._v("允许覆写 firmware/bios 设置的 PCI Express ECRC(端对端循环冗余校验). 建议关闭, 除非你确实知道为什么要开启.")]),t._v(" "),e("dt",[t._v("PCIe AER error injector support\nCONFIG_PCIEAER_INJECT")]),t._v(" "),e("dd",[t._v("允许 PCI-E AER 注入, 仅用于测试目的.")])])]),t._v(" "),e("dt",[t._v("PCI Express ASPM control\nCONFIG_PCIEASPM")]),t._v(" "),e("dd",[t._v("PCI Express [ASPM(Active State Power Management)](http://baike.baidu.cn/view/2803778.html) 和 Clock Power Management 支持. 这是 PCI-E 规范制定的一种电源管理方案, 可以在设备空闲时采用节电模式. 建议开启.[ASPM](https://wireless.wiki.kernel.org/en/users/Documentation/ASPM) 可以在运行时通过 /sys/module/pcie_aspm/parameters/policy 进行开启或关闭.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Debug PCI Express ASPM\nCONFIG_PCIEASPM_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试.")]),t._v(" "),e("dt",[t._v("Default ASPM policy")]),t._v(" "),e("dd",[t._v('默认的 ASPM 电源管理策略. 下面的三个选项:"BIOS default" 表示使用 BIOS 中的设置作为默认."Powersave" 表示在可能的情况下, 默认使用 "L0s" 和 "L1", 以尽可能节约电力."Performance" 表示禁止使用 "L0s" 和 "L1"(即使 BIOS 开启也同样禁止), 以保证最高性能.')])])])])]),t._v(" "),e("dt",[t._v("Message Signaled Interrupts (MSI and MSI-X)\nCONFIG_PCI_MSI")]),t._v(" "),e("dd",[t._v('PCI/PCI-E 支持三类中断:(1)INTx 使用传统的 IRQ 中断, 可以与现行的驱动程序和操作系统兼容.(2)MSI 是 PCI2.2 规范中新增的, 通过写入特殊的内存地址来触发和发送中断, 该种方式脱离了中断引脚带来的数目限制, 并且延迟小 / 效率高. 不过 MSI 方式将中断全部落在单个 CPU 上, 对多核 CPU 利用不佳.(3)MSI-X 是在 PCI3.0 规范中新增的, 在 MSI 的基础上, 支持更多的消息数量以及独立的消息地址, 可以自动在多个 CPU 上分担中断, 更适合多 CPU 系统. 建议开启. 开启后, 也可以使用 "pci=nomsi" 内核引导参数关闭 MSI 特性.')]),t._v(" "),e("dt",[t._v("PCI Debugging\nCONFIG_PCI_DEBUG")]),t._v(" "),e("dd",[t._v("将 PCI 调试信息输出到系统日志里. 如果你想诊断 PCI 设备的故障, 可以开启, 否则应该关闭.")]),t._v(" "),e("dt",[t._v("Enable PCI resource re-allocation detection\nCONFIG_PCI_REALLOC_ENABLE_AUTO")]),t._v(" "),e("dd",[t._v('让内核自动检测 "是否需要重新分配 PCI 资源". 即使此项已开启, 你依然可以用 "pci=realloc=[on|off]" 来覆盖它. 此项仅在已开启 CONFIG_PCI_IOV 的情况下才有意义. 此时, 如果 BIOS 没有为 [SR-IOV(Single-Root I/O Virtualization)](http://docs.oracle.com/cd/E38902_01/html/E38873/glbzi.html) BAR(基地址寄存器) 分配资源, 那么内核将会自动对 PCI 资源进行重新分配. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("PCI Stub driver\nCONFIG_PCI_STUB")]),t._v(" "),e("dd",[t._v("[PCI 设备穿透](http://www.chenyudong.com/archives/add-pci-pass-through-device-to-guest-vm-with-libvirt-and-qemu.html) ([PCI Stub](http://www.powerpcdev.net/blog/index.php/archives/52.html)) 的作用是将属主机的 PCI 设备跟目前绑定的驱动分离, 暂时由其接管, 最后再交给虚拟机内的客户操作系统自己去驱动这个 PCI 设备 (例如网卡穿透 / [显卡穿透](http://docs.eayun.cn/zh-CN/EayunOS/4.1/html/EayunOS-features/hostdev_passthrough/vga_passthrough_notice.html)), 以获得高性能. 由于 USB 等所有外围设备实际上也都是连接在 PCI 总线上的, 所以此功能同样适合各种外围设备, 例如 U 盘加密狗之类.")]),t._v(" "),e("dt",[t._v("Xen PCI Frontend\nCONFIG_XEN_PCIDEV_FRONTEND")]),t._v(" "),e("dd",[t._v("如果你使用 XEN 的半虚拟化技术, 并且你的硬件支持 IOMMU, 那么可以开启此项, 否则应该关闭.")]),t._v(" "),e("dt",[t._v("Interrupts on hypertransport devices\nCONFIG_HT_IRQ")]),t._v(" "),e("dd",[t._v("允许本地的 [HyperTransport](http://zh.wikipedia.org/wiki/HyperTransport) 设备使用中断. 这个只可用于 AMD 平台, Intel 平台不支持这个.")])])]),t._v(" "),e("dt",[t._v("PCI IOV support\nCONFIG_PCI_IOV")]),t._v(" "),e("dd",[t._v("[PCI I/O Virtualization](http://www.ibm.com/developerworks/cn/linux/l-pci-passthrough/) 支持. 这需要硬件支持 IOMMU 技术 (AMD-Vi,Intel VT-d).")]),t._v(" "),e("dt",[t._v("PCI PRI support\nCONFIG_PCI_PRI")]),t._v(" "),e("dd",[t._v("PCI Page Request Interface 支持. 它允许 IOMMU 之后的设备能够从页错误中恢复过来. 这需要硬件支持 IOMMU 技术 (AMD-Vi,Intel VT-d).")]),t._v(" "),e("dt",[t._v("PCI PASID support\nCONFIG_PCI_PASID")]),t._v(" "),e("dd",[t._v('PASID(Process Address Space Identifiers)可以被 PCI 设备用来同时访问多个 IO 地址空间. 这需要硬件 IOMMU 技术 (AMD-Vi,Intel VT-d) 支持 PASID 特性. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("PCI IO-APIC hotplug support\nCONFIG_PCI_IOAPIC")]),t._v(" "),e("dd",[t._v("PCI [IO-APIC](http://www.ibm.com/developerworks/cn/linux/l-cn-linuxkernelint/) 热插拔支持.")]),t._v(" "),e("dt",[t._v("ISA-style DMA support\nCONFIG_ISA_DMA_API")]),t._v(" "),e("dd",[t._v('[ISA-style DMA](https://lkml.org/lkml/2011/1/27/326) 控制器支持. 目前基本只有 [LPC 总线](http://zh.wikipedia.org/wiki/LPC%E5%8C%AF%E6%B5%81%E6%8E%92)设备需要使用, 最常见的是串口, 并口, PS/2 键盘,[Super I/O](http://zh.wikipedia.org/wiki/Super_I/O) 芯片 (可以使用 [Superiotool](http://www.coreboot.org/Superiotool) 和 [sensors-detect](http://www.lm-sensors.org/wiki/man/sensors-detect) 工具检测). 不确定的选 "Y".[说明] 这是一个历史遗留问题, 对于 ISA 架构, DMA 操作是由一个专用的 "DMA 控制器"(最常见的是 [Intel 8237](http://en.wikipedia.org/wiki/Intel_8237)) 来执行的, 但是到了 PCI 架构, 由于每一个 PCI 设备都可以控制 PCI 总线 (成为 "[bus master](http://en.wikipedia.org/wiki/Bus_mastering)")并直接读写系统内存, 所以"DMA 控制器 "又消失了. 此选项只是为那些需要"ISA-DMA 控制器 " 的设备提供了兼容性接口 (API) 而已.')]),t._v(" "),e("dt",[t._v("PCCard (PCMCIA/CardBus) support\nCONFIG_PCCARD")]),t._v(" "),e("dd",[t._v("[PCCard(PCMCIA/CardBus/ExpressCard)](http://zh.wikipedia.org/wiki/PC%E5%8D%A1) 接口通常出现在笔记本电脑上, 这些接口卡通常大小与信用卡差不多, 厚度大约 3-5 毫米. 注意: 必须要配合 [pcmciautils](https://www.kernel.org/pub/linux/utils/kernel/pcmcia/) 工具才能正常使用 PCMCIA 设备.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("16-bit PCMCIA support\nCONFIG_PCMCIA")]),t._v(" "),e("dd",[t._v("老旧的 16-bit PCMCIA 卡支持")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Load CIS updates from userspace\nCONFIG_PCMCIA_LOAD_CIS")]),t._v(" "),e("dd",[t._v('有些 PCMCIA 卡需要从用户空间更新 CIS(Card Information Structure) 之后才能正常工作. 开启此项后, 内核将可以使用内置的固件加载器和热插拔子系统自动加载 CIS, 而不再需要用户空间工具的辅助. 建议选 "Yes".')])])]),t._v(" "),e("dt",[t._v("32-bit CardBus support\nCONFIG_CARDBUS")]),t._v(" "),e("dd",[t._v('常见的 PCMCIA 卡基本上都是 32 位的 [CardBus](http://zh.wikipedia.org/wiki/CardBus) 与 [ExpressCard](http://zh.wikipedia.org/wiki/ExpressCard) 设备. 如果你有这样的卡, 就选 "Yes". 由于绝大多数的卡都是 "yenta-compatible" 的, 所以一般你还需要选中 CONFIG_YENTA 项.')]),t._v(" "),e("dt",[t._v("CardBus yenta-compatible bridge support\nCONFIG_YENTA")]),t._v(" "),e("dd",[t._v("使用 PCMCIA 卡的基本上都需要选择这一项, 子项是一些拥有自己特定扩展的硬件, 请按实际情况选择.")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{省略的部分请按照自己实际使用的 PCMCIA 卡选择}")])])]),t._v(" "),e("dt",[t._v("Support for PCI Hotplug\nCONFIG_HOTPLUG_PCI")]),t._v(" "),e("dd",[t._v("PCI 热插拔不仅仅针对 PCI 和 PCI-E 设备, 也包括 [CardBus](http://zh.wikipedia.org/wiki/CardBus) 与 [ExpressCard](http://zh.wikipedia.org/wiki/ExpressCard) 设备. 请按需选择.")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{省略的部分请按照自己实际使用 PCI 控制器进行选择}")]),t._v(" "),e("dt",[t._v("RapidIO support\nCONFIG_RAPIDIO")]),t._v(" "),e("dd",[t._v("[RapidIO](http://baike.baidu.com/view/1237941.htm) 总线支持. 这种总线主要用于嵌入式系统.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Discovery timeout duration (seconds)\nCONFIG_RAPIDIO_DISC_TIMEOUT")]),t._v(" "),e("dd",[t._v("等待主机完成枚举 (也就是初始化) 的超时秒数.")]),t._v(" "),e("dt",[t._v("Enable RapidIO Input/Output Ports\nCONFIG_RAPIDIO_ENABLE_RX_TX_PORTS")]),t._v(" "),e("dd",[t._v("开启所有 RapidIO Input/Output 端口.")]),t._v(" "),e("dt",[t._v("DMA Engine support for RapidIO\nCONFIG_RAPIDIO_DMA_ENGINE")]),t._v(" "),e("dd",[t._v("使用 [DMA 引擎](http://zhidao.baidu.com/question/467321157.html) (CONFIG_DMADEVICES) 进行 RapidIO 数据传输")]),t._v(" "),e("dt",[t._v("RapidIO subsystem debug messages\nCONFIG_RAPIDIO_DEBUG")]),t._v(" "),e("dd",[t._v("将 RapidIO 调试信息输出到系统日志里. 如果你想诊断 RapidIO 设备的故障, 可以开启, 否则应该关闭.")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{省略的部分请按照自己实际使用的控制器进行选择}")])])]),t._v(" "),e("dt",[t._v("Mark VGA/VBE/EFI FB as generic system framebuffer\nCONFIG_X86_SYSFB")]),t._v(" "),e("dd",[t._v('此选项的主要是为 simplefb(可作为 VGA/VBE/EFI FB 的单一替代品通用于 BIOS 和 UEFI 平台) 提供支持, 仅在你确实需要开启 CONFIG_FB_SIMPLE 选项时才需要选 "Y", 否则请选 "N".')])]),t._v(" "),e("h2",{attrs:{id:"executable-file-formats-emulations"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#executable-file-formats-emulations"}},[t._v("#")]),t._v(" Executable file formats / Emulations")]),t._v(" "),e("p",[t._v("可执行文件格式 / 仿真")]),t._v(" "),e("dl",[e("dt",[t._v("Kernel support for ELF binaries\nCONFIG_BINFMT_ELF")]),t._v(" "),e("dd",[t._v("ELF 是最常用的跨平台二进制文件格式, 支持动态连接, 支持不同的硬件平台, 支持不同的操作系统. 必选, 除非你知道自己在做什么.")]),t._v(" "),e("dt",[t._v("Write ELF core dumps with partial segments\nCONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS")]),t._v(" "),e("dd",[t._v('如果你打算在此 Linux 上开发应用程序或者帮助别人调试 bug, 那么就选 "Y", 否则选 "N". 注意这里的调试和开发不是指内核调试和开发, 是应用程序的调试和开发.')]),t._v(" "),e("dt",[t._v("Kernel support for scripts starting with #!\nCONFIG_BINFMT_SCRIPT")]),t._v(" "),e("dd",[t._v('支持以 "#!/path/to/interpreter" 行开头的脚本. 务必 "Y", 不要 "M" 或 "N", 除非你知道自己在做什么.')]),t._v(" "),e("dt",[t._v("Kernel support for MISC binaries\nCONFIG_BINFMT_MISC")]),t._v(" "),e("dd",[t._v('允许插入二进制封装层到内核中, **直接运行** Java,.NET(Mono-based),Python,Emacs-Lisp 等语言编译的二进制程序时需要它, DOSEMU 也需要它. 想要更方便的使用此特性 ([指定特定类型的文件用特定的程序打开](http://blog.csdn.net/roland_sun/article/details/50062295)), 你还需要使用 "mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc" 挂载 [binfmt_misc](http://guaneryu.com/blog/?tag=binfmt_misc) 伪文件系统. 具体详情可以参考 "[Documentation/binfmt_misc.txt](https://www.kernel.org/doc/Documentation/binfmt_misc.txt)" 文档.')]),t._v(" "),e("dt",[t._v("Enable core dump support\nCONFIG_COREDUMP")]),t._v(" "),e("dd",[t._v('[核心转储 (core dump)](http://zh.wikipedia.org/wiki/%E6%A0%B8%E5%BF%83%E6%96%87%E4%BB%B6) 支持. 如果你打算在此 Linux 上开发应用程序或者帮助别人调试 bug, 那么就选 "Y", 否则选 "N". 注意这里的调试和开发不是指内核调试和开发, 是应用程序的调试和开发.')]),t._v(" "),e("dt",[t._v("IA32 Emulation\nCONFIG_IA32_EMULATION")]),t._v(" "),e("dd",[t._v("允许在 64 位内核中运行 32 位代码. 除非你打算使用纯 64 位环境, 否则请开启此项. 提示: GRUB2 支持引导纯 64 位内核, 但是 GRUB 不支持.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("IA32 a.out support\nCONFIG_IA32_AOUT")]),t._v(" "),e("dd",[t._v("早期 UNIX 系统的可执行文件格式 (32 位), 目前已经被 ELF 格式取代. 除非你需要使用古董级的二进制程序. 否则请关闭.")]),t._v(" "),e("dt",[t._v("x32 ABI for 64-bit mode\nCONFIG_X86_X32")]),t._v(" "),e("dd",[t._v('允许 32 位程序使用完整的 64 位寄存器, 以减小内存占用 ([memory footprint](http://en.wikipedia.org/wiki/Memory_footprint)). 这可以提高 32 位程序的运行性能. 如果你使用 binutils-2.22 以上的版本 (支持 elf32_x86_64), 就选 "Y", 否则选 "N".')])])])]),t._v(" "),e("h2",{attrs:{id:"networking-support"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#networking-support"}},[t._v("#")]),t._v(" Networking support")]),t._v(" "),e("p",[t._v("网络支持")]),t._v(" "),e("dl",[e("dt",[t._v("Networking options\nCONFIG_NET")]),t._v(" "),e("dd",[t._v("网络选项. systemd 依赖于它")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Packet socket\nCONFIG_PACKET")]),t._v(" "),e("dd",[t._v('链路层 [PF_PACKET](http://blog.csdn.net/tqyou85/article/details/3115664) 套接字支持. 可以让应用程序 (比如: 抓包工具 [tcpdump](http://zh.wikipedia.org/zh-cn/Tcpdump),DHCP 客户端 [dhclient](http://linux.die.net/man/8/dhclient),WiFi 设置工具 [wpa_supplicant](http://w1.fi/wpa_supplicant/)) 直接与网络设备通讯, 而无需使用内核中的其它中介协议. 不确定的选 "Y" 或 "M".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Packet: sockets monitoring interface\nCONFIG_PACKET_DIAG")]),t._v(" "),e("dd",[t._v("PF_PACKET 套接字监控接口,[ss](http://xikder.blog.51cto.com/1423200/869467) 这样的诊断工具需要它.")])])]),t._v(" "),e("dt",[t._v("Unix domain sockets\nCONFIG_UNIX")]),t._v(" "),e("dd",[t._v('[Unix domain sockets](http://learn.akae.cn/media/ch37s04.html) 支持. 许多程序都使用它在操作系统内部进行进程间通信 (IPC), 比如: X Window, syslog, udev 等等. 选 "Y", 除非你确实知道自己在做什么.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("UNIX: socket monitoring interface\nCONFIG_UNIX_DIAG")]),t._v(" "),e("dd",[t._v("UNIX 套接字监控接口,[ss](http://xikder.blog.51cto.com/1423200/869467) 这样的工具需要它.")])])]),t._v(" "),e("dt",[t._v("Transformation user configuration interface\nCONFIG_XFRM_USER")]),t._v(" "),e("dd",[t._v("为 [IPsec](http://zh.wikipedia.org/zh-cn/IPsec) 相关的工具提供 [Transformation(XFRM)](http://manpages.ubuntu.com/manpages/raring/man8/ip-xfrm.8.html) 用户配置接口")]),t._v(" "),e("dt",[t._v("Transformation sub policy support\nCONFIG_XFRM_SUB_POLICY")]),t._v(" "),e("dd",[t._v('XFRM 子策略支持, 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Transformation migrate database\nCONFIG_XFRM_MIGRATE")]),t._v(" "),e("dd",[t._v('用于动态的更新 [IPsec](http://en.wikipedia.org/wiki/IPsec) [SA(security association)](http://en.wikipedia.org/wiki/Security_association) 的定位器 (locator). 这个特性对于手机这类移动设备来讲至关重要, 因为它需要在不同的基站之间迁移. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Transformation statistics\nCONFIG_XFRM_STATISTICS")]),t._v(" "),e("dd",[t._v('转换统计, 这不是 [SNMP/MIB](http://network.51cto.com/art/201007/209214.htm) 规范的内容. 用于调试目的. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("PF_KEY sockets\nCONFIG_NET_KEY")]),t._v(" "),e("dd",[t._v("[PF_KEYv2 套接字](http://cxw06023273.iteye.com/blog/867303)支持 (与 KAME 兼容).PF_KEY 协议族主要用来处理 SA(安全关联), 对 SADB(SA 数据库) 进行管理, 主要用在 IPsec 协议中.[PF_KEY_v2 的编程 API](http://wenku.baidu.com/view/e6cc6608763231126edb1107.html) 在 [RFC2367](http://tools.ietf.org/html/rfc2367) 中定义.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("PF_KEY MIGRATE\nCONFIG_NET_KEY_MIGRATE")]),t._v(" "),e("dd",[t._v('向 PF_KEYv2 套接字中添加一个 PF_KEY MIGRATE 消息. PF_KEY MIGRATE 消息可用于动态的更新 IPsec SA(security association) 的定位器 (locator). 这个特性对于手机这类移动设备来讲至关重要, 因为它需要在不同的基站之间迁移. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("TCP/IP networking\nCONFIG_INET")]),t._v(" "),e("dd",[t._v("TCP/IP 协议, 必选!")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("IP: multicasting\nCONFIG_IP_MULTICAST")]),t._v(" "),e("dd",[t._v('[IP 多播 (IP multicasting)](http://zh.wikipedia.org/wiki/%E5%A4%9A%E6%92%AD) 支持. 指的是一个发送者向一组特定的接收者发送数据, 但只需发送一份数据副本. 实际应用的场合很少,[MBONE](http://www.baike.com/wiki/Mbone) 算是其中之一, 与 RTP 等音视频协议相结合也算一种. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("IP: advanced router\nCONFIG_IP_ADVANCED_ROUTER")]),t._v(" "),e("dd",[t._v("高级路由支持, 需要开启内核的 IP 转发功能 (echo 1> /proc/sys/net/ipv4/ip_forward) 才能正常工作. 如果这个 Linux 系统用作专业的路由器就选上, 选上之后还需要按需选择其下的子项. 一般的主机不需要这个.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("FIB TRIE statistics\nCONFIG_IP_FIB_TRIE_STATS")]),t._v(" "),e("dd",[t._v("主要用于测试 TRIE 性能")]),t._v(" "),e("dt",[t._v("IP: policy routing\nCONFIG_IP_MULTIPLE_TABLES")]),t._v(" "),e("dd",[t._v("策略路由")]),t._v(" "),e("dt",[t._v("IP: equal cost multipath\nCONFIG_IP_ROUTE_MULTIPATH")]),t._v(" "),e("dd",[t._v("用于基于目的地址的负载均衡")]),t._v(" "),e("dt",[t._v("IP: verbose route monitoring\nCONFIG_IP_ROUTE_VERBOSE")]),t._v(" "),e("dd",[t._v("显示冗余的路由监控信息")])])]),t._v(" "),e("dt",[t._v("IP: kernel level autoconfiguration\nCONFIG_IP_PNP")]),t._v(" "),e("dd",[t._v('在内核启动时自动配置网卡的 ip 地址 / 路由表, 配置信息来自于以下途径: 内核引导参数, [自举协议 (BOOTP)](http://baike.baidu.com/view/32782.htm), [反向地址转换协议 (RARP)](http://baike.baidu.com/view/876146.htm), [动态主机配置协议 (DHCP)](http://zh.wikipedia.org/wiki/DHCP). 通常, 需要从网络启动的无盘工作站才需要这个东西 (此时还需要开启 CONFIG_ROOT_NFS), 一般的发行版都通过启动脚本 ([dhcpcd](http://roy.marples.name/projects/dhcpcd/)/[dhclient](http://www.isc.org/products/DHCP)/[ifconfig](http://zh.wikipedia.org/zh-cn/Ifconfig)) 配置网络. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("IP: DHCP support\nCONFIG_IP_PNP_DHCP")]),t._v(" "),e("dd",[t._v("DHCP 协议支持")]),t._v(" "),e("dt",[t._v("IP: BOOTP support\nCONFIG_IP_PNP_BOOTP")]),t._v(" "),e("dd",[t._v("BOOTP 协议支持")]),t._v(" "),e("dt",[t._v("IP: RARP support\nCONFIG_IP_PNP_RARP")]),t._v(" "),e("dd",[t._v("RARP 协议支持")])])]),t._v(" "),e("dt",[t._v("IP: tunneling\nCONFIG_NET_IPIP")]),t._v(" "),e("dd",[t._v("[IP 隧道](https://sites.google.com/site/emmoblin/linux-network-1/linux-zhongip-sui-dao), 主要目的是为了在 TCP/IP 网络中传输其他协议的数据包, 当然也包括 IP 数据包 (例如用于实现 VPN).")]),t._v(" "),e("dt",[t._v("IP: GRE demultiplexer\nCONFIG_NET_IPGRE_DEMUX")]),t._v(" "),e("dd",[t._v("GRE demultiplexer 支持. 被 CONFIG_NET_IPGRE 和 CONFIG_PPTP 所依赖.")]),t._v(" "),e("dt",[t._v("IP: GRE tunnels over IP\nCONFIG_NET_IPGRE")]),t._v(" "),e("dd",[t._v("基于 IP 的[通用路由封装](http://zkhylt.blog.51cto.com/3638719/771968) ([Generic Routing Encapsulation](http://en.wikipedia.org/wiki/Generic_Routing_Encapsulation)) 隧道支持. 该驱动主要用于对端是 Cisco 路由器的场合, 因为 Cisco 的路由器特别偏好 GRE 隧道 (而不是 CONFIG_NET_IPIP), 并且 GRE 还允许通过隧道对组播进行再分发.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("IP: broadcast GRE over IP\nCONFIG_NET_IPGRE_BROADCAST")]),t._v(" "),e("dd",[t._v('GRE/IP 的一种应用是构建一个广播 WAN([Wide Area Network](http://baike.baidu.com/view/21956.htm)), 而其看上去却很像一个跑在互联网上的 LAN([Local Area Network](http://zh.wikipedia.org/wiki/%E5%B1%80%E5%9F%9F%E7%BD%91)). 如果你想要创建这样的网络, 那么就选 "Y"(还要加上 CONFIG_IP_MROUTE).')])])]),t._v(" "),e("dt",[t._v("IP: multicast routing\nCONFIG_IP_MROUTE")]),t._v(" "),e("dd",[t._v('[组播路由](http://www.mvn.cn/multicast-details.htm)支持. 实际应用的场合很少,[MBONE](http://www.baike.com/wiki/Mbone) 算是其中之一, 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("IP: multicast policy routing\nCONFIG_IP_MROUTE_MULTIPLE_TABLES")]),t._v(" "),e("dd",[t._v("通常, 组播路由器上会运行一个单独的用户态守护进程, 根据源地址和目的地址来处理数据包. 开启此项后, 将能同时考虑数据包所带的标记 (mark) 和所通过的网络接口, 并可在用户空间同时运行多个守护进程, 每一个进程处理一张路由表.")]),t._v(" "),e("dt",[t._v("IP: PIM-SM version 1 support\nCONFIG_IP_PIMSM_V1")]),t._v(" "),e("dd",[t._v("Sparse Mode PIM (Protocol Independent Multicast) version 1 支持. 该协议被 Cisco 路由器广泛支持, 你需要特定的软件 (pimd-v1) 才能使用它.")]),t._v(" "),e("dt",[t._v("IP: PIM-SM version 2 support\nCONFIG_IP_PIMSM_V2")]),t._v(" "),e("dd",[t._v("Sparse Mode PIM (Protocol Independent Multicast) version 2 支持. 该协议的使用并不广泛, 你需要特定的软件 (pimd 或 gated-5) 才能使用它.")])])]),t._v(" "),e("dt",[t._v("IP: ARP daemon support\nCONFIG_ARPD")]),t._v(" "),e("dd",[t._v('通常情况下, 内核自身会使用 ARP 协议解析本地网络中的 IP 地址与 MAC 地址的对应关系, 并进行缓存. 开启此项后, 内核将使用用户空间的守护进程进行 ARP 解析. 这主要是为了使用其他的替代解析协议 (比如 mGRE 隧道中的 NHRP), 或调试目的. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("IP: TCP syncookie support\nCONFIG_SYN_COOKIES")]),t._v(" "),e("dd",[t._v('[TCP syncookie](http://baike.baidu.com/view/6625802.htm) 支持, 这是抵抗 [SYN flood](http://www.xfocus.net/articles/200106/208.html) 攻击的好东西. 此特性的开关可以通过 "/proc/sys/net/ipv4/tcp_syncookies" 文件控制, 写入 "1" 表示开启, 写入 "0" 表示关闭. 建议服务器环境开启此项.')]),t._v(" "),e("dt",[t._v("Virtual (secure) IP: tunneling\nCONFIG_NET_IPVTI")]),t._v(" "),e("dd",[t._v('虚拟 IP 隧道. 可以和 xfrm 隧道一起使用, 以实现 IPSEC 安全隧道, 并在其上使用路由协议. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("IP: Foo (IP protocols) over UDP\nCONFIG_NET_FOU")]),t._v(" "),e("dd",[t._v('允许将任意 IP 层协议封装到 UDP 隧道中. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("IP: AH transformation\nCONFIG_INET_AH")]),t._v(" "),e("dd",[t._v("[IPsec AH](http://wenku.baidu.com/view/dd0d200f6c85ec3a87c2c53a.html) 支持. IPsec 验证头 (AH) 可对整个数据包 (IP 报头与数据) 提供身份验证 / 完整性 / 抗重播保护. 但是它不提供保密性, 即它不对数据进行加密. 由于这个原因, AH 头正在慢慢被 ESP 头取代.")]),t._v(" "),e("dt",[t._v("IP: ESP transformation\nCONFIG_INET_ESP")]),t._v(" "),e("dd",[t._v("[IPsec ESP](http://wenku.baidu.com/view/dd0d200f6c85ec3a87c2c53a.html) 支持. IPsec 封装安全负载 (ESP) 不仅为 IP 负载提供身份验证 / 完整性 / 抗重播保护, 还提供保密性, 也就是还对数据进行加密. ESP 有两种使用模式: 传输模式 (ESP 不对整个数据包进行签名, 只对 IP 负载(不含 IP 报头) 进行保护)和隧道模式(将原始 IP 包封装进新的带有 ESP 头的 IP 包内, 可提供完整的保护).ESP 可以独立使用, 也可与 AH 组合使用(越来越少).")]),t._v(" "),e("dt",[t._v("IP: IPComp transformation\nCONFIG_INET_IPCOMP")]),t._v(" "),e("dd",[t._v("IP 静荷载压缩协议 ([IP Payload Compression Protocol](http://wenku.baidu.com/view/082419c00c22590102029d2d.html))(RFC3173) 支持. 用于支持 IPsec")]),t._v(" "),e("dt",[t._v("IP: IPsec transport mode\nCONFIG_INET_XFRM_MODE_TRANSPORT")]),t._v(" "),e("dd",[t._v("IPsec 传输模式. 常用于对等通信, 用以提供内网安全. 数据包经过了加密但 IP 头没有加密, 因此任何标准设备或软件都可查看和使用 IP 头")]),t._v(" "),e("dt",[t._v("IP: IPsec tunnel mode\nCONFIG_INET_XFRM_MODE_TUNNEL")]),t._v(" "),e("dd",[t._v("IPsec 隧道模式. 用于提供外网安全 (包括虚拟专用网络). 整个数据包(数据头和负载) 都已经过加密处理且分配有新的 ESP 头 / IP 头 / 验证尾, 从而能够隐藏受保护站点的拓扑结构")]),t._v(" "),e("dt",[t._v("IP: IPsec BEET mode\nCONFIG_INET_XFRM_MODE_BEET")]),t._v(" "),e("dd",[t._v("IPsec BEET 模式.")]),t._v(" "),e("dt",[t._v("Large Receive Offload (ipv4/tcp)\nCONFIG_INET_LRO")]),t._v(" "),e("dd",[t._v("[LRO(Large Receive Offload)](http://blog.chinaunix.net/uid-317451-id-92639.html) (ipv4/tcp) 支持. 它通过将多个 TCP 数据整合在一个 skb 结构中, 并在稍后的某个时刻作为一个大的数据包交付给上层的网络协议栈, 以减少上层协议栈处理 skb 的开销, 提高 Linux 系统接收 TCP 数据包的能力. 目前, 主流网卡驱动都已支持此特性. 建议开启. 不过,[LRO](http://en.wikipedia.org/wiki/Large_receive_offload) 不应该在路由器上开启, 因为它破坏了 end-to-end 原则, 并会对路由性能造成显著的不利影响.")]),t._v(" "),e("dt",[t._v("INET: socket monitoring interface\nCONFIG_INET_DIAG")]),t._v(" "),e("dd",[t._v("INET(TCP,DCCP,...) socket 监视接口, 一些 Linux 本地工具 (如: 包含 ss 的 [iproute2](http://www.linuxfoundation.org/collaborate/workgroups/networking/iproute2)) 需要使用它")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("UDP: socket monitoring interface\nCONFIG_INET_UDP_DIAG")]),t._v(" "),e("dd",[t._v("UDP socket 监视接口, 一些 Linux 本地工具 (如: 包含 ss 的 [iproute2](http://www.linuxfoundation.org/collaborate/workgroups/networking/iproute2)) 需要使用它")])])]),t._v(" "),e("dt",[t._v("TCP: advanced congestion control\nCONFIG_TCP_CONG_ADVANCED")]),t._v(" "),e("dd",[t._v('高级[拥塞控制](http://baike.baidu.com/view/1453183.htm), 子项提供多种[拥塞控制算法](http://blog.csdn.net/zhangskd/article/details/6715751)供选用. 如果没有特殊需求就别选了, 内核会自动将默认的拥塞控制设为 "CUBIC" 并将 "new Reno" 作为候补. 仅在你确实知道自己需要的情况下选 "Y". 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("TCP: MD5 Signature Option support (RFC2385)\nCONFIG_TCP_MD5SIG")]),t._v(" "),e("dd",[t._v("[RFC2385](ftp://ftp.isi.edu/in-notes/rfc2385.txt) 中描述了一种对 TCP 会话进行 MD5 签名的保护机制. 目前仅用于保护互联网运营商骨干路由器间的 [BGP](http://zh.wikipedia.org/wiki/%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE) 会话. 一般的路由器 / 服务器等设备根本不需要这个.")]),t._v(" "),e("dt",[t._v("The IPv6 protocol\nCONFIG_IPV6")]),t._v(" "),e("dd",[t._v("引领未来的 [IPv6](http://zh.wikipedia.org/wiki/IPv6) 支持.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("IPv6: Privacy Extensions (RFC 3041) support\nCONFIG_IPV6_PRIVACY")]),t._v(" "),e("dd",[t._v('IPv6 利用 "[Stateless Address Autoconfiguration](http://tools.ietf.org/html/rfc4862)"在无 DHCP 服务器的情况下, 产生可用的" 临时 IPv6 地址 ". 而本选项则为这个机制增加" 隐私扩展 "([RFC4941](http://tools.ietf.org/html/rfc4941)) 保护. 默认状态下, 内核并不生产 "临时地址", 需要 "echo 2 >/proc/sys/net/ipv6/conf/all/use_tempaddr" 才能开启')]),t._v(" "),e("dt",[t._v("IPv6: Router Preference (RFC 4191) support\nCONFIG_IPV6_ROUTER_PREF")]),t._v(" "),e("dd",[t._v('主机连上 IPv6 网络后, 会发出路由器邀请包 (Router Solicitation), 路由器则应答路由器公告包 (Router Advertisement), 其中包含网关地址 / IPv6 前缀 / DNS 地址, 这样主机就能取得 IPv6 地址, 并连接到互联网上, 这就是无状态地址自动分配 (StateLess Address AutoConfiguration)."[Router Preference](http://www.ietf.org/rfc/rfc4191.txt)"是"Router Advertisement" 包的可选扩展. 它可以改进主机选中路由器的能力, 特别是在多归属 ([multi-homed](http://blog.chinaunix.net/uid-16459552-id-3761490.html)) 网络中. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("IPv6: Route Information (RFC 4191) support\nCONFIG_IPV6_ROUTE_INFO")]),t._v(" "),e("dd",[t._v('对 "[Route Information](http://www.ietf.org/rfc/rfc4191.txt)" 的实验性支持.')])])]),t._v(" "),e("dt",[t._v("IPv6: Enable RFC 4429 Optimistic DAD\nCONFIG_IPV6_OPTIMISTIC_DAD")]),t._v(" "),e("dd",[t._v('乐观[重复地址检测](http://kapok.blog.51cto.com/517862/130464) ([Optimistic Duplicate Address Detection](http://tools.ietf.org/html/rfc4429)) 的实验性支持. 可以更快的进行自动地址配置. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("IPv6: AH transformation\nCONFIG_INET6_AH")]),t._v(" "),e("dd",[t._v('IPsec AH 支持. 不确定的选 "Y" 或 "M".AH 头正在慢慢被 ESP 头取代.')]),t._v(" "),e("dt",[t._v("IPv6: ESP transformation\nCONFIG_INET6_ESP")]),t._v(" "),e("dd",[t._v('IPsec ESP 支持. 不确定的选 "Y" 或 "M".')]),t._v(" "),e("dt",[t._v("IPv6: IPComp transformation\nCONFIG_INET6_IPCOMP")]),t._v(" "),e("dd",[t._v('IPv6 静荷载压缩协议 ([IP Payload Compression Protocol](http://wenku.baidu.com/view/082419c00c22590102029d2d.html))(RFC3173) 支持. 用于支持 IPsec. 不确定的选 "Y" 或 "M".')]),t._v(" "),e("dt",[t._v("IPv6: Mobility\nCONFIG_IPV6_MIP6")]),t._v(" "),e("dd",[t._v('[移动 IPv6(RFC3775)](http://wenku.baidu.com/view/13c8a2dc26fff705cc170af2.html) 支持. 主要用于移动设备. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("IPv6: IPsec transport mode\nCONFIG_INET6_XFRM_MODE_TRANSPORT")]),t._v(" "),e("dd",[t._v('IPsec 传输模式. 常用于对等通信, 用以提供内网安全. 数据包经过了加密但 IP 头没有加密, 因此任何标准设备或软件都可查看和使用 IP 头. 不确定的选 "Y" 或 "M".')]),t._v(" "),e("dt",[t._v("IPv6: IPsec tunnel mode\nCONFIG_INET6_XFRM_MODE_TUNNEL")]),t._v(" "),e("dd",[t._v('IPsec 隧道模式. 用于提供外网安全 (包括虚拟专用网络). 整个数据包(数据头和负载) 都已经过加密处理且分配有新的 ESP 头 / IP 头 / 验证尾, 从而能够隐藏受保护站点的拓扑结构. 不确定的选 "Y" 或 "M".')]),t._v(" "),e("dt",[t._v("IPv6: IPsec BEET mode\nCONFIG_INET6_XFRM_MODE_BEET")]),t._v(" "),e("dd",[t._v('IPsec BEET 模式. 不确定的选 "Y" 或 "M".')]),t._v(" "),e("dt",[t._v("IPv6: MIPv6 route optimization mode\nCONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION")]),t._v(" "),e("dd",[t._v('[移动 IPv6(Mobile IPv6)](http://man.chinaunix.net/network/Linux_Mobile_IPv6_HowTo/index.htm) 路由优化模式. 主要用于移动设备. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("IPv6: IPv6-in-IPv4 tunnel (SIT driver)\nCONFIG_IPV6_SIT")]),t._v(" "),e("dd",[t._v('在 IPv4 网络上建立 IPv6 隧道. 如果你希望可以通过 IPv4 网络接入一个 IPv6 网络, 可以选 "Y" 或 "M", 否则选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("IPv6: IPv6 Rapid Deployment (6RD)\nCONFIG_IPV6_SIT_6RD")]),t._v(" "),e("dd",[t._v('[IPv6 快速部署 (6RD)](http://www.a10networks.com.cn/products/axseries-IPv6_rapid_deployment_6rd.php) 支持. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("IPv6: IP-in-IPv6 tunnel (RFC2473)\nCONFIG_IPV6_TUNNEL")]),t._v(" "),e("dd",[t._v('IPv6-in-IPv6/IPv4-in-IPv6 隧道 ([RFC2473](http://wenku.baidu.com/view/8f221d6b1eb91a37f1115c62.html)) 支持. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("IPv6: GRE tunnel\nCONFIG_IPV6_GRE")]),t._v(" "),e("dd",[t._v("基于 IPv6 的[通用路由封装](http://zkhylt.blog.51cto.com/3638719/771968) ([Generic Routing Encapsulation](http://en.wikipedia.org/wiki/Generic_Routing_Encapsulation)) 隧道支持. 该驱动主要用于对端是 Cisco 路由器的场合, 因为 Cisco 的路由器特别偏好 GRE 隧道 (而不是 CONFIG_IPV6_TUNNEL), 并且 GRE 还允许通过隧道对组播进行再分发.")]),t._v(" "),e("dt",[t._v("IPv6: Multiple Routing Tables\nCONFIG_IPV6_MULTIPLE_TABLES")]),t._v(" "),e("dd",[t._v('[多重路由表](http://blog.csdn.net/oohaha_123/article/details/8597761) ([Multiple Routing Tables](http://www.study-area.org/tips/m_routing.htm)) 支持. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("IIPv6: source address based routing\nCONFIG_IPV6_SUBTREES")]),t._v(" "),e("dd",[t._v('允许根据源地址或前缀进行路由. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("IPv6: multicast routing\nCONFIG_IPV6_MROUTE")]),t._v(" "),e("dd",[t._v('测试性的 IPv6 [组播路由](http://www.mvn.cn/multicast-details.htm)支持. 实际应用的场合很少, 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("IPv6: multicast policy routing\nCONFIG_IPV6_MROUTE_MULTIPLE_TABLES")]),t._v(" "),e("dd",[t._v("通常, 组播路由器上会运行一个单独的用户态守护进程, 根据源地址和目的地址来处理数据包. 开启此项后, 将能同时考虑数据包所带的标记 (mark) 和所通过的网络接口, 并可在用户空间同时运行多个守护进程, 每一个进程处理一张路由表.")]),t._v(" "),e("dt",[t._v("IPv6: PIM-SM version 2 support\nCONFIG_IPV6_PIMSM_V2")]),t._v(" "),e("dd",[t._v("IPv6 PIM multicast routing protocol PIM-SMv2 支持.")])])])])]),t._v(" "),e("dt",[t._v("NetLabel subsystem support\nCONFIG_NETLABEL")]),t._v(" "),e("dd",[t._v("[NetLabel](http://lwn.net/Articles/204905/) 子系统支持. NetLabel 子系统为诸如 CIPSO 与 RIPSO 之类能够在分组信息上添加标签的协议提供支持, 看不懂就别选了.")])])]),t._v(" "),e("dt",[t._v("Security Marking\nCONFIG_NETWORK_SECMARK")]),t._v(" "),e("dd",[t._v("对网络包进行安全标记, 类似于 nfmark, 但主要是为安全目的而设计. 看不懂的就别选了")]),t._v(" "),e("dt",[t._v("Timestamping in PHY devices\nCONFIG_NETWORK_PHY_TIMESTAMPING")]),t._v(" "),e("dd",[t._v('允许在硬件支持的前提下, 为物理层 ([PHY](http://zh.wikipedia.org/wiki/PHY)) 数据包打上时间戳. 这会略微增加发送与接收的开销. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Network packet filtering framework (Netfilter)\nCONFIG_NETFILTER")]),t._v(" "),e("dd",[t._v('[Netfilter](http://www.ha97.com/4082.html) 可以对数据包进行过滤和修改, 可以作为防火墙 ("packet filter" 或 "proxy-based") 或网关 (NAT) 或代理 (proxy) 或网桥使用.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Network packet filtering debugging\nCONFIG_NETFILTER_DEBUG")]),t._v(" "),e("dd",[t._v("仅供开发者调试 Netfilter 使用")]),t._v(" "),e("dt",[t._v("Advanced netfilter configuration\nCONFIG_NETFILTER_ADVANCED")]),t._v(" "),e("dd",[t._v('选 "Y" 将会显示所有模块供用户选择, 选 "N" 则会隐藏一些不常用的模块, 并自动将常用模块设为 "M".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Bridged IP/ARP packets filtering\nCONFIG_BRIDGE_NETFILTER")]),t._v(" "),e("dd",[t._v('如果你希望使用桥接防火墙就打开它. Docker 依赖于它. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("Core Netfilter Configuration")]),t._v(" "),e("dd",[t._v("核心 Netfilter 配置 (当包流过 Chain 时如果 match 某个规则那么将由该规则的 target 来处理, 否则将由同一个 Chain 中的下一个规则进行匹配, 若不 match 所有规则那么最终将由该 Chain 的 policy 进行处理)")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Netfilter ingress support\nCONFIG_NETFILTER_INGRESS")]),t._v(" "),e("dd",[t._v("允许将入站包进行分类.")]),t._v(" "),e("dt",[t._v("Netfilter NFACCT over NFNETLINK interface\nCONFIG_NETFILTER_NETLINK_ACCT")]),t._v(" "),e("dd",[t._v("允许通过 [NFNETLINK](http://www.netfilter.org/projects/libnfnetlink/) 接口支持 [NFACCT](http://netfilter.org/projects/libnetfilter_acct/index.html)(记账).")]),t._v(" "),e("dt",[t._v("Netfilter NFQUEUE over NFNETLINK interface\nCONFIG_NETFILTER_NETLINK_QUEUE")]),t._v(" "),e("dd",[t._v("允许通过 [NFNETLINK](http://www.netfilter.org/projects/libnfnetlink/) 接口支持 [NFQUEUE](https://home.regit.org/netfilter-en/using-nfqueue-and-libnetfilter_queue/)(排队).")]),t._v(" "),e("dt",[t._v("Netfilter LOG over NFNETLINK interface\nCONFIG_NETFILTER_NETLINK_LOG")]),t._v(" "),e("dd",[t._v('允许通过 [NFNETLINK](http://www.netfilter.org/projects/libnfnetlink/) 接口支持 "LOG"(日志). 该选项废弃了 ipt_ULOG 和 ebg_ulog 机制, 并打算在将来废弃基于 syslog 的 ipt_LOG 和 ip6t_LOG 模块.')]),t._v(" "),e("dt",[t._v("Netfilter connection tracking support\nCONFIG_NF_CONNTRACK")]),t._v(" "),e("dd",[t._v("连接追踪 (connection tracking) 支持, 连接跟踪把所有连接都保存在一个表格内, 并将每个包关联到其所属的连接. 可用于报文伪装或地址转换, 也可用于增强包过滤能力.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Connection mark tracking support\nCONFIG_NF_CONNTRACK_MARK")]),t._v(" "),e("dd",[t._v("允许对连接进行标记, 与针对单独的包进行标记的不同之处在于它是针对连接流的. CONNMARK target 和 connmark match 需要它的支持.")]),t._v(" "),e("dt",[t._v("Connection tracking security mark support\nCONFIG_NF_CONNTRACK_SECMARK")]),t._v(" "),e("dd",[t._v("允许对连接进行安全标记, 通常这些标记包 (SECMARK) 复制到其所属连接(CONNSECMARK), 再从连接复制到其关联的包(SECMARK).")]),t._v(" "),e("dt",[t._v("Connection tracking zones\nCONFIG_NF_CONNTRACK_ZONES")]),t._v(" "),e("dd",[t._v('"[conntrack zones](http://lwn.net/Articles/370152/)"支持. 通常, 每个连接需要一个全局唯一标示符, 而"conntrack zones" 允许在不同 zone 内的连接使用相同的标识符.')]),t._v(" "),e("dt",[t._v("Supply CT list in procfs (OBSOLETE)\nCONFIG_NF_CONNTRACK_PROCFS")]),t._v(" "),e("dd",[t._v('已被废弃, 选 "N".')]),t._v(" "),e("dt",[t._v("Connection tracking events\nCONFIG_NF_CONNTRACK_EVENTS")]),t._v(" "),e("dd",[t._v('连接跟踪事件支持. 如果启用这个选项, 连接跟踪代码将提供一个 "notifier" 链, 它可以被其它内核代码用来获知连接跟踪状态的改变')]),t._v(" "),e("dt",[t._v("Connection tracking timeout\nCONFIG_NF_CONNTRACK_TIMEOUT")]),t._v(" "),e("dd",[t._v('连接跟踪 "timeout" 扩展. 这样你就可以在网络流上通过 CT target 附加超时策略.')]),t._v(" "),e("dt",[t._v("Connection tracking timestamping\nCONFIG_NF_CONNTRACK_TIMESTAMP")]),t._v(" "),e("dd",[t._v("时间戳支持. 这样你就能在连接建立和断开时打上时间戳.")]),t._v(" "),e("dt",[t._v("DCCP protocol connection tracking support\nCONFIG_NF_CT_PROTO_DCCP")]),t._v(" "),e("dd",[t._v("[DCCP 协议](http://zh.wikipedia.org/zh-cn/DCCP)支持.")]),t._v(" "),e("dt",[t._v("SCTP protocol connection tracking support\nCONFIG_NF_CT_PROTO_SCTP")]),t._v(" "),e("dd",[t._v("[SCTP 协议](http://www.ibm.com/developerworks/cn/linux/l-sctp/)支持.")]),t._v(" "),e("dt",[t._v("UDP-Lite protocol connection tracking support\nCONFIG_NF_CT_PROTO_UDPLITE")]),t._v(" "),e("dd",[t._v("[UDP-Lite](http://net.chinaunix.net/5/2006/12/15/1142339.shtml) 支持.")]),t._v(" "),e("dt",[t._v("Amanda backup protocol support\nCONFIG_NF_CONNTRACK_AMANDA")]),t._v(" "),e("dd",[t._v("[Amanda](http://www.amanda.org/) 备份协议支持.")]),t._v(" "),e("dt",[t._v("FTP protocol support\nCONFIG_NF_CONNTRACK_FTP")]),t._v(" "),e("dd",[t._v("[文件传输协议 (FTP)](http://www.cnbeta.com/articles/171754.htm) 支持. 跟踪 FTP 连接需要额外的帮助程序.")]),t._v(" "),e("dt",[t._v("H.323 protocol support\nCONFIG_NF_CONNTRACK_H323")]),t._v(" "),e("dd",[t._v("[H.323 协议](http://networking.ctocio.com.cn/tips/192/6490692.shtml)支持.")]),t._v(" "),e("dt",[t._v("IRC protocol support\nCONFIG_NF_CONNTRACK_IRC")]),t._v(" "),e("dd",[t._v("[IRC](http://zh.wikipedia.org/zh-cn/IRC) 扩展协议 [DCC(Direct Client-to-Client Protocol)](http://en.wikipedia.org/wiki/Direct_Client-to-Client) 支持. 该协议允许用户之间绕开服务器直接聊天和传输文件.")]),t._v(" "),e("dt",[t._v("NetBIOS name service protocol support\nCONFIG_NF_CONNTRACK_NETBIOS_NS")]),t._v(" "),e("dd",[t._v("[NetBIOS](http://baike.baidu.com/view/491843.htm) 协议支持.")]),t._v(" "),e("dt",[t._v("SNMP service protocol support\nCONFIG_NF_CONNTRACK_SNMP")]),t._v(" "),e("dd",[t._v("[SNMP](http://baike.baidu.com/view/2899.htm) 协议支持.")]),t._v(" "),e("dt",[t._v("PPtP protocol support\nCONFIG_NF_CONNTRACK_PPTP")]),t._v(" "),e("dd",[t._v("[RFC2637](http://tools.ietf.org/html/rfc2637) [点对点隧道协议 (Point to Point Tunnelling Protocol)](http://baike.baidu.com/view/32771.htm) 协议支持.")]),t._v(" "),e("dt",[t._v("SANE protocol support\nCONFIG_NF_CONNTRACK_SANE")]),t._v(" "),e("dd",[t._v("[SANE](http://www.sane-project.org/) 协议支持.")]),t._v(" "),e("dt",[t._v("SIP protocol support\nCONFIG_NF_CONNTRACK_SIP")]),t._v(" "),e("dd",[t._v("[SIP](http://baike.baidu.com/view/51013.htm) 协议支持.")]),t._v(" "),e("dt",[t._v("TFTP protocol support\nCONFIG_NF_CONNTRACK_TFTP")]),t._v(" "),e("dd",[t._v("[TFTP](http://baike.baidu.com/view/23881.htm) 协议支持.")]),t._v(" "),e("dt",[t._v("Connection tracking netlink interface\nCONFIG_NF_CT_NETLINK")]),t._v(" "),e("dd",[t._v("基于 [netlink](http://blog.csdn.net/dog250/article/details/6425664) 的用户接口支持.")]),t._v(" "),e("dt",[t._v("Connection tracking timeout tuning via Netlink\nCONFIG_NF_CT_NETLINK_TIMEOUT")]),t._v(" "),e("dd",[t._v("通过 [Netlink](http://www.ibm.com/developerworks/cn/linux/l-kerns-usrs/) 机制支持对连接追踪超时进行细粒度的调节: 允许为特定的网络流指定超时策略, 而不是使用统一的全局超时策略.")]),t._v(" "),e("dt",[t._v("Connection tracking helpers in user-space via Netlink\nCONFIG_NF_CT_NETLINK_HELPER")]),t._v(" "),e("dd",[t._v("通过 [Netlink](http://www.ibm.com/developerworks/cn/linux/l-kerns-usrs/) 机制为用户空间的连接追踪帮助程序提供基础框架.")]),t._v(" "),e("dt",[t._v("NFQUEUE integration with Connection Tracking\nCONFIG_NETFILTER_NETLINK_QUEUE_CT")]),t._v(" "),e("dd",[t._v("开启此项后, 即使网络包已经在队列 (NFQUEUE) 中, 它依然可以包含连接追踪信息.")])])]),t._v(" "),e("dt",[t._v("Transparent proxying support\nCONFIG_NETFILTER_TPROXY")]),t._v(" "),e("dd",[t._v('透明代理支持, 也就是可以处理非本地的 IPv4 TCP/UDP 套接字. 此功能需要配合一些 iptables 规则和策略路由才能工作. 详见 "[Documentation/networking/tproxy.txt](https://www.kernel.org/doc/Documentation/networking/tproxy.txt)" 文档.')]),t._v(" "),e("dt",[t._v("Netfilter Xtables support (required for ip_tables)\nCONFIG_NETFILTER_XTABLES")]),t._v(" "),e("dd",[t._v("如果你打算使用 ip_tables, ip6_tables, arp_tables 之一就必须选上")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("nfmark target and match support\nCONFIG_NETFILTER_XT_MARK")]),t._v(" "),e("dd",[t._v('"nfmark" 是用户给包打上的一个自定义标记. 用于 match 时, 允许基于 "nfmark" 值对包进行匹配. 用于 target 时, 允许在 "mangle" 表中创建规则以改变包的 "nfmark" 值.')]),t._v(" "),e("dt",[t._v("ctmark target and match support\nCONFIG_NETFILTER_XT_CONNMARK")]),t._v(" "),e("dd",[t._v('"ctmark" 是用户以连接为组, 给同一连接中的所有包打上的自定义标记. 用法与 "nfmark" 相似.')]),t._v(" "),e("dt",[t._v("set target and match support\nCONFIG_NETFILTER_XT_SET")]),t._v(" "),e("dd",[t._v('"set" 是 [ipset](http://blog.sina.com.cn/s/blog_6bdc95ab0100m58b.html) 工具创建的 [IP 地址集合](http://blog.chinaunix.net/uid-21706718-id-3561951.html). 使用 match 可以对 IP 地址集合进行匹配, 使用 target 可以对集合中的项进行增加和删除.')]),t._v(" "),e("dt",[t._v("AUDIT target support\nCONFIG_NETFILTER_XT_TARGET_AUDIT")]),t._v(" "),e("dd",[t._v("为被 drop/accept 的包创建审计记录.")]),t._v(" "),e("dt",[t._v("CHECKSUM target support\nCONFIG_NETFILTER_XT_TARGET_CHECKSUM")]),t._v(" "),e("dd",[t._v('用于 "mangle" 表, 为缺少校验和的包添加 checksum 字段的值. 主要是为了兼容一些老旧的网络程序 (例如某些 dhcp 客户端).')]),t._v(" "),e("dt",[t._v('"CLASSIFY" target support\nCONFIG_NETFILTER_XT_TARGET_CLASSIFY')]),t._v(" "),e("dd",[t._v("允许为包设置优先级, 一些 [qdiscs](http://edseek.com/~jasonb/articles/traffic_shaping/qdiscs.html) 排队规则 (atm,cbq,dsmark,pfifo_fast,htb,prio) 需要使用它")]),t._v(" "),e("dt",[t._v('"CONNMARK" target support\nCONFIG_NETFILTER_XT_TARGET_CONNMARK')]),t._v(" "),e("dd",[t._v("这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_CONNMARK")]),t._v(" "),e("dt",[t._v('"CONNSECMARK" target support\nCONFIG_NETFILTER_XT_TARGET_CONNSECMARK')]),t._v(" "),e("dd",[t._v("针对链接进行安全标记, 同时还会将连接上的标记还原到包上 (如果链接中的包尚未进行安全标记), 通常与 SECMARK target 联合使用")]),t._v(" "),e("dt",[t._v('"CT" target support\nCONFIG_NETFILTER_XT_TARGET_CT')]),t._v(" "),e("dd",[t._v('允许为包加上连接追踪相关的参数, 比如 "event" 和 "helper".')]),t._v(" "),e("dt",[t._v('"DSCP" and "TOS" target support\nCONFIG_NETFILTER_XT_TARGET_DSCP')]),t._v(" "),e("dd",[t._v('DSCP target 允许对 IPv4/IPv6 包头部的 DSCP(Differentiated Services Codepoint)字段 (常用于 Qos) 进行修改. TOS target 允许在 "mangle" 表创建规则以修改 IPv4 包头的 TOS(Type Of Service)字段或 IPv6 包头的 Priority 字段.')]),t._v(" "),e("dt",[t._v('"HL" hoplimit target support\nCONFIG_NETFILTER_XT_TARGET_HL')]),t._v(" "),e("dd",[t._v("HL(IPv6)/TTL(IPv4) target 允许更改包头的 hoplimit/time-to-live 值.")]),t._v(" "),e("dt",[t._v('"HMARK" target support\nCONFIG_NETFILTER_XT_TARGET_HMARK')]),t._v(" "),e("dd",[t._v('允许在 "raw" 和 "mangle" 表中创建规则, 以根据特定范围的哈希计算结果设置 "[skbuff](http://wenku.baidu.com/view/b5162f3543323968011c92e0)" 标记.')]),t._v(" "),e("dt",[t._v("IDLETIMER target support\nCONFIG_NETFILTER_XT_TARGET_IDLETIMER")]),t._v(" "),e("dd",[t._v("每个被匹配的包的定时器都会被强制指定为规则指定的值, 当超时发生时会触发一个 sysfs 文件系统的通知. 剩余时间可以通过 sysfs 读取.")]),t._v(" "),e("dt",[t._v('"LED" target support\nCONFIG_NETFILTER_XT_TARGET_LED')]),t._v(" "),e("dd",[t._v("允许在满足特定条件的包通过的时候, 触发 LED 灯闪烁. 比如可以用于控制网卡的状态指示灯仅在有 SSH 活动的时候才闪烁.")]),t._v(" "),e("dt",[t._v("LOG target support\nCONFIG_NETFILTER_XT_TARGET_LOG")]),t._v(" "),e("dd",[t._v("允许向 syslog 中记录包头信息.")]),t._v(" "),e("dt",[t._v('"MARK" target support\nCONFIG_NETFILTER_XT_TARGET_MARK')]),t._v(" "),e("dd",[t._v("这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_MARK")]),t._v(" "),e("dt",[t._v('"NETMAP" target support\nCONFIG_NETFILTER_XT_TARGET_NETMAP')]),t._v(" "),e("dd",[t._v("NETMAP 用于实现一对一的静态 NAT(地址转换).")]),t._v(" "),e("dt",[t._v('"NFLOG" target support\nCONFIG_NETFILTER_XT_TARGET_NFLOG')]),t._v(" "),e("dd",[t._v("通过 nfnetlink_log 记录日志.")]),t._v(" "),e("dt",[t._v('"NFQUEUE" target Support\nCONFIG_NETFILTER_XT_TARGET_NFQUEUE')]),t._v(" "),e("dd",[t._v("用于替代老旧的 QUEUE target. 因为 NFQUEUE 能支持最多 65535 个队列, 而 QUEUE 只能支持一个.")]),t._v(" "),e("dt",[t._v('"NOTRACK" target support (DEPRECATED)\nCONFIG_NETFILTER_XT_TARGET_NOTRACK')]),t._v(" "),e("dd",[t._v("已被废弃, 勿选.")]),t._v(" "),e("dt",[t._v('"RATEEST" target support\nCONFIG_NETFILTER_XT_TARGET_RATEEST')]),t._v(" "),e("dd",[t._v("RATEEST target 允许测量网络流的传输速率.[注: rateest match 允许根据速率进行匹配.]")]),t._v(" "),e("dt",[t._v("REDIRECT target support\nCONFIG_NETFILTER_XT_TARGET_REDIRECT")]),t._v(" "),e("dd",[t._v('[REDIRECT](http://www.linuxtopia.org/Linux_Firewall_iptables/x4508.html) 是一种特别的 NAT: 所有进入的连接都被映射到其入口网卡的地址, 这样这些包就会 "流入" 本机而不是 "流过" 本机. 这主要用于实现透明代理.')]),t._v(" "),e("dt",[t._v('"TEE" - packet cloning to alternate destination\nCONFIG_NETFILTER_XT_TARGET_TEE')]),t._v(" "),e("dd",[t._v("对包进行克隆, 并将克隆的副本路由到另一个临近的路由器 ([Next Hop](http://www.techopedia.com/definition/2447/next-hop)).")]),t._v(" "),e("dt",[t._v('"TPROXY" target support\nCONFIG_NETFILTER_XT_TARGET_TPROXY')]),t._v(" "),e("dd",[t._v('类似于 REDIRECT, 但并不依赖于连接追踪和 NAT, 也只能用于 "mangle" 表, 用于将网络流量重定向到透明代理.')]),t._v(" "),e("dt",[t._v('"TRACE" target support\nCONFIG_NETFILTER_XT_TARGET_TRACE')]),t._v(" "),e("dd",[t._v("允许对包打标记, 这样内核就可以记录每一个匹配到的规则.")]),t._v(" "),e("dt",[t._v('"SECMARK" target support\nCONFIG_NETFILTER_XT_TARGET_SECMARK')]),t._v(" "),e("dd",[t._v("允许对包进行安全标记, 用于安全子系统")]),t._v(" "),e("dt",[t._v('"TCPMSS" target support\nCONFIG_NETFILTER_XT_TARGET_TCPMSS')]),t._v(" "),e("dd",[t._v("允许更改 TCP SYN 包的 [MSS(Maximum Segment Size)](http://support.huawei.com/ecommunity/bbs/10156527.html) 值, 通常 = MTU-40.")]),t._v(" "),e("dt",[t._v('"TCPOPTSTRIP" target support\nCONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP')]),t._v(" "),e("dd",[t._v("允许从 TCP 包头中剥离所有 [TCP 选项](http://wenku.baidu.com/view/5c288b51ad02de80d4d84066).")]),t._v(" "),e("dt",[t._v('"addrtype" address type match support\nCONFIG_NETFILTER_XT_MATCH_ADDRTYPE')]),t._v(" "),e("dd",[t._v("根据地址类型进行匹配: UNICAST, LOCAL, BROADCAST, ... Docker 依赖于它.")]),t._v(" "),e("dt",[t._v('"bpf" match support\nCONFIG_NETFILTER_XT_MATCH_BPF')]),t._v(" "),e("dd",[t._v("[BPF(BSD Packet Filter)](http://blog.csdn.net/dog250/article/details/9103817) 是一个强大的包匹配模块, 用于匹配那些让过滤器返回非零值的包.")]),t._v(" "),e("dt",[t._v('"cluster" match support\nCONFIG_NETFILTER_XT_MATCH_CLUSTER')]),t._v(" "),e("dd",[t._v('这个模块可以用于创建网络服务器 / 防火墙集群, 而无需借助价格昂贵的负载均衡设备. 通常, 在包必须被本节点处理的条件下, 这个 match 返回 "true". 这样, 所有节点都可以看到所有的包, 但只有匹配的节点才需要进行处理, 这样就将负载进行了分摊. 而分摊算法是基于对源地址的哈希值.')]),t._v(" "),e("dt",[t._v('"comment" match support\nCONFIG_NETFILTER_XT_MATCH_COMMENT')]),t._v(" "),e("dd",[t._v('这是一个 "伪 match", 目的是允许你在 iptables 规则集中加入注释')]),t._v(" "),e("dt",[t._v('"connbytes" per-connection counter match support\nCONFIG_NETFILTER_XT_MATCH_CONNBYTES')]),t._v(" "),e("dd",[t._v("允许针对单个连接内部每个方向 (进 / 出) 匹配已经传送的字节数 / 包数")]),t._v(" "),e("dt",[t._v('"connlabel" match support\nCONFIG_NETFILTER_XT_MATCH_CONNLABEL')]),t._v(" "),e("dd",[t._v('允许向连接分配用户自定义的标签名. 内核仅存储 bit 值, 而名称和 bit 之间的对应关系由用户空间处理. 与 "connmark" 的不同之处在于: 可以同时为一个连接分配 32 个标志位 (flag bit).')]),t._v(" "),e("dt",[t._v('"connlimit" match support\nCONFIG_NETFILTER_XT_MATCH_CONNLIMIT')]),t._v(" "),e("dd",[t._v("允许根据每一个客户端 IP 地址 (或每一段客户端 IP 地址段) 持有的并发连接数进行匹配.")]),t._v(" "),e("dt",[t._v('"connmark" connection mark match support\nCONFIG_NETFILTER_XT_MATCH_CONNMARK')]),t._v(" "),e("dd",[t._v("这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_CONNMARK")]),t._v(" "),e("dt",[t._v('"conntrack" connection tracking match support\nCONFIG_NETFILTER_XT_MATCH_CONNTRACK')]),t._v(" "),e("dd",[t._v('通用连接跟踪匹配, 是 "state" 的超集, 它允许额外的链接跟踪信息, 在需要设置一些复杂的规则 (比如网关) 时很有用. Docker 依赖于它.')]),t._v(" "),e("dt",[t._v('"cpu" match support\nCONFIG_NETFILTER_XT_MATCH_CPU')]),t._v(" "),e("dd",[t._v("根据处理包所使用的 CPU 是哪个进行匹配")]),t._v(" "),e("dt",[t._v('"dccp" protocol match support\nCONFIG_NETFILTER_XT_MATCH_DCCP')]),t._v(" "),e("dd",[t._v("[DCCP](http://baike.baidu.com/view/1619398.htm) 是打算取代 UDP 的新传输协议, 它在 UDP 的基础上增加了流控和拥塞控制机制, 面向实时业务")]),t._v(" "),e("dt",[t._v('"devgroup" match support\nCONFIG_NETFILTER_XT_MATCH_DEVGROUP')]),t._v(" "),e("dd",[t._v('允许根据网卡所属的 "设备组" 进行匹配')]),t._v(" "),e("dt",[t._v('"dscp" and "tos" match support\nCONFIG_NETFILTER_XT_MATCH_DSCP')]),t._v(" "),e("dd",[t._v("dscp match 允许根据 IPv4/IPv6 包头的 [DSCP](http://baike.baidu.com/view/98757.htm) 字段进行匹配, tos match 允许根据 IPv4 包头的 [TOS](http://baike.baidu.com/view/1047572.htm#5) 字段进行匹配")]),t._v(" "),e("dt",[t._v('"ecn" match support\nCONFIG_NETFILTER_XT_MATCH_ECN')]),t._v(" "),e("dd",[t._v("允许根据 IPv4 TCP 包头的 [ECN](http://network.51cto.com/art/200901/107005.htm) 字段进行匹配")]),t._v(" "),e("dt",[t._v('"esp" match support\nCONFIG_NETFILTER_XT_MATCH_ESP')]),t._v(" "),e("dd",[t._v("允许对 [IPSec](http://zh.wikipedia.org/wiki/IPsec) 包的 ESP 头中的 SPI(安全参数序列) 范围进行匹配")]),t._v(" "),e("dt",[t._v('"hashlimit" match support\nCONFIG_NETFILTER_XT_MATCH_HASHLIMIT')]),t._v(" "),e("dd",[t._v('此项的目的是取代 "limit", 它基于你选定的源 / 目的地址和 / 或端口动态创建 "limit bucket" 哈希表. 这样你就可以迅速创建类似这样的匹配规则:(1) 为给定的目的地址以每秒 10k 个包的速度进行匹配;(2) 为给定的源地址以每秒 500 个包的速率进行匹配')]),t._v(" "),e("dt",[t._v('"helper" match support\nCONFIG_NETFILTER_XT_MATCH_HELPER')]),t._v(" "),e("dd",[t._v("加载特定协议的连接跟踪辅助模块, 由该模块过滤所跟踪的连接类型的包, 比如 ip_conntrack_ftp 模块")]),t._v(" "),e("dt",[t._v('"hl" hoplimit/TTL match support\nCONFIG_NETFILTER_XT_MATCH_HL')]),t._v(" "),e("dd",[t._v("基于 IPv6 包头的 hoplimit 字段, 或 IPv4 包头的 time-to-live 字段进行匹配")]),t._v(" "),e("dt",[t._v('"iprange" address range match support\nCONFIG_NETFILTER_XT_MATCH_IPRANGE')]),t._v(" "),e("dd",[t._v('根据 IP 地址范围进行匹配, 而普通的 iptables 只能根据 "IP/mask" 的方式进行匹配.')]),t._v(" "),e("dt",[t._v('"ipvs" match support\nCONFIG_NETFILTER_XT_MATCH_IPVS')]),t._v(" "),e("dd",[t._v("允许根据包的 [IPVS](http://baike.baidu.com/view/2428775.htm#1) 属性进行匹配")]),t._v(" "),e("dt",[t._v('"length" match support\nCONFIG_NETFILTER_XT_MATCH_LENGTH')]),t._v(" "),e("dd",[t._v("允许对包的长度进行匹配")]),t._v(" "),e("dt",[t._v('"limit" match support\nCONFIG_NETFILTER_XT_MATCH_LIMIT')]),t._v(" "),e("dd",[t._v('允许根据包的进出速率进行规则匹配, 常和 "LOG target" 配合使用以抵抗某些 Dos 攻击')]),t._v(" "),e("dt",[t._v('"mac" address match support\nCONFIG_NETFILTER_XT_MATCH_MAC')]),t._v(" "),e("dd",[t._v("允许根据以太网的 MAC 地址进行匹配")]),t._v(" "),e("dt",[t._v('"mark" match support\nCONFIG_NETFILTER_XT_MATCH_MARK')]),t._v(" "),e("dd",[t._v("这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_MARK")]),t._v(" "),e("dt",[t._v('"multiport" Multiple port match support\nCONFIG_NETFILTER_XT_MATCH_MULTIPORT')]),t._v(" "),e("dd",[t._v("允许对 TCP 或 UDP 包同时匹配多个不连续的端口 (通常情况下只能匹配单个端口或端口范围)")]),t._v(" "),e("dt",[t._v('"nfacct" match support\nCONFIG_NETFILTER_XT_MATCH_NFACCT')]),t._v(" "),e("dd",[t._v("允许通过 nfnetlink_acct 使用扩展记账")]),t._v(" "),e("dt",[t._v('"osf" Passive OS fingerprint match\nCONFIG_NETFILTER_XT_MATCH_OSF')]),t._v(" "),e("dd",[t._v("开启 [Passive OS Fingerprinting](http://en.wikipedia.org/wiki/TCP/IP_stack_fingerprinting) 模块, 以允许通过进入的 TCP SYN 包被动匹配远程操作系统. 规则和加载程序可以从这里获取: http://www.ioremap.net/projects/osf")]),t._v(" "),e("dt",[t._v('"owner" match support\nCONFIG_NETFILTER_XT_MATCH_OWNER')]),t._v(" "),e("dd",[t._v("基于创建套接字的本地进程身份 (user/group) 进行匹配, 还可以用于检查一个套接字是否确实存在")]),t._v(" "),e("dt",[t._v('IPsec "policy" match support\nCONFIG_NETFILTER_XT_MATCH_POLICY')]),t._v(" "),e("dd",[t._v("基于 IPsec policy 进行匹配")]),t._v(" "),e("dt",[t._v('"physdev" match support\nCONFIG_NETFILTER_XT_MATCH_PHYSDEV')]),t._v(" "),e("dd",[t._v("允许对进入或离开所经过的物理网口进行匹配")]),t._v(" "),e("dt",[t._v('"pkttype" packet type match support\nCONFIG_NETFILTER_XT_MATCH_PKTTYPE')]),t._v(" "),e("dd",[t._v("允许对封包目的地址类别 (广播 / 组播 / 直播) 进行匹配")]),t._v(" "),e("dt",[t._v('"quota" match support\nCONFIG_NETFILTER_XT_MATCH_QUOTA')]),t._v(" "),e("dd",[t._v("允许对总字节数的限额值进行匹配")]),t._v(" "),e("dt",[t._v('"rateest" match support\nCONFIG_NETFILTER_XT_MATCH_RATEEST')]),t._v(" "),e("dd",[t._v("根据 RATEEST target 评估的速率值进行匹配")]),t._v(" "),e("dt",[t._v('"realm" match support\nCONFIG_NETFILTER_XT_MATCH_REALM')]),t._v(" "),e("dd",[t._v("允许根据 iptables 中的路由子系统中的 realm 值进行匹配. 它与 tc 中的 CONFIG_NET_CLS_ROUTE4 非常类似.")]),t._v(" "),e("dt",[t._v('"recent" match support\nCONFIG_NETFILTER_XT_MATCH_RECENT')]),t._v(" "),e("dd",[t._v("[recent match](http://snowman.net/projects/ipt_recent/) 用于创建一个或多个最近使用过的地址列表, 然后又可以根据这些列表再进行匹配.")]),t._v(" "),e("dt",[t._v('"sctp" protocol match support\nCONFIG_NETFILTER_XT_MATCH_SCTP')]),t._v(" "),e("dd",[t._v('支持根据[流控制传输协议 (SCTP)](http://www.ibm.com/developerworks/cn/linux/l-sctp/) 源 / 目的端口和 "chunk type" 进行匹配.')]),t._v(" "),e("dt",[t._v('"socket" match support\nCONFIG_NETFILTER_XT_MATCH_SOCKET')]),t._v(" "),e("dd",[t._v("can be used to match packets for which a TCP or UDP socket lookup finds a valid socket. It can be used in combination with the MARK target and policy routing to implement full featured non-locally bound sockets.")]),t._v(" "),e("dt",[t._v('"state" match support\nCONFIG_NETFILTER_XT_MATCH_STATE')]),t._v(" "),e("dd",[t._v("这是对包进行分类的有力工具, 它允许利用连接跟踪信息对连接中处于特定状态的包进行匹配")]),t._v(" "),e("dt",[t._v('"statistic" match support\nCONFIG_NETFILTER_XT_MATCH_STATISTIC')]),t._v(" "),e("dd",[t._v("允许根据一个给定的百分率对包进行周期性的或随机性的匹配")]),t._v(" "),e("dt",[t._v('"string" match support\nCONFIG_NETFILTER_XT_MATCH_STRING')]),t._v(" "),e("dd",[t._v("允许根据包所承载的数据中包含的特定字符串进行匹配")]),t._v(" "),e("dt",[t._v('"tcpmss" match support\nCONFIG_NETFILTER_XT_MATCH_TCPMSS')]),t._v(" "),e("dd",[t._v("允许根据 TCP SYN 包头中的 MSS(最大分段长度) 选项的值进行匹配")]),t._v(" "),e("dt",[t._v('"time" match support\nCONFIG_NETFILTER_XT_MATCH_TIME')]),t._v(" "),e("dd",[t._v("根据包的到达时刻 (外面进入的包) 或者离开时刻 (本地生成的包) 进行匹配")]),t._v(" "),e("dt",[t._v('"u32" match support\nCONFIG_NETFILTER_XT_MATCH_U32')]),t._v(" "),e("dd",[t._v('"u32" 允许从包中提取拥有特定 mask 的最多 4 字节数据, 将此数据移动 (shift) 特定的位数, 然后测试其结果是否位于特定的集合范围内. 更多细节可以直接参考内核源码(net/netfilter/xt_u32.c)')])])])])]),t._v(" "),e("dt",[t._v("IP set support\nCONFIG_IP_SET")]),t._v(" "),e("dd",[t._v("为内核添加 IP 集 (IP set) 支持, 然后就可以使用 CONFIG_NETFILTER_XT_SET 功能. 此特性必须配合用户态工具 [ipset](http://ipset.netfilter.org/) 一起使用.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Maximum number of IP sets\nCONFIG_IP_SET_MAX")]),t._v(" "),e("dd",[t._v('默认的最大 "set" 数, 取值范围是 [2,65534]. 此值也可以由 ip_set 模块的 max_sets 参数设置.')]),t._v(" "),e("dt",[t._v("bitmap:ip set support\nCONFIG_IP_SET_BITMAP_IP")]),t._v(" "),e("dd",[t._v('"bitmap:ip" 集合类型. 根据 IP 地址范围设定集合.')]),t._v(" "),e("dt",[t._v("bitmap:ip,mac set support\nCONFIG_IP_SET_BITMAP_IPMAC")]),t._v(" "),e("dd",[t._v('"bitmap:ip,mac" 集合类型. 根据 IP/MAC 地址对范围设定集合.')]),t._v(" "),e("dt",[t._v("bitmap:port set support\nCONFIG_IP_SET_BITMAP_PORT")]),t._v(" "),e("dd",[t._v('"bitmap:port" 集合类型. 根据端口范围设定集合.')]),t._v(" "),e("dt",[t._v("hash:ip set support\nCONFIG_IP_SET_HASH_IP")]),t._v(" "),e("dd",[t._v('"hash:ip" 集合类型. 为多个离散的 IP 地址设定集合.')]),t._v(" "),e("dt",[t._v("hash:ip,port set support\nCONFIG_IP_SET_HASH_IPPORT")]),t._v(" "),e("dd",[t._v('"hash:ip,port" 集合类型. 为多个离散的 IP/MAC 地址对设定集合.')]),t._v(" "),e("dt",[t._v("hash:ip,port,ip\nCONFIG_IP_SET_HASH_IPPORTIP")]),t._v(" "),e("dd",[t._v('"hash:ip,port,ip" 集合类型. 为多个离散的 IP / 端口 / IP 三元组设定集合.')]),t._v(" "),e("dt",[t._v("hash:ip,port,net set support\nCONFIG_IP_SET_HASH_IPPORTNET")]),t._v(" "),e("dd",[t._v('"hash:ip,port,net" 集合类型. 为多个离散的 IP / 端口 / 网段三元组设定集合.')]),t._v(" "),e("dt",[t._v("hash:net set support\nCONFIG_IP_SET_HASH_NET")]),t._v(" "),e("dd",[t._v('"hash:net" 集合类型. 为多个离散的网段设定集合')]),t._v(" "),e("dt",[t._v("hash:net,port set support\nCONFIG_IP_SET_HASH_NETPORT")]),t._v(" "),e("dd",[t._v('"hash:net,port" 集合类型. 为多个离散的网段 / 端口对设定集合')]),t._v(" "),e("dt",[t._v("hash:net,iface set support\nCONFIG_IP_SET_HASH_NETIFACE")]),t._v(" "),e("dd",[t._v('"hash:net,iface" 集合类型. 为多个离散的网段 / 网卡接口对设定集合')]),t._v(" "),e("dt",[t._v("list:set set support\nCONFIG_IP_SET_LIST_SET")]),t._v(" "),e("dd",[t._v('"list:set" 集合类型. 将多个集合组成一个更大的集合')])])]),t._v(" "),e("dt",[t._v("IP virtual server support\nCONFIG_IP_VS")]),t._v(" "),e("dd",[t._v("[IPVS](http://www.baike.com/wiki/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1)([IP Virtual Server](http://www.linuxvirtualserver.org/software/ipvs.html)) 支持. IPVS 可以帮助 [LVS](http://www.linuxvirtualserver.org/zh/lvs1.html) 基于多个后端真实服务器创建一个高性能的虚拟服务器. 可以使用三种具体的方法实现: NAT, 隧道, 直接路由 (使用较广).")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("IPv6 support for IPVS\nCONFIG_IP_VS_IPV6")]),t._v(" "),e("dd",[t._v("为 IPVS 添加 IPv6 支持")]),t._v(" "),e("dt",[t._v("IP virtual server debugging\nCONFIG_IP_VS_DEBUG")]),t._v(" "),e("dd",[t._v("为 IPVS 添加调试支持")]),t._v(" "),e("dt",[t._v("IPVS connection table size (the Nth power of 2)\nCONFIG_IP_VS_TAB_BITS")]),t._v(" "),e("dd",[t._v("设置 IPVS 连接哈希表的大小 (2"),e("sup",[t._v("CONFIG_IP_VS_TAB_BITS")]),t._v("), 取值范围是 [8,20], 默认值 12 的意思是哈希表的大小是 2"),e("sup",[t._v("12")]),t._v("=4096 项. IPVS 连接哈希表使用链表来处理哈希碰撞. 使用大的哈希表能够显著减少碰撞几率, 特别是哈希表中有成千上万连接的时候. 比较恰当的值差不多等于每秒的新建连接数乘以每个连接的平均持续秒数. 太小的值会造成太多碰撞, 从而导致性能大幅下降; 太大的值又会造成占用太多不必要的内存 (每个表项 8 字节 + 每个连接 128 字节). 该值也可以通过 ip_vs 模块的 conn_tab_bits 参数进行设置.")]),t._v(" "),e("dt",[t._v("TCP load balancing support\nCONFIG_IP_VS_PROTO_TCP")]),t._v(" "),e("dd",[t._v("TCP 传输协议负载均衡支持")]),t._v(" "),e("dt",[t._v("UDP load balancing support\nCONFIG_IP_VS_PROTO_UDP")]),t._v(" "),e("dd",[t._v("UDP 传输协议负载均衡支持")]),t._v(" "),e("dt",[t._v("ESP load balancing support\nCONFIG_IP_VS_PROTO_ESP")]),t._v(" "),e("dd",[t._v("IPSec ESP(Encapsulation Security Payload) 传输协议负载均衡支持")]),t._v(" "),e("dt",[t._v("AH load balancing support\nCONFIG_IP_VS_PROTO_AH")]),t._v(" "),e("dd",[t._v("IPSec AH(Authentication Header) 传输协议负载均衡支持.")]),t._v(" "),e("dt",[t._v("SCTP load balancing support\nCONFIG_IP_VS_PROTO_SCTP")]),t._v(" "),e("dd",[t._v("SCTP 传输协议负载均衡支持")]),t._v(" "),e("dt",[t._v("round-robin scheduling\nCONFIG_IP_VS_RR")]),t._v(" "),e("dd",[t._v("循环分散算法: 最简单的调度算法, 将连接简单的循环分散到后端服务器上")]),t._v(" "),e("dt",[t._v("weighted round-robin scheduling\nCONFIG_IP_VS_WRR")]),t._v(" "),e("dd",[t._v("基于权重的循环分散算法: 在循环分散的基础上, 权重较高的后端服务器接纳较多的连接")]),t._v(" "),e("dt",[t._v("least-connection scheduling\nCONFIG_IP_VS_LC")]),t._v(" "),e("dd",[t._v("最少连接算法: 将连接优先分配到活动连接最少的后端服务器")]),t._v(" "),e("dt",[t._v("weighted least-connection scheduling\nCONFIG_IP_VS_WLC")]),t._v(" "),e("dd",[t._v("基于权重的最少连接算法: 结合考虑活动连接数与服务器权重")]),t._v(" "),e("dt",[t._v("locality-based least-connection scheduling\nCONFIG_IP_VS_LBLC")]),t._v(" "),e("dd",[t._v("基于目的 IP 的最少连接算法 (常用于缓存集群): 优先根据目的 IP 地址将连接分配到特定的后端, 仅在这些后端过载时(活动连接数大于其权重) 才分散到其他后端.")]),t._v(" "),e("dt",[t._v("locality-based least-connection with replication scheduling\nCONFIG_IP_VS_LBLCR")]),t._v(" "),e("dd",[t._v("与 LBLC 类似, 不同之处在于: 前端负载均衡器会像 NAT 一样同时记住客户端 IP 与后端的对应关系, 并在新的连接到来的时候, 复用这个对应关系.")]),t._v(" "),e("dt",[t._v("destination hashing scheduling\nCONFIG_IP_VS_DH")]),t._v(" "),e("dd",[t._v("目标地址哈希表算法: 简单的根据静态设定的目标 IP 地址哈希表将连接分发到后端")]),t._v(" "),e("dt",[t._v("source hashing scheduling\nCONFIG_IP_VS_SH")]),t._v(" "),e("dd",[t._v("源地址哈希表算法: 简单的根据静态设定的源 IP 地址哈希表将连接分发到后端")]),t._v(" "),e("dt",[t._v("shortest expected delay scheduling\nCONFIG_IP_VS_SED")]),t._v(" "),e("dd",[t._v('最小期望延迟算法: 将连接分配到根据期望延迟公式 ((Ci+1)/Ui) 算得的延迟最小的后端."i" 是后端服务器编号,"Ci" 是该服务器当前的连接数,"Ui" 是该服务器的权重.')]),t._v(" "),e("dt",[t._v("never queue scheduling\nCONFIG_IP_VS_NQ")]),t._v(" "),e("dd",[t._v("无排队算法: 这是一个两阶段算法, 如果有空闲服务器, 就直接分发到空闲服务器 (而不是等待速度最快的服务器), 如果没有空闲服务器, 就分发到期望延迟最小的服务器 (SED 算法).")]),t._v(" "),e("dt",[t._v("IPVS source hashing table size (the Nth power of 2)\nCONFIG_IP_VS_SH_TAB_BITS")]),t._v(" "),e("dd",[t._v("将源 IP 地址映射到后端服务器所使用的哈希表的大小 (2"),e("sup",[t._v("CONFIG_IP_VS_SH_TAB_BITS")]),t._v("), 取值范围是 [4,20], 默认值 8 的意思是哈希表的大小是 2"),e("sup",[t._v("8")]),t._v("=256 项. 理想的大小应该是所有后端的权重乘以后端总数?")]),t._v(" "),e("dt",[t._v("FTP protocol helper\nCONFIG_IP_VS_FTP")]),t._v(" "),e("dd",[t._v("FTP 协议连接追踪帮助")]),t._v(" "),e("dt",[t._v("Netfilter connection tracking\nCONFIG_IP_VS_NFCT")]),t._v(" "),e("dd",[t._v("Netfilter 连接追踪支持")]),t._v(" "),e("dt",[t._v("SIP persistence engine\nCONFIG_IP_VS_PE_SIP")]),t._v(" "),e("dd",[t._v("基于 SIP Call-ID 提供持久连接支持")])])]),t._v(" "),e("dt",[t._v("IP: Netfilter Configuration")]),t._v(" "),e("dd",[t._v("针对 IPv4 的 Netfilter 配置")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("IPv4 connection tracking support (required for NAT)\nCONFIG_NF_CONNTRACK_IPV4")]),t._v(" "),e("dd",[t._v("IPv4 链接跟踪. 可用于包伪装或地址转换, 也可用于增强包过滤能力")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("proc/sysctl compatibility with old connection tracking\nCONFIG_NF_CONNTRACK_PROC_COMPAT")]),t._v(" "),e("dd",[t._v("用于兼容老旧的连接追踪用户态程序")])])]),t._v(" "),e("dt",[t._v("IP tables support (required for filtering/masq/NAT)\nCONFIG_IP_NF_IPTABLES")]),t._v(" "),e("dd",[t._v("要用 iptables 就肯定要选上")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v('"ah" match support\nCONFIG_IP_NF_MATCH_AH')]),t._v(" "),e("dd",[t._v("允许对 IPSec 包头的 AH 字段进行匹配")]),t._v(" "),e("dt",[t._v('"ecn" match support\nCONFIG_IP_NF_MATCH_ECN')]),t._v(" "),e("dd",[t._v("这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_MATCH_ECN")]),t._v(" "),e("dt",[t._v('"rpfilter" reverse path filter match support\nCONFIG_IP_NF_MATCH_RPFILTER')]),t._v(" "),e("dd",[t._v("对进出都使用同一个网络接口的包进行匹配")]),t._v(" "),e("dt",[t._v('"ttl" match support\nCONFIG_IP_NF_MATCH_TTL')]),t._v(" "),e("dd",[t._v("这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_MATCH_HL")]),t._v(" "),e("dt",[t._v("Packet filtering\nCONFIG_IP_NF_FILTER")]),t._v(" "),e("dd",[t._v("定义 filter 表, 以允许对包进行过滤. Docker 依赖于它.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("REJECT target support\nCONFIG_IP_NF_TARGET_REJECT")]),t._v(" "),e("dd",[t._v("允许返回一个 ICMP 错误包而不是简单的丢弃包")])])]),t._v(" "),e("dt",[t._v("ULOG target support\nCONFIG_IP_NF_TARGET_ULOG")]),t._v(" "),e("dd",[t._v("反对使用该选项, 因为它已经被 CONFIG_NETFILTER_NETLINK_LOG 代替")]),t._v(" "),e("dt",[t._v("IPv4 NAT\nCONFIG_NF_NAT_IPV4")]),t._v(" "),e("dd",[t._v("允许进行伪装 / 端口转发以及其它的 NAT 功能, 仅在你需要使用 iptables 中的 nat 表时才需要选择. Docker 依赖于它.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("MASQUERADE target support\nCONFIG_IP_NF_TARGET_MASQUERADE")]),t._v(" "),e("dd",[t._v("SNAT 是指在数据包从网卡发送出去的时候, 把数据包中的源地址部分替换为指定的 IP, 这样, 接收方就认为数据包的来源是被替换的那个 IP 的主机. 伪装 (MASQUERADE) 是一种特殊类型的 SNAT:MASQUERADE 是用发送数据的网卡上的 IP 来替换源 IP, 用于那些 IP 不固定的场合(比如拨号或者通过 DHCP 分配).Docker 依赖于它.")]),t._v(" "),e("dt",[t._v("NETMAP target support\nCONFIG_IP_NF_TARGET_NETMAP")]),t._v(" "),e("dd",[t._v("这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_TARGET_NETMAP.")]),t._v(" "),e("dt",[t._v("REDIRECT target support\nCONFIG_IP_NF_TARGET_REDIRECT")]),t._v(" "),e("dd",[t._v("这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_TARGET_REDIRECT.")]),t._v(" "),e("dt",[t._v("Basic SNMP-ALG support\nCONFIG_NF_NAT_SNMP_BASIC")]),t._v(" "),e("dd",[t._v("为 [SNMP](http://baike.baidu.com/view/2899.htm) 荷载实现 ALG(Application Layer Gateway) 支持 ([RFC2962](http://www.rfc-base.org/txt/rfc-2962.txt)).")])])]),t._v(" "),e("dt",[t._v("Packet mangling\nCONFIG_IP_NF_MANGLE")]),t._v(" "),e("dd",[t._v("在 iptables 中启用 mangle 表以便对包进行各种修改, 常用于改变包的路由")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("CLUSTERIP target support\nCONFIG_IP_NF_TARGET_CLUSTERIP")]),t._v(" "),e("dd",[t._v("CLUSTERIP target 允许你无需使用昂贵的负载均衡设备也能创建廉价的负载均衡集群")]),t._v(" "),e("dt",[t._v("ECN target support\nCONFIG_IP_NF_TARGET_ECN")]),t._v(" "),e("dd",[t._v('用于 mangle 表, 可以去除 IPv4 包头的 [ECN(Explicit Congestion Notification)](http://blog.sina.com.cn/s/blog_6cf9802d0100xtwv.html) 位, 主要用于在保持 ECN 功能的前提下, 去除网络上的 "ECN 黑洞".')]),t._v(" "),e("dt",[t._v('"TTL" target support\nCONFIG_IP_NF_TARGET_TTL')]),t._v(" "),e("dd",[t._v("这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_TARGET_HL.")])])]),t._v(" "),e("dt",[t._v("raw table support (required for NOTRACK/TRACE)\nCONFIG_IP_NF_RAW")]),t._v(" "),e("dd",[t._v("在 iptables 中添加一个 raw 表, 该表在 netfilter 框架中非常靠前, 并在 PREROUTING 和 OUTPUT 链上有钩子, 从而可以对收到的数据包在连接跟踪前进行处理")]),t._v(" "),e("dt",[t._v("Security table\nCONFIG_IP_NF_SECURITY")]),t._v(" "),e("dd",[t._v("在 iptables 中添加一个 security 表, 以支持[强制访问控制 (Mandatory Access Control)](http://baike.baidu.com/view/4420215.htm) 策略")])])]),t._v(" "),e("dt",[t._v("ARP tables support\nCONFIG_IP_NF_ARPTABLES")]),t._v(" "),e("dd",[t._v("[arptables](http://baike.baidu.com/view/3908213.htm) 支持")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("ARP packet filtering\nCONFIG_IP_NF_ARPFILTER")]),t._v(" "),e("dd",[t._v("ARP 包过滤. 对于进入和离开本地的 ARP 包定义一个 filter 表, 在桥接的情况下还可以应用于被转发的 ARP 包")]),t._v(" "),e("dt",[t._v("ARP payload mangling\nCONFIG_IP_NF_ARP_MANGLE")]),t._v(" "),e("dd",[t._v("允许对 ARP 包的荷载部分进行修改, 比如修改源和目标物理地址")])])])])]),t._v(" "),e("dt",[t._v("IPv6: Netfilter Configuration")]),t._v(" "),e("dd",[t._v("针对 IPv6 的 Netfilter 配置. 其子项内容类似于 IPv4, 需要的话可以参考前面 IPv4 的 Netfilter 配置进行选择")]),t._v(" "),e("dt",[t._v("DECnet: Netfilter Configuration")]),t._v(" "),e("dd",[t._v("针对 [DECnet](http://baike.baidu.com/view/1449756.htm) 的 Netfilter 配置")]),t._v(" "),e("dt",[t._v("Ethernet Bridge tables (ebtables) support\nCONFIG_BRIDGE_NF_EBTABLES")]),t._v(" "),e("dd",[t._v("针对以太网桥的 [ebtables](http://www.oschina.net/p/ebtables) Netfilter 配置")])])]),t._v(" "),e("dt",[t._v("The DCCP Protocol\nCONFIG_IP_DCCP")]),t._v(" "),e("dd",[t._v("数据报拥塞控制协议 ([Datagram Congestion Control Protocol](http://zh.wikipedia.org/wiki/DCCP)) 在 UDP 的基础上增加了流控和拥塞控制机制, 使数据报协议能够更好地用于流媒体业务的传输")]),t._v(" "),e("dt",[t._v("The SCTP Protocol\nCONFIG_IP_SCTP")]),t._v(" "),e("dd",[t._v("[流控制传输协议](http://zh.wikipedia.org/wiki/%E6%B5%81%E6%8E%A7%E5%88%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE) ([Stream Control Transmission Protocol](http://www.ibm.com/developerworks/cn/linux/l-sctp/)) 是一种新兴的传输层协议. TCP 协议一次只能连接一个 IP 地址而在 [SCTP](http://www.cnblogs.com/qlee/archive/2011/07/13/2105717.html) 协议一次可以连接多个 IP 地址且可以自动平衡网络负载, 一旦某一个 IP 地址失效会自动将网络负载转移到其他 IP 地址上")]),t._v(" "),e("dt",[t._v("The RDS Protocol\nCONFIG_RDS")]),t._v(" "),e("dd",[t._v("[可靠数据报套接字 (Reliable Datagram Sockets) 协议](http://network.51cto.com/art/200711/60157.htm)支持. RDS 可以使用 Infiniband 和 iWARP 作为支持 RDMA(远程直接内存访问) 的传输方式, RDMA 用于一台远程计算机访问另一台计算机的内存而无需本机计算机操作系统的辅助, 这就像直接内存访问 (DMA), 但是这里远程代替了本地计算机.")]),t._v(" "),e("dt",[t._v("The TIPC Protocol\nCONFIG_TIPC")]),t._v(" "),e("dd",[t._v("透明内部进程间通信协议 ([Transparent Inter Process Communication](http://zh.wikipedia.org/wiki/TIPC)), 以共享内存为基础实现任务和资源的调度, 专门用于集群内部通信")]),t._v(" "),e("dt",[t._v("Asynchronous Transfer Mode (ATM)\nCONFIG_ATM")]),t._v(" "),e("dd",[t._v("异步传输模式 ([ATM](http://baike.baidu.com/view/817251.htm)) 支持. 主要用于高速 LAN 和 WAN. 目前已经日薄西山了.")]),t._v(" "),e("dt",[t._v("Layer Two Tunneling Protocol (L2TP)\nCONFIG_L2TP")]),t._v(" "),e("dd",[t._v("[第二层隧道协议](http://baike.baidu.com/view/32692.htm) (RFC2661) 是一种对应用透明的隧道协议, VPN 经常使用它.")]),t._v(" "),e("dt",[t._v("802.1d Ethernet Bridging\nCONFIG_BRIDGE")]),t._v(" "),e("dd",[t._v("[802.1d](http://baike.baidu.com/view/2019315.htm) 以太网桥 (例如为 QEMU 虚拟机或 Docker 容器提供桥接网卡支持)")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("IGMP/MLD snooping\nCONFIG_BRIDGE_IGMP_SNOOPING")]),t._v(" "),e("dd",[t._v('选 "Y" 可以允许以太网桥根据 [IGMP](http://baike.baidu.com/view/876138.htm)([Internet Group Management Protocol](https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%BB%84%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE), IPv4)/[MLD](http://ithelp.ithome.com.tw/articles/10004381)([Multicast Listener Discovery](http://hanteye01.blog.fc2.com/blog-entry-6.html), IPv6) 负载选择性的转发不同端口上的多播包. 选 "N" 可以减小二进制文件的体积. 确定需要使用组播的选 "Y".')])])]),t._v(" "),e("dt",[t._v("802.1Q/802.1ad VLAN Support\nCONFIG_VLAN_8021Q")]),t._v(" "),e("dd",[t._v("[802.1Q](http://baike.baidu.com/view/116899.htm) 虚拟局域网")]),t._v(" "),e("dt",[t._v("DECnet Support\nCONFIG_DECNET")]),t._v(" "),e("dd",[t._v("[DECnet](http://baike.baidu.com/view/1449756.htm) 协议")]),t._v(" "),e("dt",[t._v("ANSI/IEEE 802.2 LLC type 2 Support\nCONFIG_LLC2")]),t._v(" "),e("dd",[t._v("PF_LLC 类型套接字支持. 也就是 [IEEE 802.2 LLC 2](http://baike.baidu.com/view/193847.htm)")]),t._v(" "),e("dt",[t._v("The IPX protocol\nCONFIG_IPX")]),t._v(" "),e("dd",[t._v("[IPX 协议](http://baike.baidu.com/view/32700.htm)是由 Novell 公司提出的运行于 OSI 模型第三层的协议, 具有可路由的特性, IPX 的地址分为网络地址和主机地址, 网络地址由管理员分配, 主机地址为 MAC 地址. 由于 IP 协议的广泛使用, IPX 的应用早已日薄西山.")]),t._v(" "),e("dt",[t._v("Appletalk protocol support\nCONFIG_ATALK")]),t._v(" "),e("dd",[t._v("[Appletalk](http://baike.baidu.com/view/25115.htm) 是苹果公司创建的一组网络协议, 仅用于苹果系列计算机.")]),t._v(" "),e("dt",[t._v("CCITT X.25 Packet Layer\nCONFIG_X25")]),t._v(" "),e("dd",[t._v("[CCITT X.25](http://www.baike.com/wiki/x.25) 协议集支持.")]),t._v(" "),e("dt",[t._v("LAPB Data Link Driver\nCONFIG_LAPB")]),t._v(" "),e("dd",[t._v("[LAPB](http://baike.baidu.com/view/1147867.htm) 协议支持.")]),t._v(" "),e("dt",[t._v("Phonet protocols family\nCONFIG_PHONET")]),t._v(" "),e("dd",[t._v("PhoNet 是 Nokia 开发的面相数据包的通信协议, 仅用于 Nokia maemo/meego 产品.")]),t._v(" "),e("dt",[t._v("IEEE Std 802.15.4 Low-Rate Wireless Personal Area Networks support\nCONFIG_IEEE802154")]),t._v(" "),e("dd",[t._v("[IEEE Std 802.15.4](http://blog.csdn.net/zwlforever/article/details/6340366) 定义了一个低速率 / 低功耗 / 低复杂度的短距离个人无线网络规范. 主要用于物联网中的传感器 / 交换器之类设备之间的互联.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("6lowpan support over IEEE 802.15.4\nCONFIG_IEEE802154_6LOWPAN")]),t._v(" "),e("dd",[t._v("在 IEEE 802.15.4 上支持 IPv6 压缩.")]),t._v(" "),e("dt",[t._v("Generic IEEE 802.15.4 Soft Networking Stack (mac802154)\nCONFIG_MAC802154")]),t._v(" "),e("dd",[t._v('为 SoftMAC 设备 (仅实现了 PHY 层) 实现硬件独立的 [IEEE Std 802.15.4](http://blog.csdn.net/zwlforever/article/details/6340366) 协议栈. 使用 HardMAC 设备的用户应该选 "N".[注意] 这里的实现既未经过认证, 也未进行充分的兼容性测试.')])])]),t._v(" "),e("dt",[t._v("QoS and/or fair queueing\nCONFIG_NET_SCHED")]),t._v(" "),e("dd",[t._v('[QoS](http://zh.wikipedia.org/zh-cn/QoS)([Quality of Service](http://baike.baidu.com/view/20897.htm)) 支持. 当内核有多个包需要通过网络发送的时候, 它需要决定哪个包先发, 那个包后发, 哪个包丢弃. 这就是包调度算法. 关闭此项表示内核使用最简单的 FIFO 算法, 开启此项后就可以使用多种不同的调度算法 (需要配合用户层工具 [iproute2+tc](ftp://ftp.tux.org/pub/net/ip-routing/)).QoS 还用于支持 [diffserv](http://diffserv.sourceforge.net/)(Differentiated Services) 和 [RSVP](http://baike.baidu.com/view/876124.htm)(Resource Reservation Protocol) 功能. 包调度的状态信息可以从 "/proc/net/psched" 文件中获取. 仅在你确实需要的时候选 "Y".')]),t._v(" "),e("dt",[t._v("Data Center Bridging support\nCONFIG_DCB")]),t._v(" "),e("dd",[t._v('[DCB(Data Center Bridging)](http://zh.community.dell.com/techcenter/b/weblog/archive/2011/08/30/ready-for-the-dcb-coming.aspx) 支持. 数据中心桥接是一组可增强传统以太网功能, 以管理通信的功能, 尤其适用于网络通信流量和传输率都很高的环境中. 光纤通道可专用于承载此类型的通信. 但是, 如果使用专用链路来仅提供光纤通道通信, 则成本可能会很高. 因此, 更多情况下使用以太网光纤通道. DCB 功能可满足光纤通道对遍历以太网时包丢失的敏感度要求. DCB 允许对等方基于优先级区分通信. 通过区分优先级, 可确保在主机之间发生拥塞时, 保持较高优先级通信的包完整性. 使用 DCB 交换协议, 通信主机可以交换会影响高速网络通信的配置信息. 然后, 对等方可对公用配置进行协商, 确保通信流不中断, 同时防止高优先级包出现包丢失. 这些功能都需要底层的网卡支持. 一般网卡都是不支持的. 所以不确定的可以选 "N".')]),t._v(" "),e("dt",[t._v("DNS Resolver support\nCONFIG_DNS_RESOLVER")]),t._v(" "),e("dd",[t._v('内核 DNS 解析支持. 用于支持 CONFIG_AFS_FS/CONFIG_CIFS/CONFIG_CIFS_SMB2/NFS_V4 模块. 此功能需要用户态程序 "/sbin/dns.resolve" 和配置文件 "/etc/request-key.conf" 的支持. 更多信息参见 "[Documentation/networking/dns_resolver.txt](https://www.kernel.org/doc/Documentation/networking/dns_resolver.txt)"文档, 不确定的选"N".')]),t._v(" "),e("dt",[t._v("B.A.T.M.A.N. Advanced Meshing Protocol\nCONFIG_BATMAN_ADV")]),t._v(" "),e("dd",[t._v('B.A.T.M.A.N.(更好的移动无线网络方案) 是一种用于 multi-hop ad-hoc [mesh](http://baike.baidu.com/view/1215700.htm) 网络的路由协议. 它是一种去中心化分布式无线 Adhoc 模式, 特别适用于自然灾害等紧急情况下, 创建临时的无线网络. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Open vSwitch\nCONFIG_OPENVSWITCH")]),t._v(" "),e("dd",[t._v("[Open vSwitch](http://bengo.blog.51cto.com/4504843/791213/) 是一个多层虚拟交换标准. 此选项提供了内核级的高速转发功能 (需要配合用户态守护进程 ovs-vswitchd 来实现).")]),t._v(" "),e("dt",[t._v("Virtual Socket protocol\nCONFIG_VSOCKETS")]),t._v(" "),e("dd",[t._v("这是一个类似于 TCP/IP 的协议, 用于虚拟机之间以及虚拟机与宿主之间的通信. 开启此项后, 还需要从子项中选择适用于特定虚拟化技术的传输协议.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("VMware VMCI transport for Virtual Sockets\nCONFIG_VMWARE_VMCI_VSOCKETS")]),t._v(" "),e("dd",[t._v("适用于 VMware 虚拟化技术的 VMCI 传输协议支持.")])])]),t._v(" "),e("dt",[t._v("NETLINK: mmaped IO\nCONFIG_NETLINK_MMAP")]),t._v(" "),e("dd",[t._v('基于内存映射机制的 [netlink](http://zh.wikipedia.org/wiki/Netlink) IO 支持. 可以避免在用户空间与内存空间之间复制数据, 从而提升操作速度. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("NETLINK: socket monitoring interface\nCONFIG_NETLINK_DIAG")]),t._v(" "),e("dd",[t._v("NETLINK socket 监视接口.[ss](http://xikder.blog.51cto.com/1423200/869467) 这样的诊断工具需要它.")]),t._v(" "),e("dt",[t._v("MultiProtocol Label Switching\nCONFIG_MPLS")]),t._v(" "),e("dd",[t._v('[多协议标签交换](http://www.cisco.com/support/zh/105/mpls_faq_4649.shtml) ([MPLS](https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E6%A0%87%E7%AD%BE%E4%BA%A4%E6%8D%A2)) 是新一代的 IP 高速骨干网络交换标准. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("High-availability Seamless Redundancy (HSR)\nCONFIG_HSR")]),t._v(" "),e("dd",[t._v('以太网 HSR(高可用性无缝冗余)规范 (IEC 62439-3:2010) 支持. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Network priority cgroup\nCONFIG_NETPRIO_CGROUP\nCONFIG_CGROUP_NET_PRIO")]),t._v(" "),e("dd",[t._v("Cgroup 子系统支持: 基于每个网络接口为每个进程分配网络使用优先级. Docker 依赖于它.")]),t._v(" "),e("dt",[t._v("enable BPF Just In Time compiler\nCONFIG_BPF_JIT")]),t._v(" "),e("dd",[t._v('[BPF(Berkeley Packet Filter)](http://zh.wikipedia.org/wiki/BPF) 的过滤功能通常由一个解释器 (interpreter) 解释执行 BPF 虚拟机指令的方式工作. 开启此项, 内核在加载过滤指令后, 会将其编译为本地指令, 以加快执行速度. 网络嗅探程序 (libpcap/tcpdump) 可以从中受益. 注意: 需要 "echo 1 > /proc/sys/net/core/bpf_jit_enable" 之后才能生效.')]),t._v(" "),e("dt",[t._v("Network testing")]),t._v(" "),e("dd",[t._v("网络测试, 仅供调试使用")])])]),t._v(" "),e("dt",[t._v("Amateur Radio support\nCONFIG_HAMRADIO")]),t._v(" "),e("dd",[t._v("业余无线电支持. 供无线电爱好者进行自我训练 / 相互通讯 / 技术研究")]),t._v(" "),e("dt",[t._v("CAN bus subsystem support\nCONFIG_CAN")]),t._v(" "),e("dd",[t._v('[CAN(Controller Area Network)](http://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%99%A8%E5%8D%80%E5%9F%9F%E7%B6%B2%E8%B7%AF) 是一个低速串行通信协议. 被广泛地应用于工业自动化 / 船舶 / 医疗设备 / 工业设备等嵌入式领域. 更多信息参见 "[Documentation/networking/can.txt](https://www.kernel.org/doc/Documentation/networking/can.txt)" 文件.')]),t._v(" "),e("dt",[t._v("IrDA (infrared) subsystem support\nCONFIG_IRDA")]),t._v(" "),e("dd",[t._v("[红外线通讯技术](http://zh.wikipedia.org/wiki/%E7%BA%A2%E5%A4%96%E9%80%9A%E8%AE%AF%E6%8A%80%E6%9C%AF)支持, 主要用于嵌入式环境, 某些老旧的笔记本上也可能会有红外接口.")]),t._v(" "),e("dt",[t._v("Bluetooth subsystem support\nCONFIG_BT")]),t._v(" "),e("dd",[t._v("[蓝牙](http://www.cppblog.com/iuranus/archive/2008/12/14/69391.html)支持. 蓝牙目前已经基本取代红外线, 成为嵌入式设备 / 智能设备 / 笔记本的标配近距离 (小于 10 米) 通信设备. 在 Linux 上通常使用来自 [BlueZ](http://www.bluez.org/) 的 hciconfig 和 bluetoothd 工具操作蓝牙通信.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("RFCOMM protocol support\nCONFIG_BT_RFCOMM")]),t._v(" "),e("dd",[t._v("虚拟串口协议 ([RFCOMM](http://baike.baidu.com/view/493704.htm)) 是一个面向连接的流传输协议, 提供 [RS232](http://baike.baidu.com/view/112004.htm) 控制和状态信号, 从而模拟串口的功能. 它被用于支持拨号网络,[OBEX(Object Exchange)](http://blog.csdn.net/yangwenchao1983/article/details/4583140), 以及某些蓝牙程序 (例如文件传输).")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("RFCOMM TTY support\nCONFIG_BT_RFCOMM_TTY")]),t._v(" "),e("dd",[t._v("允许在 RFCOMM 通道上模拟 [TTY](http://baike.baidu.com/view/749979.htm) 终端")])])]),t._v(" "),e("dt",[t._v("BNEP protocol support\nCONFIG_BT_BNEP")]),t._v(" "),e("dd",[t._v("蓝牙网络封装协议 (Bluetooth Network Encapsulation Protocol) 可以在蓝牙上运行其他网络协议(TCP/IP). [Bluetooth PAN](http://windows.microsoft.com/zh-cn/windows7/what-is-a-bluetooth-personal-area-network-pan)(Personal Area Network) 需要它的支持.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Multicast filter support\nCONFIG_BT_BNEP_MC_FILTER")]),t._v(" "),e("dd",[t._v("组播支持")]),t._v(" "),e("dt",[t._v("Protocol filter support\nCONFIG_BT_BNEP_PROTO_FILTER")]),t._v(" "),e("dd",[t._v("协议过滤器支持")])])]),t._v(" "),e("dt",[t._v("CMTP protocol support\nCONFIG_BT_CMTP")]),t._v(" "),e("dd",[t._v('CMTP(CAPI 消息传输协议) 用于支持已在上世纪被淘汰的 ISDN 设备. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("HIDP protocol support\nCONFIG_BT_HIDP")]),t._v(" "),e("dd",[t._v("人机接口设备协议 (Human Interface Device Protocol) 用于支持各种人机接口设备(比如鼠标 / 键盘 / 耳机等).")]),t._v(" "),e("dt",[t._v("Bluetooth device drivers")]),t._v(" "),e("dd",[t._v("各种蓝牙设备驱动")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("HCI USB driver\nCONFIG_BT_HCIBTUSB")]),t._v(" "),e("dd",[t._v("使用 USB 接口的蓝牙设备支持")]),t._v(" "),e("dt",[t._v("HCI SDIO driver\nCONFIG_BT_HCIBTSDIO")]),t._v(" "),e("dd",[t._v("使用 [SDIO](http://zh.wikipedia.org/wiki/Secure_Digital#SDIO_.E4.BB.8B.E7.BB.8D) 接口的蓝牙设备支持")]),t._v(" "),e("dt",[t._v("HCI UART driver\nCONFIG_BT_HCIUART")]),t._v(" "),e("dd",[t._v("使用串口的蓝牙设备支持. 此外, 基于 [UART](http://baike.baidu.com/view/245027.htm) 的蓝牙 [PCMCIA](http://baike.baidu.com/view/591980.htm) 和 [CF](http://baike.baidu.com/view/3832.htm) 设备也需要此模块的支持.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("UART (H4) protocol support\nCONFIG_BT_HCIUART_H4")]),t._v(" "),e("dd",[t._v("大多数使用 UART 接口的蓝牙设备 (包括 PCMCIA 和 CF 卡) 都使用这个协议.")]),t._v(" "),e("dt",[t._v("BCSP protocol support\nCONFIG_BT_HCIUART_BCSP")]),t._v(" "),e("dd",[t._v("基于 CSR(Cambridge Silicon Radio)公司的 BlueCore 系列芯片的蓝牙设备 (包括 PCMCIA 和 CF 卡) 支持")]),t._v(" "),e("dt",[t._v("Atheros AR300x serial support\nCONFIG_BT_HCIUART_ATH3K")]),t._v(" "),e("dd",[t._v("基于 Atheros AR300x 系列芯片的蓝牙设备支持")]),t._v(" "),e("dt",[t._v("HCILL protocol support\nCONFIG_BT_HCIUART_LL")]),t._v(" "),e("dd",[t._v("基于 Texas Instruments 公司的 BRF 芯片的蓝牙设备支持")]),t._v(" "),e("dt",[t._v("Three-wire UART (H5) protocol support\nCONFIG_BT_HCIUART_3WIRE")]),t._v(" "),e("dd",[t._v("Three-wire UART (H5) 协议假定 UART 通信可能存在各种错误, 从而使得 CTS/RTS 引脚线变得可有可无. 看不懂就可以不选.")])])]),t._v(" "),e("dt",[t._v("HCI VHCI (Virtual HCI device) driver\nCONFIG_BT_HCIVHCI")]),t._v(" "),e("dd",[t._v("模拟蓝牙设备支持. 主要用于开发")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{大多数蓝牙设备并不需要特定的独立驱动, 此处省略的独立驱动仅是为了驱动那些不严格遵守蓝牙规范的芯片}")])])])])]),t._v(" "),e("dt",[t._v("RxRPC session sockets\nCONFIG_AF_RXRPC")]),t._v(" "),e("dd",[t._v('RxRPC 会话套接字支持 (仅包括传输部分, 不含表示部分).CONFIG_AFS_FS 依赖于它. 不确定的选 "N". 详情参见 "[Documentation/networking/rxrpc.txt](https://www.kernel.org/doc/Documentation/networking/rxrpc.txt)" 文档.')]),t._v(" "),e("dt",[t._v("Wireless\nCONFIG_WIRELESS")]),t._v(" "),e("dd",[t._v("无线网络支持.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("cfg80211 - wireless configuration API\nCONFIG_CFG80211")]),t._v(" "),e("dd",[t._v('[cfg80211](http://wireless.kernel.org/en/developers/Documentation/cfg80211) 是 [Linux 无线局域网](http://www.crifan.com/files/doc/docbook/linux_wireless/release/htmls/ch05_linux_wireless_lan_80211.html) ([802.11](http://zh.wikipedia.org/zh/IEEE_802.11)) 配置接口, 是使用 WiFi 的前提. 注意:"[WiFi](http://baike.baidu.com/view/3941.htm)" 是一个无线网路通信技术的品牌, 由 WiFi 联盟所持有. 目的是改善基于 IEEE 802.11 标准的无线网路产品之间的互通性. 现时一般人会把 WiFi 及 IEEE 802.11 混为一谈, 甚至把 WiFi 等同于无线网路 (WiFi 只是无线网络的一种).')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("nl80211 testmode command\nCONFIG_NL80211_TESTMODE")]),t._v(" "),e("dd",[t._v("仅供调试和特殊目的使用.")]),t._v(" "),e("dt",[t._v("enable developer warnings\nCONFIG_CFG80211_DEVELOPER_WARNINGS")]),t._v(" "),e("dd",[t._v("仅供调试开发使用")]),t._v(" "),e("dt",[t._v("cfg80211 regulatory debugging\nCONFIG_CFG80211_REG_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试开发使用")]),t._v(" "),e("dt",[t._v("cfg80211 certification onus\nCONFIG_CFG80211_CERTIFICATION_ONUS")]),t._v(" "),e("dd",[t._v('仅在你确实明白此项含义的情况下, 才考虑选 "Y", 否则请选 "N".')]),t._v(" "),e("dt",[t._v("enable powersave by default\nCONFIG_CFG80211_DEFAULT_PS")]),t._v(" "),e("dd",[t._v('若开启此项则表示默认开启省电模式 (也就是默认 "Soft blocked: yes"). 关闭此项则表示默认使用 BIOS 中的状态 (通常是上一次关机时的状态). 详情参见 "[Documentation/power/pm_qos_interface.txt](https://www.kernel.org/doc/Documentation/power/pm_qos_interface.txt)" 文档.')]),t._v(" "),e("dt",[t._v("cfg80211 DebugFS entries\nCONFIG_CFG80211_DEBUGFS")]),t._v(" "),e("dd",[t._v("仅供调试")]),t._v(" "),e("dt",[t._v("use statically compiled regulatory rules database\nCONFIG_CFG80211_INTERNAL_REGDB")]),t._v(" "),e("dd",[t._v('由于绝大多数发行版都含有 [CRDA](http://wireless.kernel.org/en/developers/Regulatory/CRDA) 软件包, 所以绝大多数人应该选 "N". 如果你确实需要选 "Y", 那么请认真阅读 "net/wireless/db.txt" 文件.')]),t._v(" "),e("dt",[t._v("cfg80211 wireless extensions compatibility\nCONFIG_CFG80211_WEXT")]),t._v(" "),e("dd",[t._v("为那些老旧的用户空间程序提供兼容性, 建议关闭.")])])]),t._v(" "),e("dt",[t._v("lib80211 debugging messages\nCONFIG_LIB80211_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试")]),t._v(" "),e("dt",[t._v("Generic IEEE 802.11 Networking Stack (mac80211)\nCONFIG_MAC80211")]),t._v(" "),e("dd",[t._v('独立于硬件的通用 [IEEE 802.11](http://wenku.baidu.com/view/7df7eb7f27284b73f24250e5.html) 协议栈模块 (mac80211). 它是驱动开发者用来编写 softMAC 无线设备驱动的框架, softMAC 设备允许用软件实现帧的管理 (包括解析和产生 80211 无线帧), 从而让系统能更好的控制硬件, 现在大多数的无线网卡都是 softMAC 设备. 不确定的选 "Y".')]),t._v(" "),e("dt",[t._v("PID controller based rate control algorithm\nCONFIG_MAC80211_RC_PID")]),t._v(" "),e("dd",[t._v('基于[比例 - 积分 - 微分控制器](http://baike.baidu.com/view/104644.htm) ([PID controller](http://wireless.kernel.org/en/developers/Documentation/mac80211/RateControl/PID))的发送速率 (TX rate) 控制算法. 用于 CONFIG_MAC80211 模块. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Minstrel\nCONFIG_MAC80211_RC_MINSTREL")]),t._v(" "),e("dd",[t._v('[minstrel](http://wireless.kernel.org/en/developers/Documentation/mac80211/RateControl/minstrel) 发送速率 (TX rate) 控制算法. 用于 CONFIG_MAC80211 模块. 这是首选的算法, 不确定的选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Minstrel 802.11n support\nCONFIG_MAC80211_RC_MINSTREL_HT")]),t._v(" "),e("dd",[t._v('[minstrel_ht](http://lwn.net/Articles/376765/) 发送速率 (TX rate) 控制算法. 适用于 [802.11n](http://baike.baidu.com/view/32843.htm) 规范. 不确定的选 "Y".')])])]),t._v(" "),e("dt",[t._v("Default rate control algorithm")]),t._v(" "),e("dd",[t._v('默认发送速率 (TX rate) 控制算法. 相当于 mac80211 模块 "ieee80211_default_rc_algo" 参数的值. 建议选择 "Minstrel" 算法.')]),t._v(" "),e("dt",[t._v("Enable mac80211 mesh networking (pre-802.11s) support\nCONFIG_MAC80211_MESH")]),t._v(" "),e("dd",[t._v('[802.11s](http://baike.baidu.com/view/1720501.htm) 草案是无线网状网络 (Mesh Networking) 的延伸与增补标准 (amendment). 它扩展了 IEEE 802.11 MAC(介质访问控制) 标准, 定义了利用自我组态的多点跳跃拓朴(multi-hop topologies), 进行无线感知(radio-aware metrics), 以支援广播 / 组播 / 单播传送网络封包的架构与协定. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Enable LED triggers\nCONFIG_MAC80211_LEDS")]),t._v(" "),e("dd",[t._v("允许在接受 / 发送数据时触发无线网卡的 LED 灯闪烁.")]),t._v(" "),e("dt",[t._v("Export mac80211 internals in DebugFS\nCONFIG_MAC80211_DEBUGFS")]),t._v(" "),e("dd",[t._v("在 DebugFS 中显示 mac80211 模块内部状态的扩展信息, 仅用于调试目的.")]),t._v(" "),e("dt",[t._v("Trace all mac80211 debug messages\nCONFIG_MAC80211_MESSAGE_TRACING")]),t._v(" "),e("dd",[t._v("跟踪所有 mac80211 模块的调试信息, 仅用于调试目的.")]),t._v(" "),e("dt",[t._v("Select mac80211 debugging features\nCONFIG_MAC80211_DEBUG_MENU")]),t._v(" "),e("dd",[t._v("仅供调试")])])]),t._v(" "),e("dt",[t._v("WiMAX Wireless Broadband support\nCONFIG_WIMAX")]),t._v(" "),e("dd",[t._v("[WiMAX](http://zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E4%BA%92%E9%80%9A%E5%BE%AE%E6%B3%A2%E5%AD%98%E5%8F%96)(IEEE 802.16) 协议支持. 随着 2010 年英特尔放弃 WiMAX 以及 LTE 在 4G 市场成了唯一的主流标准, WiMAX 的电信运营商也逐渐向 LTE 转移, WiMAX 论坛也于 2012 年将 TD-LTE 纳入 WiMAX2.1 规范, 一些 WiMAX 运营商也开始将设备升级为 TD-LTE.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("WiMAX debug level\nCONFIG_WIMAX_DEBUG_LEVEL")]),t._v(" "),e("dd",[t._v('设置允许使用的最大调试信息详细等级, 推荐使用默认值 "8", 设为 "0" 表示允许使用所有调试信息. 运行时默认禁止使用调试信息, 但可通过 sysfs 文件系统中的 debug-levels 文件开启调试信息.')])])]),t._v(" "),e("dt",[t._v("RF switch subsystem support\nCONFIG_RFKILL")]),t._v(" "),e("dd",[t._v('为了节约电力, 很多无线网卡和蓝牙设备都有内置的射频开关 ([RF switche](http://blog.csdn.net/angelbosj/article/details/7247651)) 用于开启和关闭设备 (通过 [rfkill](https://access.redhat.com/site/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html/Power_Management_Guide/RFKill.html) 命令). 建议选 "Y". 更多详情参见 "[Documentation/rfkill.txt](https://www.kernel.org/doc/Documentation/rfkill.txt)" 文档')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("RF switch input support\nCONFIG_RFKILL_INPUT")]),t._v(" "),e("dd",[t._v("这是个反对使用的特性, 一般情况下建议关闭. 若关闭此项导致某些笔记本的无线网卡开关按钮失效, 可以考虑开启.")]),t._v(" "),e("dt",[t._v("Generic rfkill regulator driver\nCONFIG_RFKILL_REGULATOR")]),t._v(" "),e("dd",[t._v('通用射频开关驱动, 其射频开关连接在电压调节器 (voltage regulator) 上. 依赖于 CONFIG_REGULATOR 框架. 不确定的选 "N" 或 "M"')]),t._v(" "),e("dt",[t._v("GPIO RFKILL driver\nCONFIG_RFKILL_GPIO")]),t._v(" "),e("dd",[t._v("通用 GPIO 射频开关驱动. 仅用于嵌入式环境, 其射频开关连接在 [GPIO](http://baike.baidu.com/view/980829.htm) 总线上, 比如 NVIDIA 的 [Tegra](http://baike.baidu.com/view/1660634.htm) 和三星的 [Exynos 4](http://baike.baidu.com/view/5821967.htm) 智能手机 SoC 芯片.")])])]),t._v(" "),e("dt",[t._v("Plan 9 Resource Sharing Support (9P2000)\nCONFIG_NET_9P")]),t._v(" "),e("dd",[t._v("实验性的支持 [Plan 9](http://zh.wikipedia.org/wiki/%E8%B2%9D%E7%88%BE%E5%AF%A6%E9%A9%97%E5%AE%A4%E4%B9%9D%E8%99%9F%E8%A8%88%E7%95%AB) 的 [9P2000](http://zh.wikipedia.org/wiki/9P) 协议.")]),t._v(" "),e("dt",[t._v("CAIF support\nCONFIG_CAIF")]),t._v(" "),e("dd",[t._v('除非你为 Android/MeeGo 系统编译内核, 并且需要使用 PF_CAIF 类型的 socket, 否则请选 "N".')]),t._v(" "),e("dt",[t._v("Ceph core library\nCONFIG_CEPH_LIB")]),t._v(" "),e("dd",[t._v('仅在你需要使用 [Ceph](http://www.ibm.com/developerworks/cn/linux/l-ceph/) 分布式文件系统, 或者 [rados](http://www.alidata.org/archives/1589) 块设备 (rbd) 时选 "Y". 否则应选 "N".')]),t._v(" "),e("dt",[t._v("NFC subsystem support\nCONFIG_NFC")]),t._v(" "),e("dd",[t._v("[NFC](http://zh.wikipedia.org/wiki/%E8%BF%91%E5%A0%B4%E9%80%9A%E8%A8%8A)([近场通信](http://baike.baidu.com/view/917495.htm)) 子系统. 这些设备主要用于智能手机之类的嵌入式领域.")]),t._v(" "),e("dt",[t._v("Network light weight tunnels\nCONFIG_LWTUNNEL")]),t._v(" "),e("dd",[t._v('为 [MPLS](https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%8D%8F%E8%AE%AE%E6%A0%87%E7%AD%BE%E4%BA%A4%E6%8D%A2)([多协议标签交换](http://www.cisco.com/support/zh/105/mpls_faq_4649.shtml)) 之类的轻量级隧道提供基础结构支持. 不确定的选 "N".')])]),t._v(" "),e("h2",{attrs:{id:"device-drivers"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#device-drivers"}},[t._v("#")]),t._v(" Device Drivers")]),t._v(" "),e("p",[t._v("设备驱动程序")]),t._v(" "),e("dl",[e("dt",[t._v("Generic Driver Options")]),t._v(" "),e("dd",[t._v('驱动程序通用选项.[提示][Linux Kernel Driver DataBase](https://cateee.net/lkddb/web-lkddb/) 网站是搜索驱动程序与硬件型号对应关系的绝佳网站. 如果你不知道某个驱动 (例如 "CONFIG_INTEL_IOATDMA") 究竟对应着哪些型号的硬件, 那么可以直接根据该驱动选项的首字母 (本例是 "I") 进入对应的索引页去查找到该驱动的详情页面 (本例是 "https://cateee.net/lkddb/web-lkddb/INTEL_IOATDMA.html").[提示] 可以使用 "lspci -nn" 与 "lsusb" 命令查看本机所有 PCI/USB 设备的 "vendor id" 与 "device id" 及文本名称. 也可以根据已知的 id 到 [pci.ids](http://pci-ids.ucw.cz/v2.2/pci.ids) 与 [usb.ids](http://www.linux-usb.org/usb.ids) 数据库中搜索设备的名称.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Support for uevent helper\nCONFIG_UEVENT_HELPER")]),t._v(" "),e("dd",[t._v('早年的内核 (切换到基于 netlink 机制之前), 在发生 [uevent](http://blog.chinaunix.net/uid-22590270-id-3304271.html) 事件 (通常是热插拔) 时, 需要调用用户空间程序(通常是 "/sbin/hotplug"), 以帮助完成 uevent 事件的处理. 此选项就是用于开启此功能. 由于目前的发行版都已不再需要此帮助程序, 所以请选 "N". 此外, 如果你使用了 systemd 或 udev 则必须选 "N".')]),t._v(" "),e("dt",[t._v("path to uevent helper\nCONFIG_UEVENT_HELPER_PATH")]),t._v(" "),e("dd",[t._v('早年的内核 (切换到基于 netlink 机制之前), 在发生 [uevent](http://blog.chinaunix.net/uid-22590270-id-3304271.html) 事件 (通常是热插拔) 时, 需要调用用户空间程序(通常是 "/sbin/hotplug"), 以帮助完成 uevent 事件的处理. 此选项就是用于设定这个帮助程序的路径. 由于目前的发行版都已不再需要此帮助程序, 所以请保持空白. 此外, 如果你使用了 systemd 或 udev 则必须保持空白.')]),t._v(" "),e("dt",[t._v("Maintain a devtmpfs filesystem to mount at /dev\nCONFIG_DEVTMPFS")]),t._v(" "),e("dd",[t._v('devtmpfs 是一种基于 CONFIG_TMPFS 的文件系统 (与 proc 和 sys 有几分相似). 在系统启动过程中, 随着各个设备的初始化完成, 内核将会自动在 devtmpfs 中创建相应的设备节点(使用默认的文件名和权限) 并赋予正确的主次设备号. 更进一步, 在系统运行过程中, 随着各种设备插入和拔除, 内核也同样会自动在 devtmpfs 中创建和删除的相应的设备节点 (使用默认的文件名和权限) 并赋予正确的主次设备号. 如果将 devtmpfs 挂载到 "/dev" 目录(通常是系统启动脚本), 那么便拥有了一个全自动且全功能的 "/dev" 目录, 而且用户空间程序(通常是 [udevd](http://www.ibm.com/developerworks/cn/linux/l-cn-udev/)) 还可以对其中的内容进行各种修改 (增删节点, 改变权限, 创建符号链接). 目前的发行版和各种嵌入式系统基本都依赖于此, 除非你知道自己在做什么, 否则请选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Automount devtmpfs at /dev, after the kernel mounted the rootfs\nCONFIG_DEVTMPFS_MOUNT")]),t._v(" "),e("dd",[t._v('在内核挂载根文件系统的同时, 立即自动将 devtmpfs 挂载到 "/dev" 目录. 因为此时 init 进程都还尚未启动, 所以这就确保在进入用户空间之前, 所有设备文件就都已经准备完毕. 开启此选项相当于设置内核引导参数 "devtmpfs.mount=1", 关闭此选项相当于设置内核引导参数 "devtmpfs.mount=0". 开启此项后, 你就可以放心的使用 "init=/bin/sh" 直接进入救援模式, 而不必担心 "/dev" 目录空无一物. 注意: 此选项并不影响基于 initramfs 的启动, 此种情况下, devtmpfs 必须被手动挂载. 所以, 如果你的系统使用 initrd 或者有专门的启动脚本用于挂载 "/dev" 目录 (大多数发行版都有这样的脚本), 或者你看了前面的解释, 还是不确定, 那就选 "N". 对于实在想要使用 "init=/bin/sh" 直接进入救援模式的人来说, 还是使用 "init=/bin/sh devtmpfs.mount=1" 吧!')])])]),t._v(" "),e("dt",[t._v("Select only drivers that don't need compile-time external firmware\nCONFIG_STANDALONE")]),t._v(" "),e("dd",[t._v('只显示那些编译时不需要额外固件支持的驱动程序, 除非你有某些怪异硬件, 否则请选 "Y".')]),t._v(" "),e("dt",[t._v("Prevent firmware from being built\nCONFIG_PREVENT_FIRMWARE_BUILD")]),t._v(" "),e("dd",[t._v('不编译固件 (firmware). 固件一般是随硬件的驱动程序提供的, 仅在更新固件的时候才需要重新编译. 建议选 "Y".')]),t._v(" "),e("dt",[t._v("Userspace firmware loading support\nCONFIG_FW_LOADER")]),t._v(" "),e("dd",[t._v("用户空间固件加载支持. 如果内核自带的模块需要它, 它将会被自动选中. 但某些内核树之外的模块也可能需要它, 这时候就需要你根据实际情况手动开启了.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Include in-kernel firmware blobs in kernel binary\nCONFIG_FIRMWARE_IN_KERNEL")]),t._v(" "),e("dd",[t._v('内核源码树中包含了许多驱动程序需要的二进制固件 (blob), 推荐的方法是通过 "make firmware_install" 将 "firmware" 目录中所需的固件复制到系统的 "/lib/firmware/" 目录中, 然后由用户空间帮助程序在需要的时候进行加载. 开启此项后, 将会把所需的 "blob" 直接编译进内核, 这样就可以无需用户空间程序的帮助, 而直接使用这些固件了 (例如: 当根文件系统依赖于此类固件, 而你又不想使用 initrd 的时候). 每个需要此类二进制固件的驱动程序, 都会有一个 "Include firmware for xxx device" 的选项, 如果此处选 "Y", 那么这些选项都将被隐藏. 建议选 "N".')]),t._v(" "),e("dt",[t._v("External firmware blobs to build into the kernel binary\nCONFIG_EXTRA_FIRMWARE")]),t._v(" "),e("dd",[t._v('指定要额外编译进内核的二进制固件 (blob). 此选项的值是一个空格分隔的固件文件名字符串, 这些文件必须位于 CONFIG_EXTRA_FIRMWARE_DIR 目录中 (其默认值是内核源码树下的 "firmware" 目录).')]),t._v(" "),e("dt",[t._v("Firmware blobs root directory\nCONFIG_EXTRA_FIRMWARE_DIR")]),t._v(" "),e("dd",[t._v('指定 CONFIG_EXTRA_FIRMWARE 中列出的文件位于哪个目录. 默认值是当前内核源码树下的 "firmware" 目录. 若有需要, 你也可以修改成其他目录 (例如 "/lib/firmware/").')])])]),t._v(" "),e("dt",[t._v("Fallback user-helper invocation for firmware loading\nCONFIG_FW_LOADER_USER_HELPER")]),t._v(" "),e("dd",[t._v('在内核自己直接加载固件失败后, 作为补救措施, 调用用户空间帮助程序 (通常是 udev) 再次尝试加载. 通常这个动作是不必要的, 因此应该选 "N", 如果你使用了 udev 或 systemd, 则必须选 "N". 仅在某些特殊的固件位于非标准位置时, 才需要选 "Y".')]),t._v(" "),e("dt",[t._v("Allow device coredump\nCONFIG_ALLOW_DEV_COREDUMP")]),t._v(" "),e("dd",[t._v("为驱动程序开启 coredump 机制, 仅供调试.")]),t._v(" "),e("dt",[t._v("Driver Core verbose debug messages\nCONFIG_DEBUG_DRIVER")]),t._v(" "),e("dd",[t._v("让驱动程序核心在系统日志中产生冗长的调试信息, 仅供调试")]),t._v(" "),e("dt",[t._v("Managed device resources verbose debug messages\nCONFIG_DEBUG_DEVRES")]),t._v(" "),e("dd",[t._v('为内核添加一个 "devres.log" 引导参数. 当被设为非零值时, 将会打印出设备资源管理驱动 (devres) 的调试信息. 仅供调试使用.')])])]),t._v(" "),e("dt",[t._v("Bus devices")]),t._v(" "),e("dd",[t._v("总线设备. 此类设备仅出现在 ARM 平台.")]),t._v(" "),e("dt",[t._v("Connector - unified userspace <-> kernelspace linker\nCONFIG_CONNECTOR")]),t._v(" "),e("dd",[t._v('[统一的用户空间和内核空间连接器](http://www.ibm.com/developerworks/cn/linux/l-connector/index.html), 工作在 netlink socket 协议的顶层. 连接器是非常便利的用户态与内核态的通信方式, 这些驱动使内核知道当进程 fork 并使用 proc 连接器更改 UID/GID/SID(会话 ID). 内核需要知道什么时候进程 fork(CPU 中运行多个任务) 并执行, 否则, 内核可能会低效管理资源. 内核有几个连接器应用实例: CONFIG_HYPERV_UTILS,CONFIG_FB_UVESA,CONFIG_W1_CON,CONFIG_DM_LOG_USERSPACE. 另外还有一个[给 Gentoo 装上启动画面](http://hily.me/blog/2008/10/gentoo_splash/)的例子. 建议选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Report process events to userspace\nCONFIG_PROC_EVENTS")]),t._v(" "),e("dd",[t._v('提供一个向用户空间报告进程事件 (fork,exec,id 变化(uid,gid,suid)) 的连接器. 建议选 "Y".')])])]),t._v(" "),e("dt",[t._v("Memory Technology Device (MTD) support\nCONFIG_MTD")]),t._v(" "),e("dd",[t._v('[MTD](http://www.linux-mtd.infradead.org/faq/general.html) 子系统是一个[闪存转换层](http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%96%83%E8%A8%98%E6%86%B6%E9%AB%94%E8%BD%89%E6%8F%9B%E5%B1%A4). 其主要目的是提供一个介于闪存硬件驱动程序与高级应用程序之间的抽象层, 以简化闪存设备的驱动. 注意: MTD 常用于嵌入式系统, 而我们常见的 U 盘 / MMC 卡 / SD 卡 / CF 卡等移动存储设备以及固态硬盘 (SSD), 虽然也叫 "flash", 但它们并不是使用 MTD 技术的存储器. 仅在你需要使用主设备号为 31 的 MTD 块设备(/dev/romX,/dev/rromX,/dev/flashX,/dev/rflashX), 或者主设备号为 90 的 MTD 字符设备(/dev/mtdX,/dev/mtdrX) 时选 "Y", 否则选 "N".')]),t._v(" "),e("dt",[t._v("Device Tree and Open Firmware support\nCONFIG_OF")]),t._v(" "),e("dd",[t._v('[Device Tree](http://www.wowotech.net/device_model/why-dt.html) 基础架构与 [Open Firmware](https://en.wikipedia.org/wiki/Open_Firmware) 支持. 主要用于嵌入式环境. 不确定的选 "N". 内核中若有其它选项依赖于它, 则会自动选中此项.')]),t._v(" "),e("dt",[t._v("Parallel port support\nCONFIG_PARPORT")]),t._v(" "),e("dd",[t._v("25 针并口 ([LPT 接口](http://baike.baidu.com/view/79689.htm)) 支持. 古董级的打印机或扫描仪可能使用这种接口. 目前已被淘汰.")]),t._v(" "),e("dt",[t._v("Plug and Play support\nCONFIG_PNP")]),t._v(" "),e("dd",[t._v('[即插即用](http://baike.baidu.com/view/33701.htm) (PnP) 支持. 选 "Y" 表示让 Linux 为 PnP 设备分配中断和 I/O 端口 (需要在 BIOS 中开启 "PnP OS"), 选 "N" 则表示让 BIOS 来分配 (需要在 BIOS 中关闭 "PnP OS"). 建议选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("PNP debugging messages\nCONFIG_PNP_DEBUG_MESSAGES")]),t._v(" "),e("dd",[t._v('允许使用 "pnp.debug" 内核参数在系统启动过程中输出 PnP 设备的调试信息, 建议选 "N".')])])]),t._v(" "),e("dt",[t._v("Block devices\nCONFIG_BLK_DEV")]),t._v(" "),e("dd",[t._v('块设备, 建议选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Null test block driver\nCONFIG_BLK_DEV_NULL_BLK")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Normal floppy disk support\nCONFIG_BLK_DEV_FD")]),t._v(" "),e("dd",[t._v("通用[软驱](http://baike.baidu.com/view/9006.htm)支持. 已被时代抛弃的设备")]),t._v(" "),e("dt",[t._v("Parallel port IDE device support\nCONFIG_PARIDE")]),t._v(" "),e("dd",[t._v("通过并口与计算机连接的 IDE 设备, 比如某些老旧的外接光驱或硬盘之类. 此类设备早就绝种了")]),t._v(" "),e("dt",[t._v("Block Device Driver for Micron PCIe SSDs\nCONFIG_BLK_DEV_PCIESSD_MTIP32XX")]),t._v(" "),e("dd",[t._v("[Micron P320/P325/P420/P425 系列固态硬盘](http://www.expreview.com/25252.html)支持")]),t._v(" "),e("dt",[t._v("Compressed RAM block device support\nCONFIG_ZRAM")]),t._v(" "),e("dd",[t._v("[zram](http://wiki.gentoo.org/wiki/Zram) 是一种基于压缩内存的虚拟块设备, 它允许你创建 \"/dev/zramN\" 块设备文件, 并将它当作普通的磁盘一样使用. 它完全位于物理内存中, 并被实时压缩与解压以节约物理内存的用量, 所有对 \"/dev/zramN\" 的读写实质上都是对内存的读写, 从而可以获得比一般的磁盘快的多的 IO 速度. 常将它用做'/tmp'分区或作为 swap 分区挂载. 你可以把它看作是 CONFIG_BLK_DEV_RAM 的升级版. 具体用法可以参考内核文档'[Documentation/blockdev/zram.txt](https://www.kernel.org/doc/Documentation/blockdev/zram.txt)'.")]),t._v(" "),e("dt",[t._v("Compaq SMART2 support\nCONFIG_BLK_CPQ_DA")]),t._v(" "),e("dd",[t._v("基于 Compaq SMART2 控制器的磁盘阵列卡")]),t._v(" "),e("dt",[t._v("Compaq Smart Array 5xxx support\nCONFIG_BLK_CPQ_CISS_DA")]),t._v(" "),e("dd",[t._v("基于 Compaq Smart 控制器的磁盘阵列卡")]),t._v(" "),e("dt",[t._v("SCSI tape drive support for Smart Array 5xxx\nCONFIG_CISS_SCSI_TAPE")]),t._v(" "),e("dd",[t._v("在基于 Compaq Smart 控制器的磁盘阵列卡上使用的磁带机")]),t._v(" "),e("dt",[t._v("Mylex DAC960/DAC1100 PCI RAID Controller support\nCONFIG_BLK_DEV_DAC960")]),t._v(" "),e("dd",[t._v("Mylex DAC960, AcceleRAID, eXtremeRAID PCI RAID 控制器. 很古董的设备了.")]),t._v(" "),e("dt",[t._v("Micro Memory MM5415 Battery Backed RAM support\nCONFIG_BLK_DEV_UMEM")]),t._v(" "),e("dd",[t._v("一种使用电池做后备电源的内存, 但被用作块设备, 可以像硬盘一样被分区")]),t._v(" "),e("dt",[t._v("Loopback device support\nCONFIG_BLK_DEV_LOOP")]),t._v(" "),e("dd",[t._v('loop 是指拿文件来模拟块设备 (/dev/loopX), 比如可以将一个 iso9660 镜像文件当成文件系统来挂载. 建议选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Number of loop devices to pre-create at init time\nCONFIG_BLK_DEV_LOOP_MIN_COUNT")]),t._v(" "),e("dd",[t._v('系统预先初始化的 loop 设备个数. 此值可以通过内核引导参数 "loop.max_loop" 修改. 如果你使用 [util-linux](https://www.kernel.org/pub/linux/utils/util-linux/)-2.21 以上版本, 建议设为 "0"(loop 设备将通过 / dev/loop-control 动态创建), 否则保持默认值即可.')]),t._v(" "),e("dt",[t._v("Cryptoloop Support\nCONFIG_BLK_DEV_CRYPTOLOOP")]),t._v(" "),e("dd",[t._v('使用系统提供的 CryptoAPI 对 loop 设备加密. 注意: 因为不能在 Cryptoloop 上创建日志型文件系统 (CONFIG_DM_CRYPT 模块可以), 所以 Cryptoloop 已经逐渐淡出了. 建议选 "N".')])])]),t._v(" "),e("dt",[t._v("DRBD Distributed Replicated Block Device support\nCONFIG_BLK_DEV_DRBD")]),t._v(" "),e("dd",[t._v('[DRBD(Distributed Replicated Block Device)](http://www.ibm.com/developerworks/cn/linux/l-drbd/) 是一种分布式储存系统.[DBRD](http://www.drbd.org/) 处于文件系统之下, 比文件系统更加靠近操作系统内核及 IO 栈. DRBD 类似 RAID1 磁盘阵列, 只不过 RAID1 是在同一台电脑内, 而 DRBD 是透过网络. 注意: 为了进行连接认证, 你还需要选中 CONFIG_CRYPTO_HMAC 以及相应的哈希算法. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("DRBD fault injection\nCONFIG_DRBD_FAULT_INJECTION")]),t._v(" "),e("dd",[t._v("模拟 IO 错误, 以用于测试 DRBD 的行为. 主要用于调试目的")])])]),t._v(" "),e("dt",[t._v("Network block device support\nCONFIG_BLK_DEV_NBD")]),t._v(" "),e("dd",[t._v('让你的电脑成为网络块设备的客户端, 也就是可以挂载远程服务器通过 TCP/IP 网络提供的块设备 (/dev/ndX). 提示: 这与 NFS 或 Coda 没有任何关系. 更多详情参见 "[Documentation/blockdev/nbd.txt](https://www.kernel.org/doc/Documentation/blockdev/nbd.txt)". 不确定的选"N".')]),t._v(" "),e("dt",[t._v("OSD object-as-blkdev support\nCONFIG_BLK_DEV_OSD")]),t._v(" "),e("dd",[t._v('允许将一个单独的 [SCSI OSD(Object-Based Storage Devices)](http://www.51cto.com/art/200608/30308.htm) 对象当成普通的块设备来使用. 举例来说, 你可以在 OSD 设备上创建一个 2G 大小的对象, 然后通过本模块将其模拟成一个 2G 大小的块设备使用. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("STEC S1120 Block Driver\nCONFIG_BLK_DEV_SKD")]),t._v(" "),e("dd",[t._v("STEC 公司的 S1120 PCIe SSD")]),t._v(" "),e("dt",[t._v("Promise SATA SX8 support\nCONFIG_BLK_DEV_SX8")]),t._v(" "),e("dd",[t._v("基于 Promise 公司的 SATA SX8 控制器的 RAID 卡")]),t._v(" "),e("dt",[t._v("RAM block device support\nCONFIG_BLK_DEV_RAM")]),t._v(" "),e("dd",[t._v('内存中的虚拟磁盘, 大小固定. 详情参阅 "[Documentation/blockdev/ramdisk.txt](https://www.kernel.org/doc/Documentation/blockdev/ramdisk.txt)". 由于其功能比 CONFIG_TMPFS 和 CONFIG_ZRAM 弱许多, 使用上也不方便, 所以除非你有明确的理由, 否则应该选"N", 并转而使用 CONFIG_TMPFS 或 CONFIG_ZRAM.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Default number of RAM disks\nCONFIG_BLK_DEV_RAM_COUNT")]),t._v(" "),e("dd",[t._v("默认 RAM disk 的数量. 请保持默认值, 除非你知道自己在做什么.")]),t._v(" "),e("dt",[t._v("Default RAM disk size (kbytes)\nCONFIG_BLK_DEV_RAM_SIZE")]),t._v(" "),e("dd",[t._v("默认 RAM disk 的大小. 请保持默认值, 除非你知道自己在做什么.")]),t._v(" "),e("dt",[t._v("Support XIP filesystems on RAM block device\nCONFIG_BLK_DEV_XIP")]),t._v(" "),e("dd",[t._v("XIP(eXecute In Place) 支持 (指应用程序可以直接在 flash 闪存内运行, 不必再把代码读到系统 RAM 中). 一般用于嵌入式设备.")])])]),t._v(" "),e("dt",[t._v("Packet writing on CD/DVD media\nCONFIG_CDROM_PKTCDVD")]),t._v(" "),e("dd",[t._v('CD/DVD 刻录机支持. 详情参见 "[Documentation/cdrom/packet-writing.txt](https://www.kernel.org/doc/Documentation/cdrom/packet-writing.txt)" 文档')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Free buffers for data gathering\nCONFIG_CDROM_PKTCDVD_BUFFERS")]),t._v(" "),e("dd",[t._v("用于收集写入数据的缓冲区个数 (每个占用 64Kb 内存), 缓冲区越多性能越好.")]),t._v(" "),e("dt",[t._v("Enable write caching\nCONFIG_CDROM_PKTCDVD_WCACHE")]),t._v(" "),e("dd",[t._v("为 CD-R/W 设备启用写入缓冲, 目前这是一个比较危险的选项. 建议关闭.")])])]),t._v(" "),e("dt",[t._v("ATA over Ethernet support\nCONFIG_ATA_OVER_ETH")]),t._v(" "),e("dd",[t._v("以太网 ATA 设备 ([ATA over Ethernet](http://zh.wikipedia.org/wiki/ATA_over_Ethernet)) 支持.")]),t._v(" "),e("dt",[t._v("Xen virtual block device support\nCONFIG_XEN_BLKDEV_FRONTEND")]),t._v(" "),e("dd",[t._v("XEN 虚拟块设备前端驱动. 此驱动用于与实际驱动块设备的后端驱动 (通常位于 domain0) 通信.")]),t._v(" "),e("dt",[t._v("Xen block-device backend driver\nCONFIG_XEN_BLKDEV_BACKEND")]),t._v(" "),e("dd",[t._v("XEN 块设备后端驱动 (通常位于 domain0) 允许内核将实际的块设备通过高性能的共享内存接口导出给其他客户端的前端驱动 (通常位于非 domain0) 使用.")]),t._v(" "),e("dt",[t._v("Virtio block driver\nCONFIG_VIRTIO_BLK")]),t._v(" "),e("dd",[t._v("[Virtio](http://www.ibm.com/developerworks/cn/linux/l-virtio/) 虚拟块设备驱动. 仅可用在基于 [lguest](http://lguest.ozlabs.org/) 或 [QEMU](http://wiki.qemu.org/Main_Page) 的半虚拟化客户机中 (一般是 [KVM](http://wiki.ubuntu.org.cn/Kvm%E6%95%99%E7%A8%8B) 或 [XEN](http://zh.wikipedia.org/zh-cn/Xen)).")]),t._v(" "),e("dt",[t._v("Very old hard disk (MFM/RLL/IDE) driver\nCONFIG_BLK_DEV_HD")]),t._v(" "),e("dd",[t._v('又老又旧的 MFM/RLL/ESDI 硬盘驱动. 无需犹豫, 选 "N".')]),t._v(" "),e("dt",[t._v("Rados block device (RBD)\nCONFIG_BLK_DEV_RBD")]),t._v(" "),e("dd",[t._v("[rados](http://www.alidata.org/archives/1589) 块设备 (rbd) 支持. 它可以与分布式文件系统 [Ceph](http://www.ibm.com/developerworks/cn/linux/l-ceph/) 合作, 也能独立工作.")]),t._v(" "),e("dt",[t._v("IBM Flash Adapter 900GB Full Height PCIe Device Driver\nCONFIG_BLK_DEV_RSXX")]),t._v(" "),e("dd",[t._v("IBM Flash Adapter 900GB Full Height PCIe SSD 驱动")])])]),t._v(" "),e("dt",[t._v("NVM Express block device\nCONFIG_BLK_DEV_NVME")]),t._v(" "),e("dd",[t._v("[NVM Express](http://news.mydrivers.com/1/187/187633.htm) 是专门针对 PCI-E 接口高性能固态硬盘的标准规范. 有了这一标准, 操作系统厂商只需要编写一种驱动, 就可以支持不同厂商的不同 PCI-E SSD 设备, 以解决过去 PCI-E SSD 产品形态与规格五花八门, 缺乏通用性和互用性的问题. 如果你有一块较新的 PCIE 固态硬盘, 那么很大可能就是 NVMe 接口.")]),t._v(" "),e("dt",[t._v("Misc devices")]),t._v(" "),e("dd",[t._v("杂项设备")]),t._v(" "),e("dd",[e("dl",[e("dt",{staticClass:"omit"},[t._v("{省略的部分请按照实际的硬件状况进行选择}")]),t._v(" "),e("dt",[t._v("Integrated Circuits ICS932S401\nCONFIG_ICS932S401")]),t._v(" "),e("dd",[t._v("[IDT ICS932S401](http://lwn.net/Articles/306320/) 系列时钟频率控制芯片支持 (可能会出现在某些主板上).")]),t._v(" "),e("dt",[t._v("Enclosure Services\nCONFIG_ENCLOSURE_SERVICES")]),t._v(" "),e("dd",[t._v("SES([SCSI Enclosure Services](http://wenku.baidu.com/view/dd358de86294dd88d0d26bec.html))是 SCSI 协议中用于查询设备状态 (温度 / 风扇 / 电源 / 指示灯) 的一项服务. 这里的设备可以是移动硬盘盒 / 磁盘阵列柜 / 硬盘托架等. SES 可以让主机端透过 SCSI 命令去控制外接 SCSI 设备的电源 / 风扇以及其他与数据传输无关的东西. 要使用这项技术, 外置设备和主机上的 SCSI/ATA 控制芯片都需要支持 SES 技术才 OK. 事实上, 目前大多数外置移动硬盘和所有磁盘阵列柜都支持 SES 规范.")]),t._v(" "),e("dt",[t._v("VMware Balloon Driver\nCONFIG_VMWARE_BALLOON")]),t._v(" "),e("dd",[t._v("VMware 物理内存 balloon 驱动 (将客户机操作系统不需要的物理内存页交还给宿主机). 参见 CONFIG_BALLOON_COMPACTION 选项.")]),t._v(" "),e("dt",[t._v("Generic on-chip SRAM driver\nCONFIG_SRAM")]),t._v(" "),e("dd",[t._v('许多 [SoC 系统](http://baike.baidu.com/view/882467.htm)都有芯片内嵌的 [SRAM](http://baike.baidu.com/view/423438.htm). 开启此项后, 就可以声明将此段内存范围交给通用内存分配器 ([genalloc](http://blog.csdn.net/g_salamander/article/details/8562424)) 管理. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("EEPROM support")]),t._v(" "),e("dd",[t._v('[EEPROM](http://baike.baidu.com/view/93707.htm) 主要用于保存主板或板卡的 BIOS, 如果你想通过此 Linux 系统刷写 BIOS 可以考虑开启相应的子项. 不确定的全部选 "N".')]),t._v(" "),e("dt",[t._v("Intel Management Engine Interface\nCONFIG_INTEL_MEI")]),t._v(" "),e("dd",[t._v('[Intel 芯片组管理引擎](https://software.intel.com/en-us/business-client/manageability), 是一种面向企业环境的远程管理技术, 其中的重头戏是[英特尔主动管理技术](https://software.intel.com/zh-cn/articles/amt). 如果你的芯片组位于 "CONFIG_INTEL_MEI_ME" 中, 可以考虑选 "Y", 不过如果你不明白这是什么东西, 那就说明你不需要它, 就应该选 "N". 此外, 在某些服务器上此驱动 (mei) 还可能[可能导致监视程序计时器错误, 还可能导致无法正常关机](http://zh.community.dell.com/techcenter/b/weblog/archive/2012/10/23/ubuntu-on-dell-12g-poweredge-servers).')]),t._v(" "),e("dt",[t._v("ME Enabled Intel Chipsets\nCONFIG_INTEL_MEI_ME")]),t._v(" "),e("dd",[t._v("请根据帮助中列出的芯片组对照实际情况选择.")]),t._v(" "),e("dt",[t._v("VMware VMCI Driver\nCONFIG_VMWARE_VMCI")]),t._v(" "),e("dd",[t._v('[VMware VMCI](http://pubs.vmware.com/vmci-sdk/VMCI_intro.html)(Virtual Machine Communication Interface) 是一个在 host 和 guest 之间以及同一 host 上的 guest 和 guest 之间进行高速通信的虚拟设备. VMCI 主要是提供一个接口让 guest 内的程序来调用, 通过这个接口能在一个主机上的多个虚拟机之间进行直接的通信, 而且无需经过更上层的其他途径, 这样将有效地降低网络通信所产生的开支, 但是这需要修改虚拟机上的软件, 所以 VMCI 只适用于对虚拟机间通信要求非常高的情况. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("ATA/ATAPI/MFM/RLL support (DEPRECATED)\nCONFIG_IDE")]),t._v(" "),e("dd",[t._v('已被废弃的 IDE 硬盘和 ATAPI 光驱等接口的驱动 (已被 CONFIG_ATA 取代). 选 "N", 除非你确实知道自己在干什么.')]),t._v(" "),e("dt",[t._v("SCSI device support")]),t._v(" "),e("dd",[t._v("[SCSI 子系统](http://www.ibm.com/developerworks/cn/linux/l-scsi-subsystem/)")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("RAID Transport Class\nCONFIG_RAID_ATTRS")]),t._v(" "),e("dd",[t._v('这只是用来得到 RAID 信息以及将来可能用于配置 RAID 方式的一个类. 不管你的系统使用的是哪种 RAID, 都可以放心的关闭此项. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("SCSI device support\nCONFIG_SCSI")]),t._v(" "),e("dd",[t._v('[SCSI 协议](http://wenku.baidu.com/view/517ac1bfc77da26925c5b0bb.html)支持. 有任何 SCSI/SAS/SATA/USB/Fibre Channel/FireWire 设备之一就必须选上. 选 "Y".')]),t._v(" "),e("dt",[t._v("SCSI target support\nCONFIG_SCSI_TGT")]),t._v(" "),e("dd",[t._v('内核态的通用 [SCSI Target](http://wangxu.me/blog/p/586) 实现 (原 [LIO](http://linux-iscsi.org/wiki/Target) 项目).SCSI 子系统使用了一种客户机 - 服务器 (C/S) 模型. 通常, 一台计算机是这个模型中的客户机 (称为 "initiator"), 向目标(target) 发起块操作请求, 这个 "target" 通常是一个存储设备(例如一块硬盘). 此模块的功能是将一台计算机变成一个 "target"(就像一个普通的硬盘一样), 响应其他 "initiator" 节点的操作请求, 从而让 "target" 能够提供更加高级的功能: 复制, 自动精简配置, 重复数据删除, 高可用性, 自动备份等. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("SCSI: use blk-mq I/O path by default\nCONFIG_SCSI_MQ_DEFAULT")]),t._v(" "),e("dd",[t._v('对所有 SCSI 块设备默认使用新式的多重队列 I/O 调度机制 ([blk-mq](http://blog.csdn.net/zhufengtianya/article/details/43266415)), 也就是将 I/O 请求分散至多个 CPU 处理以提高性能. 相当于开启 "scsi_mod.use_blk_mq" 内核模块参数. 尤其适合于 SSD(高 IOP)/ 磁盘阵列 (多通道) 这类存储设备.')]),t._v(" "),e("dt",[t._v("legacy /proc/scsi/ support\nCONFIG_SCSI_PROC_FS")]),t._v(" "),e("dd",[t._v('过时的 / proc/scsi / 接口. 某些老旧的刻录程序可能需要它, 建议选 "N".')]),t._v(" "),e("dt",[t._v("SCSI disk support\nCONFIG_BLK_DEV_SD")]),t._v(" "),e("dd",[t._v('使用 SCSI/SAS/SATA/PATA/USB/Fibre Channel 存储设备的必选. 选 "Y".')]),t._v(" "),e("dt",[t._v("SCSI tape support\nCONFIG_CHR_DEV_ST")]),t._v(" "),e("dd",[t._v("通用 SCSI 磁带驱动")]),t._v(" "),e("dt",[t._v("SCSI OnStream SC-x0 tape support\nCONFIG_CHR_DEV_OSST")]),t._v(" "),e("dd",[t._v("专用于 OnStream SC-x0/USB-x0/DI-x0 的 SCSI 磁带 / USB 盘驱动")]),t._v(" "),e("dt",[t._v("SCSI CDROM support\nCONFIG_BLK_DEV_SR")]),t._v(" "),e("dd",[t._v("通过 SCSI/FireWire/USB/SATA/IDE 接口连接的 DVD/CD 驱动器 (基本上涵盖了所有常见的接口).")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable vendor-specific extensions (for SCSI CDROM)\nCONFIG_BLK_DEV_SR_VENDOR")]),t._v(" "),e("dd",[t._v("仅在某些古董级的 SCSI CDROM 设备上才需要: NEC/TOSHIBA cdrom, HP Writers")])])]),t._v(" "),e("dt",[t._v("SCSI generic support\nCONFIG_CHR_DEV_SG")]),t._v(" "),e("dd",[t._v("[通用 SCSI 协议](http://sg.danny.cz/sg/) (/dev/sg*) 支持. 也就是除硬盘 / 光盘 / 磁带之外的 SCSI 设备 (例如光纤通道). 这些设备还需要额外的用户层工具支持才能正常工作. 例如:[SANE](http://www.sane-project.org/),[Cdrtools](http://cdrecord.berlios.de/private/cdrecord.html),[CDRDAO](http://cdrdao.sourceforge.net/),[Cdparanoia](http://www.xiph.org/paranoia/)")]),t._v(" "),e("dt",[t._v("SCSI media changer support\nCONFIG_CHR_DEV_SCH")]),t._v(" "),e("dd",[t._v('SCSI 介质转换设备 (SCSI Medium Changer device) 是一种控制多个 SCSI 介质的转换器(例如在多个磁带 / 光盘之间进行切换), 常用于控制磁带库或者 CD 自动点歌机(jukeboxes). 此种设备会在 / proc/scsi/scsi 中以 "Type: Medium Changer" 列出. 控制此类设备的用户层工具包是 [scsi-changer](http://linux.bytesex.org/misc/changer.html). 更多细节参见 "[Documentation/scsi/scsi-changer.txt](https://www.kernel.org/doc/Documentation/scsi/scsi-changer.txt)"文档. 不确定的选"N".')]),t._v(" "),e("dt",[t._v("SCSI Enclosure Support\nCONFIG_SCSI_ENCLOSURE")]),t._v(" "),e("dd",[t._v('"Enclosure" 是一种用于管理 SCSI 设备的背板装置. 移动硬盘盒与磁盘阵列柜就是最常见的 "Enclosure" 设备. 此项主要用于向用户层报告一些 "Enclosure" 设备的状态, 这些状态对于 SCSI 设备的正常运行并非必须. 此项依赖于 CONFIG_ENCLOSURE_SERVICES 选项.')]),t._v(" "),e("dt",[t._v("Probe all LUNs on each SCSI device\nCONFIG_SCSI_MULTI_LUN")]),t._v(" "),e("dd",[t._v('默认强制在每个 SCSI 设备上探测所有的逻辑设备数量 (Logical Unit Number), 其值会被该模块的内核引导参数 "max_luns" 覆盖. 只在一个 SCSI 设备上有多个逻辑设备时才需要选它, 一般的 SCSI 设备并不需要. 一个 SCSI 设备上有多个逻辑设备的典型例子: 多端口 USB 读卡器, CD 点唱机 (jukebox), 处于 "mass storage" 模式的智能手机, 量产为多个设备后的 U 盘. 注意: 此项并不影响符合 SCSI-3 或更高标准的设备, 因为这些设备会明确的向内核报告逻辑设备数.')]),t._v(" "),e("dt",[t._v("Verbose SCSI error reporting (kernel size +=75K)\nCONFIG_SCSI_CONSTANTS")]),t._v(" "),e("dd",[t._v("以易读的方式报告 SCSI 错误, 内核将会增大 75K")]),t._v(" "),e("dt",[t._v("SCSI logging facility\nCONFIG_SCSI_LOGGING")]),t._v(" "),e("dd",[t._v('启用 SCSI 日志 (默认并不开启, 需要 "echo [bitmask] > /proc/sys/dev/scsi/logging_level"), 可用于跟踪和捕获 SCSI 设备的错误. 关于[bitmask] 的说明可以查看 "drivers/scsi/scsi_logging.h" 文件. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Asynchronous SCSI scanning\nCONFIG_SCSI_SCAN_ASYNC")]),t._v(" "),e("dd",[t._v('异步扫描的意思是, 在内核引导过程中, SCSI 子系统可以在不影响其他子系统引导的同时进行 SCSI 设备的探测 (包括同时在多个总线上进行检测), 这样可以加快系统的引导速度. 但是如果 SCSI 设备驱动被编译为模块, 那么异步扫描将会导致内核引导出现问题 (解决方法是加载 scsi_wait_scan 模块, 或者使用 "scsi_mod.scan=sync" 内核引导参数). 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("SCSI Transports")]),t._v(" "),e("dd",[t._v("SCSI 接口类型, 下面的子项可以全不选, 内核中若有其他部分依赖它, 会自动选上")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Parallel SCSI (SPI) Transport Attributes\nCONFIG_SCSI_SPI_ATTRS")]),t._v(" "),e("dd",[t._v("传统的并行 SCSI(Ultra320/160 之类), 已逐渐被淘汰")]),t._v(" "),e("dt",[t._v("FiberChannel Transport Attributes\nCONFIG_SCSI_FC_ATTRS")]),t._v(" "),e("dd",[t._v("[光纤通道](http://baike.baidu.com/view/15247.htm)接口")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("SCSI target support for FiberChannel Transport Attributes\nCONFIG_SCSI_FC_TGT_ATTRS")]),t._v(" "),e("dd",[t._v('为光纤通道添加 "target" 模式驱动')])])]),t._v(" "),e("dt",[t._v("iSCSI Transport Attributes\nCONFIG_SCSI_ISCSI_ATTRS")]),t._v(" "),e("dd",[t._v("[iSCSI](http://zh.wikipedia.org/wiki/ISCSI) 协议是利用 TCP/IP 网络传送 SCSI 命令和数据的 I/O 技术")]),t._v(" "),e("dt",[t._v("SAS Transport Attributes\nCONFIG_SCSI_SAS_ATTRS")]),t._v(" "),e("dd",[t._v("串行 SCSI 传输属性支持 ([SAS](http://storage.chinaunix.net/stor/raid/2008/05/22/1114713.shtml) 对于 SPI 的关系犹如 SATA 对于 IDE), 这是目前的主流接口")]),t._v(" "),e("dt",[t._v("SAS Domain Transport Attributes\nCONFIG_SCSI_SAS_LIBSAS")]),t._v(" "),e("dd",[t._v('为使用了 [SAS Domain](http://biz.chinabyte.com/24/2435024_4.shtml) 架构的驱动程序提供帮助. SAS Domain 即整个 SAS 交换构架, 由 "SAS device" 和 "SAS expander device" 组成, 其中 Device 又区分为 Initiator 和 Target, 它们可以直接对接起来, 也可以经过 Expander 进行连接, Expander 起到通道交换或者端口扩展的作用. 看不懂就说明你不需要它.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("ATA support for libsas (requires libata)\nCONFIG_SCSI_SAS_ATA")]),t._v(" "),e("dd",[t._v("在 libsas 中添加 ATA 支持, 从而让 libata 和 libsas 协同工作.")]),t._v(" "),e("dt",[t._v("Support for SMP interpretation for SAS hosts\nCONFIG_SCSI_SAS_HOST_SMP")]),t._v(" "),e("dd",[t._v("在 libsas 中添加 SMP 解释器, 以允许主机支持 SAS SMP 协议.")])])]),t._v(" "),e("dt",[t._v("SRP Transport Attributes\nCONFIG_SCSI_SRP_ATTRS")]),t._v(" "),e("dd",[t._v("SCSI [RDMA](http://wiki.mbalib.com/wiki/RDMA) 协议 (SCSI RDMA Protocol) 通过将 SCSI 数据传输阶段映射到 Infiniband 远程直接内存访问 (Remote Direct Memory Access) 操作加速了 SCSI 协议.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("SCSI target support for SRP Transport Attributes\nCONFIG_SCSI_SRP_TGT_ATTRS")]),t._v(" "),e("dd",[t._v('为 SRP 添加 "target" 模式驱动')])])])])]),t._v(" "),e("dt",[t._v("SCSI low-level drivers\nCONFIG_SCSI_LOWLEVEL")]),t._v(" "),e("dd",[t._v("底层 SCSI 驱动程序")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("iSCSI Initiator over TCP/IP\nCONFIG_ISCSI_TCP")]),t._v(" "),e("dd",[t._v('[iSCSI](http://zh.wikipedia.org/wiki/ISCSI) 协议利用 TCP/IP 网络在 "initiator" 与 "targets" 间传送 SCSI 命令和数据. 此选项便是 iSCSI initiator 驱动. 相关的用户层工具 / 文档 / 配置示例, 可以在 [open-iscsi](http://open-iscsi.org) 找到.')]),t._v(" "),e("dt",[t._v("iSCSI Boot Sysfs Interface\nCONFIG_ISCSI_BOOT_SYSFS")]),t._v(" "),e("dd",[t._v('通过 sysfs 向用户空间显示 iSCSI 的引导信息. 不确定的选 "N".')]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处省略的部分按照实际使用的控制器进行选择}")]),t._v(" "),e("dt",[t._v("VMware PVSCSI driver support\nCONFIG_VMWARE_PVSCSI")]),t._v(" "),e("dd",[t._v("VMware 半虚拟化的 SCSI HBA 控制器")]),t._v(" "),e("dt",[t._v("Microsoft Hyper-V virtual storage driver\nCONFIG_HYPERV_STORAGE")]),t._v(" "),e("dd",[t._v("微软的 Hyper-V 虚拟存储控制器")]),t._v(" "),e("dt",[t._v("Intel(R) C600 Series Chipset SAS Controller\nCONFIG_SCSI_ISCI")]),t._v(" "),e("dd",[t._v("Intel C600 系列芯片组 6Gb/s SAS 控制器")]),t._v(" "),e("dt",[t._v("virtio-scsi support\nCONFIG_SCSI_VIRTIO")]),t._v(" "),e("dd",[t._v("[virtio](http://www.ibm.com/developerworks/cn/linux/l-virtio/) 虚拟 HBA 控制器. 仅可用在基于 [lguest](http://lguest.ozlabs.org/) 或 [QEMU](http://wiki.qemu.org/Main_Page) 的半虚拟化客户机中 (一般是 [KVM](http://wiki.ubuntu.org.cn/Kvm%E6%95%99%E7%A8%8B) 或 [XEN](http://zh.wikipedia.org/zh-cn/Xen)).")])])]),t._v(" "),e("dt",[t._v("PCMCIA SCSI adapter support\nCONFIG_SCSI_LOWLEVEL_PCMCIA")]),t._v(" "),e("dd",[t._v("通过 PCMCIA 卡与计算机连接的 SCSI 设备")]),t._v(" "),e("dt",[t._v("SCSI Device Handlers\nCONFIG_SCSI_DH")]),t._v(" "),e("dd",[t._v("针对某些多路径安装的 SCSI 设备的驱动, 用在每个节点都需要一个到 SCSI 存储单元的直接路径的集群中, 具体子项请按照实际使用的控制器进行选择")]),t._v(" "),e("dt",[t._v("OSD-Initiator library\nCONFIG_SCSI_OSD_INITIATOR")]),t._v(" "),e("dd",[t._v('[OSD(Object-Based Storage Device)](http://xanpeng.github.io/linux/2012/12/30/object-storage.html) 协议是一个 T10 SCSI 命令集, 和 SCSI 处于同一级别, 也跟 SCSI 很类似, 分成 osd-initiator/osd-target 两部分, 用于[对象存储文件系统](http://www.ibm.com/developerworks/cn/linux/l-ofs/index.html), 此选项实现了 [OSD-Initiator 库](http://lwn.net/Articles/305860/) (libosd.ko). 更多细节参见 "[Documentation/scsi/osd.txt](https://www.kernel.org/doc/Documentation/scsi/osd.txt)" 文件. 看不懂就说明你不需要.[提示] 此选项依赖于 CONFIG_CRYPTO_SHA1 和 CONFIG_CRYPTO_HMAC 模块.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("OSD Upper Level driver\nCONFIG_SCSI_OSD_ULD")]),t._v(" "),e("dd",[t._v("提供 OSD 上层驱动 (也就是向用户层提供 / dev/osdX 设备). 从而允许用户层控制 OSD 设备 (比如挂载基于 OSD 的 [exofs 文件系统](http://www.ibm.com/developerworks/cn/linux/l-nilfs-exofs/)).")])])])])]),t._v(" "),e("dt",[t._v("Serial ATA and Parallel ATA drivers\nCONFIG_ATA")]),t._v(" "),e("dd",[t._v("SATA 与 PATA(IDE) 设备. 桌面级 PC 以及低端服务器的硬盘基本都是此种接口")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Verbose ATA error reporting\nCONFIG_ATA_VERBOSE_ERROR")]),t._v(" "),e("dd",[t._v("输出详细的 ATA 命令描述信息. 大约会让内核增大 6KB. 禁用它将会导致调试 ATA 设备错误变得困难.")]),t._v(" "),e("dt",[t._v("ATA ACPI Support\nCONFIG_ATA_ACPI")]),t._v(" "),e("dd",[t._v('与 ATA 相关的 ACPI 对象支持. 这些对象与性能 / 安全 / 电源管理等相关. 不管你使用的是 IDE 硬盘还是 SATA 硬盘, 都建议开启 (可以使用内核引导参数 "libata.noacpi=1" 关闭).')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("SATA Zero Power Optical Disc Drive (ZPODD) support\nCONFIG_SATA_ZPODD")]),t._v(" "),e("dd",[t._v("这是 [SATA-3.1](http://news.mydrivers.com/1/199/199581.htm) 版规范新增的节能相关内容, 用新的电源管理策略降低了整个系统的电力需求, 可以让处于空闲状态的光驱耗电量近乎于零. 这需要主板和光驱两者都支持 SATA-3.1 规范才行.")])])]),t._v(" "),e("dt",[t._v("SATA Port Multiplier support\nCONFIG_SATA_PMP")]),t._v(" "),e("dd",[t._v('SATA 端口复用器 ([Port Multiplier](http://www.360doc.com/content/12/0424/16/5073814_206190083.shtml)) 是一个定义在 SATA 规范里面的可以选择的功能, 可以把一个活动主机连接多路复用至多个设备连接, 相当于一个 SATA HUB. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("AHCI SATA support\nCONFIG_SATA_AHCI")]),t._v(" "),e("dd",[t._v('AHCI SATA 支持. 这是最佳的 SATA 模式 (NCQ 功能依赖于它). 某些主板还需要在 BIOS 中将硬盘明确设为 AHCI 模式. 使用 SATA 硬盘者必选 "Y".[提示] 由于各厂商芯片组内的 SATA 控制器都遵循同一种规范, 所以并不需要各种各样针对不同 SATA 控制器的驱动, 就这一个驱动基本就能通吃所有 SATA 控制器了, 这比丰富多彩的网卡驱动省事多了.')]),t._v(" "),e("dt",[t._v("Platform AHCI SATA support\nCONFIG_SATA_AHCI_PLATFORM")]),t._v(" "),e("dd",[t._v('这是用于嵌入式系统的与 AHCI 接口兼容的 SATA 驱动. 并不是常见的芯片组中的 SATA 控制器驱动. 不确定的选 "N".')]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处省略几个特殊且不常见的 SATA 控制器驱动}")]),t._v(" "),e("dt",[t._v("ATA SFF support (for legacy IDE and PATA)\nCONFIG_ATA_SFF")]),t._v(" "),e("dd",[t._v('使用 SATA 硬盘的用户可无视此项, 选 "N" 即可. 对于依然使用老旧的 IDE/PATA 硬盘的用户而言, 按照实际情况在子项中选择相应的控制器驱动即可.')]),t._v(" "),e("dd",[e("dl",[e("dt",{staticClass:"omit"},[t._v("{此处省略几个罕见的 Pacific/Promise 芯片组}")]),t._v(" "),e("dt",[t._v("ATA BMDMA support\nCONFIG_ATA_BMDMA")]),t._v(" "),e("dd",[t._v('这是 IDE 控制器的事实标准. 除了上世纪的古董外, 绝大多数芯片组都遵守这个标准, 选 "Y", 然后从子项中选择恰当的芯片组 / 控制器.')]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处省略的 PIO-only SFF 芯片组都是早就绝迹的老古董}")]),t._v(" "),e("dt",[t._v("ACPI firmware driver for PATA\nCONFIG_PATA_ACPI")]),t._v(" "),e("dd",[t._v('通过 ACPI BIOS 去操作 IDE 控制器. 仅用于某些比较奇特的 IDE 控制器. 选 "N".')]),t._v(" "),e("dt",[t._v("Generic ATA support\nCONFIG_ATA_GENERIC")]),t._v(" "),e("dd",[t._v('这是通用的 IDE 控制器驱动. 如果你无法确定 IDE 控制器的具体型号 (比如需要面对未知的硬件状况), 或者不想使用针对特定芯片组的 IDE 驱动, 就选 "Y" 吧.')])])])])]),t._v(" "),e("dt",[t._v("Multiple devices driver support (RAID and LVM)\nCONFIG_MD")]),t._v(" "),e("dd",[t._v("多设备支持 ([RAID](http://zh.wikipedia.org/zh-cn/RAID) 和 [LVM](https://wiki.archlinux.org/index.php/LVM_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29)).RAID 和 LVM 的功能是使用多个物理设备组建成一个单独的逻辑设备")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("RAID support\nCONFIG_BLK_DEV_MD")]),t._v(" "),e("dd",[t._v('"[Software RAID](http://www.tldp.org/HOWTO/html_single/Software-RAID-HOWTO/)"(需要使用 [mdadm](https://www.kernel.org/pub/linux/utils/raid/mdadm/) 工具) 支持. 也就是 " [软 RAID](http://molinux.blog.51cto.com/2536040/516008)". 使用硬件 RAID 卡的用户并不需要此项.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Autodetect RAID arrays during kernel boot\nCONFIG_MD_AUTODETECT")]),t._v(" "),e("dd",[t._v('在内核启动过程中自动检测 RAID 模式. 如果你没有使用 RAID, 那么选中此项将会让内核在启动过程中增加几秒延迟. 如果你使用了 "raid=noautodetect" 内核引导参数关闭了自动检测, 或者此处选了 "N", 那么你必须使用 "md=???" 内核引导参数明确告诉内核 RAID 模式及配置.')]),t._v(" "),e("dt",[t._v("Linear (append) mode\nCONFIG_MD_LINEAR")]),t._v(" "),e("dd",[t._v("线性模式 (简单的将一个分区追加在另一个分区之后), 一般不使用这种模式.")]),t._v(" "),e("dt",[t._v("RAID-0 (striping) mode\nCONFIG_MD_RAID0")]),t._v(" "),e("dd",[t._v("RAID-0(等量分割) 模式, 可以获取最高性能, 但是却损害了可靠性, 一般也不使用这种模式.")]),t._v(" "),e("dt",[t._v("RAID-1 (mirroring) mode\nCONFIG_MD_RAID1")]),t._v(" "),e("dd",[t._v("RAID-1(镜像) 模式. 包含内核的引导分区只能使用这种模式.")]),t._v(" "),e("dt",[t._v("RAID-10 (mirrored striping) mode\nCONFIG_MD_RAID10")]),t._v(" "),e("dd",[t._v("RAID 1+0 模式")]),t._v(" "),e("dt",[t._v("RAID-4/RAID-5/RAID-6 mode\nCONFIG_MD_RAID456")]),t._v(" "),e("dd",[t._v("RAID-4/RAID-5/RAID-6 模式")]),t._v(" "),e("dt",[t._v("Multipath I/O support\nCONFIG_MD_MULTIPATH")]),t._v(" "),e("dd",[t._v('多路径 IO 支持是指在服务器和存储设备之间使用冗余的物理路径组件创建 "逻辑路径", 如果这些组件发生故障并造成路径失败, 多路径逻辑将为 I/O 使用备用路径以使应用程序仍然可以访问其数据. 该选项已废弃, 并已被 CONFIG_DM_MULTIPATH 所取代. 选 "N".')]),t._v(" "),e("dt",[t._v("Faulty test module for MD\nCONFIG_MD_FAULTY")]),t._v(" "),e("dd",[t._v("用于 MD(Multi-device) 的缺陷测试模块, 仅用于调试.")])])]),t._v(" "),e("dt",[t._v("Block device as cache\nCONFIG_BCACHE")]),t._v(" "),e("dd",[t._v('将一个块设备用作其他块设备的缓存 ([Bcache](https://wiki.archlinux.org/index.php/Bcache)). 此缓存使用 btree(平衡树) 索引, 并专门为 SSD 进行了优化. 仅在你打算[使用高速 SSD 作为普通硬盘的缓存](http://www.expreview.com/25399.html)时才需要此功能. 详情参见 "[Documentation/bcache.txt](https://www.kernel.org/doc/Documentation/bcache.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Bcache debugging\nCONFIG_BCACHE_DEBUG")]),t._v(" "),e("dd",[t._v("仅供内核开发者调试使用")]),t._v(" "),e("dt",[t._v("Extended runtime checks\nCONFIG_BCACHE_EDEBUG")]),t._v(" "),e("dd",[t._v("仅供内核开发者调试使用")]),t._v(" "),e("dt",[t._v("Debug closures\nCONFIG_BCACHE_CLOSURES_DEBUG")]),t._v(" "),e("dd",[t._v("仅供内核开发者调试使用")])])]),t._v(" "),e("dt",[t._v("Device mapper support\nCONFIG_BLK_DEV_DM")]),t._v(" "),e("dd",[t._v('[Device-mapper](http://www.ibm.com/developerworks/cn/linux/l-devmapper/) 是一个底层的卷管理器, 提供了一种从逻辑设备到物理设备的映射框架, 用户可以很方便的根据自己的需要制定存储资源的管理策略. 它不像 RAID 那样工作在设备层, 而是通过块和扇区的映射机制, 将不同磁盘的不同部分组合成一个大的块设备供用户使用.[LVM2](https://wiki.archlinux.org/index.php/LVM_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29) 和 [EVMS](http://en.wikipedia.org/wiki/Enterprise_Volume_Management_System) 都依赖于它. 此外, 那些集成在南桥 (例如 ICH8R/ICH9R/ICH10R 系列等) 中所谓的 "硬 RAID"(准确的称呼应该是 "[Device Mapper RAID](http://wenku.baidu.com/view/195a16eae009581b6bd9eb1b.html)", 又称为"Fake RAID"/"BIOS RAID") 也依赖于它. 还有企业级高可用环境中经常使用的多路径设备也依赖于它.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("request-based DM: use blk-mq I/O path by default\nCONFIG_DM_MQ_DEFAULT")]),t._v(" "),e("dd",[t._v('对所有 Device-mapper 块设备默认使用新式的多重队列 I/O 调度机制 ([blk-mq](http://blog.csdn.net/zhufengtianya/article/details/43266415)), 也就是将 I/O 请求映射至多个硬件或软件队列以提高性能. 相当于开启 "dm_mod.use_blk_mq" 内核模块参数. 推荐选 "Y".')]),t._v(" "),e("dt",[t._v("Device mapper debugging support\nCONFIG_DM_DEBUG")]),t._v(" "),e("dd",[t._v("仅供内核开发者调试使用")]),t._v(" "),e("dt",[t._v("Keep stack trace of persistent data block lock holders\nCONFIG_DM_DEBUG_BLOCK_STACK_TRACING")]),t._v(" "),e("dd",[t._v("仅供内核开发者调试使用")]),t._v(" "),e("dt",[t._v("Crypt target support\nCONFIG_DM_CRYPT")]),t._v(" "),e("dd",[t._v('此模块允许你创建一个经过透明加密的逻辑设备 (使用 [cryptsetup](http://code.google.com/p/cryptsetup/) 工具), 要使用加密功能, 除此项外, 还需要在 "Cryptographic API" 里选中相应的加密算法, 例如 CONFIG_CRYPTO_AES. 更多文档请参考 [LUKS FAQ](http://code.google.com/p/cryptsetup/wiki/FrequentlyAskedQuestions).')]),t._v(" "),e("dt",[t._v("Snapshot target\nCONFIG_DM_SNAPSHOT")]),t._v(" "),e("dd",[t._v('允许卷管理器为 DM 设备创建可写的快照 (定格于特定瞬间的一个设备虚拟映像).[LVM2 Snapshot](http://blog.chinaunix.net/uid-8650524-id-6166.html) 需要它的支持. 更多详情参见 "[Documentation/device-mapper/snapshot.txt](https://www.kernel.org/doc/Documentation/device-mapper/snapshot.txt)"文档. 不确定的选"N".')]),t._v(" "),e("dt",[t._v("Thin provisioning target\nCONFIG_DM_THIN_PROVISIONING")]),t._v(" "),e("dd",[t._v('"[Thin provisioning](http://en.wikipedia.org/wiki/Thin_provisioning)"(某些地方翻译为" 精简配置 ") 的意思是允许分配给所有用户的总存储容量超过实际的存储容量 (使用 [thin-provisioning-tools](https://github.com/jthornber/thin-provisioning-tools) 工具). 例如给 100 个用户分配空间, 每个用户最大允许 10G 空间, 共计需要 1000G 空间. 但实际情况是 95% 的用户都只使用了不到 1G 的空间, 那么实际准备 1000G 空间就是浪费. 有了 "thin provisioning" 的帮助, 你实际只需要准备 150G 的空间就可以了, 之后, 可以随着用户需求的增加, 添加更多的实际存储容量, 从而减少存储投资和避免浪费. 更多详情参见 "[Documentation/device-mapper/thin-provisioning.txt](https://www.kernel.org/doc/Documentation/device-mapper/thin-provisioning.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Keep stack trace of thin provisioning block lock holders\nCONFIG_DM_DEBUG_BLOCK_STACK_TRACING")]),t._v(" "),e("dd",[t._v("仅用于调试目的")])])]),t._v(" "),e("dt",[t._v("Cache target\nCONFIG_DM_CACHE")]),t._v(" "),e("dd",[t._v('[dm-cache](http://www.oschina.net/p/dm-cache) 通过将频繁使用的热点数据缓存到一个容量较小但性能很高的存储设备上, 从而提升块设备的性能. 它支持 [writeback 和 writethrough](http://blog.csdn.net/string19820108/article/details/7327552) 两种模式, 并可以使用多种[缓存策略 (policy)](http://wangxu.me/blog/p/787) 以判断哪些是热点数据以及哪些数据需要从缓存中移除. 更多详情参见 "[Documentation/device-mapper/cache.txt](https://www.kernel.org/doc/Documentation/device-mapper/cache.txt)"文档. 不确定的选"N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("MQ Cache Policy\nCONFIG_DM_CACHE_MQ")]),t._v(" "),e("dd",[t._v("MQ 缓存策略. 这是目前唯一真正可用的缓存策略.")]),t._v(" "),e("dt",[t._v("Cleaner Cache Policy\nCONFIG_DM_CACHE_CLEANER")]),t._v(" "),e("dd",[t._v("Cleaner 简单的把所有数据都同步写入到原始设备上, 相当于关闭缓存.")])])]),t._v(" "),e("dt",[t._v("Era target\nCONFIG_DM_ERA")]),t._v(" "),e("dd",[t._v('跟踪块设备上的哪些部分被写入, 用于在使用 vendor 快照时维护缓存一致性. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Mirror target\nCONFIG_DM_MIRROR")]),t._v(" "),e("dd",[t._v("允许对逻辑卷进行镜像, 同时实时数据迁移工具 [pvmove](http://francs3.blog.163.com/blog/static/40576727201223134340630/) 也需要此项的支持.")]),t._v(" "),e("dt",[t._v("RAID 1/4/5/6/10 target\nCONFIG_DM_RAID")]),t._v(" "),e("dd",[t._v('RAID 1/4/5/6/10 支持. 即使使用 ICH8R/ICH9R/ICH10R 这样的南桥, 也不推荐使用 "Device Mapper RAID"(既无性能优势又依赖于特定硬件), 应该直接使用更成熟的 CONFIG_BLK_DEV_MD 模块.')]),t._v(" "),e("dt",[t._v("Mirror userspace logging\nCONFIG_DM_LOG_USERSPACE")]),t._v(" "),e("dd",[t._v('device-mapper 用户空间日志功能由内核模块和用户空间程序两部分组成, 此选项是内核模块 (API 定义于 "linux/dm-dirty-log.h" 文件). 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Zero target\nCONFIG_DM_ZERO")]),t._v(" "),e("dd",[t._v('"Zero target" 类似于 "/dev/zero", 所有的写入都被丢弃, 所有的读取都可以得到无限多个零. 可用于某些恢复场合.')]),t._v(" "),e("dt",[t._v("Multipath target\nCONFIG_DM_MULTIPATH")]),t._v(" "),e("dd",[t._v("[设备映射多路径](http://wenku.it168.com/d_000497278.shtml) (DM-Multipath) 支持. 常用于对可靠性要求比较苛刻的场合.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("I/O Path Selector based on the number of in-flight I/Os\nCONFIG_DM_MULTIPATH_QL")]),t._v(" "),e("dd",[t._v("这是一个动态负载均衡路径选择器: 选择当前正在处理中的 I/O 数量最小的通路.")]),t._v(" "),e("dt",[t._v("I/O Path Selector based on the service time\nCONFIG_DM_MULTIPATH_ST")]),t._v(" "),e("dd",[t._v("这是一个动态负载均衡路径选择器: 选择完成此 I/O 操作预期时间最少的通路.")])])]),t._v(" "),e("dt",[t._v("I/O delaying target\nCONFIG_DM_DELAY")]),t._v(" "),e("dd",[t._v("对读 / 写操作进行延迟, 并可将其发送到不同的设备. 仅用于测试 DM 子系统.")]),t._v(" "),e("dt",[t._v("DM uevents\nCONFIG_DM_UEVENT")]),t._v(" "),e("dd",[t._v('为 DM 事件透过 [netlink](http://zh.wikipedia.org/wiki/Netlink) 向用户层的 udevd 发出 uevent 通知, 这样就允许 udevd 在 "/dev/" 目录中执行相应的操作.')]),t._v(" "),e("dt",[t._v("Flakey target\nCONFIG_DM_FLAKEY")]),t._v(" "),e("dd",[t._v("模拟间歇性的 I/O 错误, 以用于调试 DM 子系统.")]),t._v(" "),e("dt",[t._v("Verity target support\nCONFIG_DM_VERITY")]),t._v(" "),e("dd",[t._v('Verity target 可以创建一个只读的逻辑设备, 然后根据预先生成的哈希校验和 (存储在其他设备上), 校验底层设备上的数据正确性. 要使此模块正常工作, 还需要在 "Cryptographic API" 部分选中相应的哈希算法.')]),t._v(" "),e("dt",[t._v("Switch target support\nCONFIG_DM_SWITCH")]),t._v(" "),e("dd",[t._v("Switch target 可以创建这样的逻辑设备: 将固定尺寸区块的 I/O 操作任意映射到一组固定的路径上. 通过向 target 发送一个消息, 即可动态的切换指定区块的 I/O 操作所使用的路径.")]),t._v(" "),e("dt",[t._v("Log writes target support\nCONFIG_DM_LOG_WRITES")]),t._v(" "),e("dd",[t._v("此种 target 需要两个设备: 主设备按照常规方式使用, 辅设备则专门记录所有主设备的写操作. 主要用于帮助文件系统的开发者验证文件系统的一致性, 仅供开发调试使用.")])])])])]),t._v(" "),e("dt",[t._v("Generic Target Core Mod (TCM) and ConfigFS Infrastructure\nCONFIG_TARGET_CORE")]),t._v(" "),e("dd",[t._v("通用 TCM 存储引擎与 ConfigFS 虚拟文件系统 (/sys/kernel/config) 支持. 看不懂就说明你不需要.")]),t._v(" "),e("dt",[t._v("Fusion MPT device support\nCONFIG_FUSION")]),t._v(" "),e("dd",[t._v('[Fusion MPT](http://storage.chinaunix.net/stor/other/2006/04/05/1109749.shtml)(Message Passing Technology) 是 LSI Logic 公司为了更容易实现 SCSI 和光纤通道而提出的技术, 支持 Ultra320 SCSI / 光纤通道 / SAS. VirtualBox 与 VMware 的虚拟 SCSI 控制器 "LSI Logic SAS" 就使用该目录下的 CONFIG_FUSION_SAS 驱动.')]),t._v(" "),e("dt",[t._v("IEEE 1394 (FireWire) support")]),t._v(" "),e("dd",[t._v("火线 ([IEEE 1394](http://baike.baidu.com/view/117006.htm)) 是苹果公司开发的串行接口, 类似于 USB, 但 PC 上并不常见, 算得上是个没有未来的技术了.")]),t._v(" "),e("dt",[t._v("I2O device support\nCONFIG_I2O")]),t._v(" "),e("dd",[t._v("[智能输入输出](http://wenwen.soso.com/z/q59111011.htm) ([Intelligent Input/Output](http://baike.baidu.com/view/272945.htm)) 架构让硬件驱动分成了两部分: OSM(特定于操作系统)+HDM(特定于硬件, 与操作系统无关). 由于 [I2O 设备](http://i2o.shadowconnect.com/index.php)上集成有专用的 I/O 处理器, 从而加快 I/O 速度 (因为避免了 CPU 的参与).I2O 属于已被废弃的技术, 目前能见到的此类设备都属于老古董了.")]),t._v(" "),e("dt",[t._v("Macintosh device drivers\nCONFIG_MACINTOSH_DRIVERS")]),t._v(" "),e("dd",[t._v("苹果的 Macintosh 电脑上的专有设备驱动")]),t._v(" "),e("dt",[t._v("Network device support\nCONFIG_NETDEVICES")]),t._v(" "),e("dd",[t._v('网络设备. 除非你不想连接任何网络, 否则必选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Network core driver support\nCONFIG_NET_CORE")]),t._v(" "),e("dd",[t._v('如果你不想使用任何高级网络功能 (拨号网络 / EQL/VLAN/bridging/bonding/team / 光纤通道 / [虚拟网络](http://www.ibm.com/developerworks/cn/linux/l-virtual-networking/)等), 仅仅是一般性质的联网 (普通低端服务器, 通过路由器或者局域网上网的常规个人电脑或办公电脑), 可以选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Bonding driver support\nCONFIG_BONDING")]),t._v(" "),e("dd",[t._v('链路聚合技术拥有多个不同的称谓: Linux 称为 "[Bonding](http://blog.csdn.net/wuweilong/article/details/39720571)",IEEE 称为"[802.3ad](http://baike.baidu.com/view/1996279.htm)",Sun 称为"Trunking",Cisco 称为"[Etherchannel](http://baike.baidu.com/view/320130.htm)". 该技术可以将多个以太网通道聚合为一个单独的虚拟适配器, 例如将两块网卡聚合成一个逻辑网卡, 可以用来实现负载均衡或硬件冗余. 此项技术目前已逐渐被 CONFIG_NET_TEAM 取代.')]),t._v(" "),e("dt",[t._v("Dummy net driver support\nCONFIG_DUMMY")]),t._v(" "),e("dd",[t._v("Dummy 网络接口本质上是一个可以配置 IP 地址的 bit-bucket(位桶, 所有发送到此设备的流量都将被湮灭), 以使应用程序看上去正在和一个常规的网络接口进行通信. 使用 [SLIP](http://zh.wikipedia.org/wiki/%E4%B8%B2%E8%A1%8C%E7%BA%BF%E8%B7%AFIP%E5%8D%8F%E8%AE%AE)(小猫拨号, 目前应该已经绝迹了) 或 [PPP](http://zh.wikipedia.org/wiki/%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE)(常用于 [PPPoE](http://zh.wikipedia.org/wiki/PPPoE) ADSL) 的用户需要它")]),t._v(" "),e("dt",[t._v("EQL (serial line load balancing) support\nCONFIG_EQUALIZER")]),t._v(" "),e("dd",[t._v("串行线路的负载均衡. 如果有两个 MODEM 和两条 SLIP/PPP 线路, 该选项可以让你同时使用这两个通道以达到双倍速度 (网络的对端也要支持 EQL 技术). 曾经昙花一现的 [ISDN](http://baike.baidu.com/view/51012.htm) 就这项技术的一个实例.")]),t._v(" "),e("dt",[t._v("Fibre Channel driver support\nCONFIG_NET_FC")]),t._v(" "),e("dd",[t._v("光纤通道 (Fibre Channel) 是一种高速网络串行协议, 主要用于存储局域网 (SAN), 与传统的 iSCSI 技术相比, 除了提供更高的数据传输速度(此优势不是绝对的), 更远的传输距离, 更多的设备连接支持, 更稳定的性能, 更简易的安装以外, 最重要的是支持网络区域存储(SAN) 技术. FC 与 SCSI 兼容, 并意在取代 iSCSI(看起来难以如愿, 并且有可能被 40Gb 以上的 iSCSI 反超). 如果你的机器上有光纤通道卡(FC 卡), 除了需要开启此项外, 还需要开启相应的 FC 卡驱动, 以及 CONFIG_CHR_DEV_SG 选项.")]),t._v(" "),e("dt",[t._v("Generic Media Independent Interface device support\nCONFIG_MII")]),t._v(" "),e("dd",[t._v("[媒体独立接口](http://baike.baidu.com/view/229282.htm) ([Media Independent Interface](http://www.cndzz.com/download/4105_0/102212.html)) 又称介质无关接口, 是 [IEEE-802.3](http://baike.baidu.com/view/203586.htm)(规定了以太网相关协议的具体内容) 定义的以太网行业标准. 它包括一个数据接口, 以及一个位于 [MAC 和 PHY](http://www.360doc.com/content/11/1020/23/1317564_157853470.shtml) 之间的控制接口.[提示] 大多数以太网卡都有 MII 收发器, 其驱动都依赖于此项, 也会自动选中此项.")]),t._v(" "),e("dt",[t._v("Intermediate Functional Block support\nCONFIG_IFB")]),t._v(" "),e("dd",[t._v("[IFB](http://www.linuxfoundation.org/collaborate/workgroups/networking/ifb) 是一个中间层驱动, 可以用来灵活的配置资源共享. 更多信息参见 iproute2 文档. 看不懂就说明你不需要.")]),t._v(" "),e("dt",[t._v("Ethernet team driver support\nCONFIG_NET_TEAM")]),t._v(" "),e("dd",[t._v('[team 驱动](http://ceyes.github.io/2014-07/Study-Linux-Team/). 允许通过 "ip link add link [address MAC] [ NAME ] type team" 命令, 或者使用将多个以太网卡 (称为 "port") 组合在一起, 创建一个虚拟的 "[team](https://linux.cn/article-5384-1.html)"网络设备, 从而允许故障转移或者提高吞吐率, 其目的是取代传统的"Bonding"(CONFIG_BONDING) 驱动."ip"是 iproute2 包中的一个命令. 不确定的选"N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Broadcast mode support\nCONFIG_NET_TEAM_MODE_BROADCAST")]),t._v(" "),e("dd",[t._v('广播模式: 所有网卡共用同一个 MAC 地址, 每一个包都从所有网卡同时发送, 不做负载均衡, 仅做链路冗余, 需要和交换机的 "聚合强制不协商" 方式配合使用. 此模式最浪费资源, 但可靠性最高, 容错能力最强. 常用于强调极端可靠的金融业.')]),t._v(" "),e("dt",[t._v("Round-robin mode support\nCONFIG_NET_TEAM_MODE_ROUNDROBIN")]),t._v(" "),e("dd",[t._v('循环均衡模式: 所有网卡共用同一个 MAC 地址, 数据包依次从每个网卡循环分发 (例如, 在三个网卡一组的情况下, 第 0 个包走 eth0, 第 1 个包走 eth1, 第 2 个包走 eth2, 第 3 个包走 eth0, 第 4 个包走 eth1, 第 5 个包走 eth2, 第 6 个包走 eth0,... 一直循环分发下去, 直到传输完毕), 带宽增加, 支持容错 (故障链路会被自动踢出), 交换机需要配置聚合口 (思科叫 "port channel"). 数据包从不同的网卡发出, 若中途再经过不同的链路, 在到达客户端时可能会乱序, 从而造成吞吐量达不到理论上的翻倍效果.')]),t._v(" "),e("dt",[t._v("Random mode support\nCONFIG_NET_TEAM_MODE_RANDOM")]),t._v(" "),e("dd",[t._v('随机均衡模式: 所有网卡共用同一个 MAC 地址, 数据包依次随机选择一个网卡分发 (例如, 在三个网卡一组的情况下, 第 0 个包走 eth2, 第 1 个包走 eth0, 第 2 个包走 eth2, 第 3 个包走 eth1, 第 4 个包走 eth1, 第 5 个包走 eth0, 第 6 个包走 eth2,... 一直随机分发下去, 直到传输完毕), 带宽增加, 支持容错 (故障链路会被自动踢出), 交换机需要配置聚合口 (思科叫 "port channel"). 数据包从不同的网卡发出, 若中途再经过不同的链路, 在到达客户端时可能会乱序, 从而造成吞吐量达不到理论上的翻倍效果.')]),t._v(" "),e("dt",[t._v("Active-backup mode support\nCONFIG_NET_TEAM_MODE_ACTIVEBACKUP")]),t._v(" "),e("dd",[t._v("主备模式: 无需更改每个网卡的原生 MAC 地址, 但是 team 的 MAC 地址对外仅在主网卡上可见并且保持不变, 同一时刻仅有主网卡处于激活状态, 其他备用网卡都处于等待状态, 所有流量仅通过主网卡发送, 仅在主网卡故障时, 某个备用网卡才会被激活成主网卡. 此模式仅提供容错能力, 可靠性高, 但是资源利用率最低. 此模式最大的好处是不需要在交换机上做特别的设置.")]),t._v(" "),e("dt",[t._v("Load-balance mode support\nCONFIG_NET_TEAM_MODE_LOADBALANCE")]),t._v(" "),e("dd",[t._v("BPF 均衡模式: 均衡算法由用户空间通过 BPF 接口 (bpf_hash_func) 设置.")])])]),t._v(" "),e("dt",[t._v("MAC-VLAN support\nCONFIG_MACVLAN")]),t._v(" "),e("dd",[t._v('MAC-VLAN 是通过 MAC 地址来划分 [VLAN](http://baike.baidu.com/view/21837.htm) 的方式, 在 Linux 则用来给网卡添加多个 MAC 地址. 你可以使用 "ip link add link '),e("real",{attrs:{dev:""}},[t._v(' [ address MAC ] [ NAME ] type macvlan" 命令创建一个虚拟的 "macvlan" 设备 (系统会自动打开网卡的[混杂模式](http://baike.baidu.com/view/2521757.htm)), 然后就可以在同一个物理网卡上虚拟出多个以太网口. Docker 依赖于它.')])],1),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("MAC-VLAN based tap driver\nCONFIG_MACVTAP")]),t._v(" "),e("dd",[t._v('基于 MAC-VLAN 接口的 tap(虚拟以太网设备) 字符设备 ([macvtap](http://blog.csdn.net/kl222/article/details/8513593)) 驱动, 旨在简化虚拟化的桥接网络, 目的是替代 [TUN/TAP](http://baike.baidu.com/view/8570754.htm)(CONFIG_TUN) 和 Bridge(CONFIG_BRIDGE) 内核模块. 可以通过与创建 macvlan 设备相同的 "ip" 命令创建一个虚拟的 "macvtap" 设备, 并通过 [TAP](http://zh.wikipedia.org/wiki/TUN%E4%B8%8ETAP) 用户空间接口进行访问.')])])]),t._v(" "),e("dt",[t._v("Virtual eXtensible Local Area Network (VXLAN)\nCONFIG_VXLAN")]),t._v(" "),e("dd",[t._v('"[vxlan](http://hb.qq.com/a/20111010/000076.htm)" 虚拟接口可以在第三层网络上创建第二层网络 (跨多个物理 IP 子网的虚拟二层子网), 是一种在 UDP 中封装 MAC 的简单机制, 主要用于虚拟化环境下的隧道虚拟网络 (tunnel virtual network).')]),t._v(" "),e("dt",[t._v("Network console logging support\nCONFIG_NETCONSOLE")]),t._v(" "),e("dd",[t._v('网络控制台 (netconsole) 的作用是通过网络记录内核日志信息. 详情参见 "[Documentation/networking/netconsole.txt](https://www.kernel.org/doc/Documentation/networking/netconsole.txt)"文档. 不确定的选"N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Dynamic reconfiguration of logging targets\nCONFIG_NETCONSOLE_DYNAMIC")]),t._v(" "),e("dd",[t._v("允许通过 configfs 导出的用户空间接口, 在运行时更改日志目标 (网口, IP 地址, 端口号, MAC 地址).")])])]),t._v(" "),e("dt",[t._v("Netpoll traffic trapping\nCONFIG_NETPOLL_TRAP")]),t._v(" "),e("dd",[t._v('[netpoll](http://www.360doc.com/content/11/1023/09/7975692_158366329.shtml) 的目的是让内核在网络和 I/O 子系统尚不能完整可用时, 依然能发送和接收数据包. 主要用于网络控制台 (netconsole) 和远程内核调试 (KGDBoE) 中. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Virtual Ethernet over NTB\nCONFIG_NTB_NETDEV")]),t._v(" "),e("dd",[t._v('PCI-E 非透明桥 (CONFIG_NTB) 上的虚拟网卡. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("RapidIO Ethernet over messaging driver support\nCONFIG_RIONET")]),t._v(" "),e("dd",[t._v('在标准的 [RapidIO](http://www.big-bit.com/news/ic_29514.html) 通信方式上发送以太网数据包. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Universal TUN/TAP device driver support\nCONFIG_TUN")]),t._v(" "),e("dd",[t._v('[TUN/TAP](http://www.ibm.com/developerworks/cn/linux/l-tuntap/) 可以为用户空间提供包的接收和发送服务, 可以用来虚拟一张网卡或点对点通道 (例如为 QEMU 提供虚拟网卡支持). 当程序打开 "/dev/net/tun" 设备时, 驱动程序就会注册相应的 ["tunX" 或 "tapX"](http://blog.csdn.net/wangxing1018/article/details/3510118) 网络设备, 当程序关闭 "/dev/net/tun" 设备时, 驱动程序又会删除相应的 "tunX" 或 "tapX" 网络设备以及所有与之相关联的路由. 详情参见 "[Documentation/networking/tuntap.txt](https://www.kernel.org/doc/Documentation/networking/tuntap.txt)" 文档. 看不懂就表明你不需要.')]),t._v(" "),e("dt",[t._v("Support for cross-endian vnet headers on little-endian kernels\nCONFIG_TUN_VNET_CROSS_LE")]),t._v(" "),e("dd",[t._v('允许小端序 (little-endian) 内核中的 TUN/TAP 与 MACVTAP 设备驱动解析来自大端序 (big-endian) 内核的老旧的 virtio 设备的 vnet 头. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Virtual ethernet pair device\nCONFIG_VETH")]),t._v(" "),e("dd",[t._v("该驱动提供了一个本地以太网隧道 (设备会被成对的创建).Docker 依赖于它.")]),t._v(" "),e("dt",[t._v("Virtio network driver\nCONFIG_VIRTIO_NET")]),t._v(" "),e("dd",[t._v("[virtio](http://www.ibm.com/developerworks/cn/linux/l-virtio/) 虚拟网卡驱动. 仅可用在基于 [lguest](http://lguest.ozlabs.org/) 或 [QEMU](http://wiki.qemu.org/Main_Page) 的半虚拟化客户机中 (一般是 [KVM](http://wiki.ubuntu.org.cn/Kvm%E6%95%99%E7%A8%8B) 或 [XEN](http://zh.wikipedia.org/zh-cn/Xen)).")]),t._v(" "),e("dt",[t._v("Virtual netlink monitoring device\nCONFIG_NLMON")]),t._v(" "),e("dd",[t._v("提供一个可以监视 netlink skbs 的网络设备, 以允许 tcpdump 之类的工具通过 packet socket 来分析 netlink 消息. 仅供调试使用.")])])]),t._v(" "),e("dt",[t._v("ARCnet support\nCONFIG_ARCNET")]),t._v(" "),e("dd",[t._v("[ARCnet](http://baike.baidu.com/view/630530.htm) 是 1977 年由 Datapoint 公司开发的一种局域网技术, 它采用令牌总线方案来管理 LAN 上工作站和其他设备之间的共享线路, 主要用于工业控制领域中.")]),t._v(" "),e("dt",[t._v("ATM drivers\nCONFIG_ATM_DRIVERS")]),t._v(" "),e("dd",[t._v("可怜的 ATM(异步传输模式), 曾经在 90 年代风靡一时, 现在已经消失的无影无踪了.")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{这里省略几个专用于 Android/MeeGo 系统的 PF_CAIF 类型套接字相关的选项}")]),t._v(" "),e("dt",[t._v("Distributed Switch Architecture drivers")]),t._v(" "),e("dd",[t._v("分布式交换架构驱动, 其子项都是 Marvell 系列以太网交换机芯片组的驱动")]),t._v(" "),e("dt",[t._v("Ethernet driver support\nCONFIG_ETHERNET")]),t._v(" "),e("dd",[t._v("最常见的以太网卡驱动")]),t._v(" "),e("dd",[e("dl",[e("dt",{staticClass:"omit"},[t._v("{省略的部分请按照实际的硬件状况进行选择, 这里仅以两个常见公司的以太网芯片为例进行说明}")]),t._v(" "),e("dt",[t._v("AMD devices\nCONFIG_NET_VENDOR_AMD")]),t._v(" "),e("dd",[t._v("AMD 出品的以太网控制芯片")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("AMD PCnet32 PCI support\nCONFIG_PCNET32")]),t._v(" "),e("dd",[t._v("这是 VMware/VirtualBox 虚拟机中常用的网卡")])])]),t._v(" "),e("dt",[t._v("Broadcom devices\nCONFIG_NET_VENDOR_BROADCOM")]),t._v(" "),e("dd",[t._v("博通 (Broadcom) 公司的网卡")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Broadcom 440x/47xx ethernet support\nCONFIG_B44")]),t._v(" "),e("dd",[t._v("Broadcom 44xx/47xx 10/100M PCI")]),t._v(" "),e("dt",[t._v("Broadcom NetXtremeII support\nCONFIG_BNX2")]),t._v(" "),e("dd",[t._v("NetXtreme II 1 Gigabit (BCM5706/5708/5709/5716)")]),t._v(" "),e("dt",[t._v("Broadcom CNIC support\nCONFIG_CNIC")]),t._v(" "),e("dd",[t._v('NetXtremeII 系列网卡的 [TCP 减负引擎](http://www.sansky.net/article/2007-11-17-toe-technology-and-the-working-principle-of-toe-nic.html) ([TCP Offload Engine](http://en.wikipedia.org/wiki/TCP_offload_engine)) 特性支持. 不过,[TOE 并不适合高连接数 / 小文件的 Web 服务器类应用](http://www.cnblogs.com/pandaeye/archive/2013/05/20/3089635.html), 它的主要目的是和 IP 存储协议 (iSCSI/NFS) 一起使用.[注意]TOE 与 "Large Receive Offload" 是两个不同的东西, 不要混淆.')]),t._v(" "),e("dt",[t._v("Broadcom Tigon3 support\nCONFIG_TIGON3")]),t._v(" "),e("dd",[t._v('这是最流行的驱动, 其涵盖的型号特别多, 但是 "Tigon3" 的名称却非常具有迷惑性. 简单说来, 除了 B44,BNX2,BNX2X 中明确列出的型号外, 其他型号用的都是这个驱动.[注意] 某些型号还需要额外到固件支持, 例如: BCM5703/BCM5704 需要 tigon/tg3_tso.bin,BCM5701A0 需要 tigon/tg3.bin,BCM5705 需要 tigon/tg3_tso5.bin')]),t._v(" "),e("dt",[t._v("Broadcom NetXtremeII 10Gb support\nCONFIG_BNX2X")]),t._v(" "),e("dd",[t._v("NetXtreme II 10 Gigabit (BCM57710/57711/57711E/57712/57800/57810)")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Broadcom 578xx and 57712 SR-IOV support\nCONFIG_BNX2X_SRIOV")]),t._v(" "),e("dd",[t._v("支持 578xx/57712 的[单根 I/O 虚拟化](http://blog.sina.com.cn/s/blog_582a1a4b0100zvnh.html) ([Single Root IOV](http://www.openstack.cn/?p=2118)) 技术")])])])])])])]),t._v(" "),e("dt",[t._v("FDDI driver support\nCONFIG_FDDI")]),t._v(" "),e("dd",[t._v("[光纤分布式数据接口](http://baike.baidu.com/view/876931.htm) (FDDI)")]),t._v(" "),e("dt",[t._v("HIPPI driver support\nCONFIG_HIPPI")]),t._v(" "),e("dd",[t._v("[高性能并行接口](http://baike.baidu.com/view/5423623.htm) (HIgh Performance Parallel Interface) 是一个在短距离内高速传送大量数据的点对点协议. 常用于集群和超级计算机.")]),t._v(" "),e("dt",[t._v("General Instruments Surfboard 1000\nCONFIG_NET_SB1000")]),t._v(" "),e("dd",[t._v("SURFboard 1000 插卡式 Cable Medem(ISA 接口), 这玩意早就绝种了")]),t._v(" "),e("dt",[t._v("PHY Device support and infrastructure\nCONFIG_PHYLIB")]),t._v(" "),e("dd",[t._v('数据链路层芯片简称为 MAC 控制器, 物理层芯片简称之为 PHY, 通常的网卡把 MAC 和 PHY 的功能做到了一颗芯片中, 但也有一些仅含 PHY 的 "软网卡". 此选项就是对这些 "软网卡" 的支持. 请根据实际情况选择其下的子项.')]),t._v(" "),e("dt",[t._v("Micrel KS8995MA 5-ports 10/100 managed Ethernet switch\nCONFIG_MICREL_KS8995MA")]),t._v(" "),e("dd",[t._v("[Micrel](http://www.micrel.com.cn/) KS8995MA 5 端口 10/100M 以太网交换芯片")]),t._v(" "),e("dt",[t._v("PLIP (parallel port) support\nCONFIG_PLIP")]),t._v(" "),e("dd",[t._v('[PLIP](http://fanqiang.chinaunix.net/a3/b2/20010421/173510_b.html)(Parallel Line Internet Protocol) 用于将两台电脑通过并口进行联网, 组成一个简单的客户机 / 服务器结构. 详情参见 "[Documentation/networking/PLIP.txt](https://www.kernel.org/doc/Documentation/networking/PLIP.txt)". 现在的电脑都使用网卡进行互联, 并口早就经被丢进历史的垃圾箱了.')]),t._v(" "),e("dt",[t._v("PPP (point-to-point protocol) support\nCONFIG_PPP")]),t._v(" "),e("dd",[t._v('[点对点协议](http://zh.wikipedia.org/zh-cn/%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE) ([Point to Point Protocol](http://www.cnblogs.com/zmkeil/archive/2013/05/02/3055518.html)) 是 SLIP 的继任者, 使用 PPP 需要用户层程序 [pppd](http://www.cnblogs.com/simonshi/archive/2010/04/23/1718984.html) 的帮助. PPP 实际上有两个版本: 基于普通模拟电话线的 "异步 PPP" 和基于数字线路 (例如 ISDN 线路) 的 "同步 PPP". [使用电脑直接拨号的 PPPoE ADSL 用户](http://wiki.ubuntu.org.cn/ADSL%EF%BC%88PPPOE%EF%BC%89%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97)需要此项.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("PPP BSD-Compress compression\nCONFIG_PPP_BSDCOMP")]),t._v(" "),e("dd",[t._v("为 PPP 提供 BSD(等价于 LZW 压缩算法, 没有 gzip 高效) 压缩算法支持, 需要通信双方的支持才有效. 大多数 ISP 都不支持此算法.")]),t._v(" "),e("dt",[t._v("PPP Deflate compression\nCONFIG_PPP_DEFLATE")]),t._v(" "),e("dd",[t._v("为 PPP 提供 Deflate(等价于 gzip 压缩算法) 压缩算法支持, 需要通信双方的支持才有效. 这是比 BSD 更好的算法 (压缩率更高且无专利障碍).")]),t._v(" "),e("dt",[t._v("PPP filtering\nCONFIG_PPP_FILTER")]),t._v(" "),e("dd",[t._v('允许对通过 PPP 接口的包进行过滤. 仅在你需要使用 pppd 的 pass-filter/active-filter 选项时才需要开启. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("PPP MPPE compression (encryption)\nCONFIG_PPP_MPPE")]),t._v(" "),e("dd",[t._v("为 PPP 提供 MPPE 加密协议支持, 它被用于微软的 P2P 隧道协议中. 此特性需要 [PPTP Client](https://wiki.archlinux.org/index.php/Microsoft_VPN_client_setup_with_pptpclient_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29) 工具的支持.")]),t._v(" "),e("dt",[t._v("PPP multilink support\nCONFIG_PPP_MULTILINK")]),t._v(" "),e("dd",[t._v("多重链路协议 (RFC1990) 允许你将多个线路 (物理的或逻辑的) 组合为一个 PPP 连接一充分利用带宽, 这不但需要 pppd 的支持, 还需要 ISP 的支持")]),t._v(" "),e("dt",[t._v("PPP over ATM\nCONFIG_PPPOATM")]),t._v(" "),e("dd",[t._v('在 ATM 上跑的 PPP. 果断 "N".')]),t._v(" "),e("dt",[t._v("PPP over Ethernet\nCONFIG_PPPOE")]),t._v(" "),e("dd",[t._v("这就是 ADSL 用户最常见的 PPPoE, 也就是在以太网上跑的 PPP 协议. 这需要 [RP-PPPoE](http://www.roaringpenguin.com/pppoe) 工具的帮助")]),t._v(" "),e("dt",[t._v("PPP over IPv4 (PPTP)\nCONFIG_PPTP")]),t._v(" "),e("dd",[t._v("[点对点隧道协议](http://zh.wikipedia.org/zh-cn/%E9%BB%9E%E5%B0%8D%E9%BB%9E%E9%9A%A7%E9%81%93%E5%8D%94%E8%AD%B0) ([Point-to-Point Tunneling Protocol](http://baike.baidu.com/view/32771.htm)) 是一种主要用于 VPN 的数据链路层网络协议. 此功能需要 [ACCEL-PPTP](http://accel-pptp.sourceforge.net/) 工具的支持.")]),t._v(" "),e("dt",[t._v("PPP over L2TP\nCONFIG_PPPOL2TP")]),t._v(" "),e("dd",[t._v("[第二层隧道协议](http://zh.wikipedia.org/zh-cn/%E7%AC%AC%E4%BA%8C%E5%B1%82%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE) ([L2TP](http://baike.baidu.com/view/32692.htm)) 是一种通过 UDP 隧道传输 PPP 流量的技术, 对于 VPN 用户来说,[L2TP VPN](http://www.h3c.com.cn/MiniSite/Technology_Circle/Technology_Column/ICG/ICG_Technology/201004/671383_97665_0.htm) 是比 PPTP VPN 的更好解决方案.")]),t._v(" "),e("dt",[t._v("PPP support for async serial ports\nCONFIG_PPP_ASYNC")]),t._v(" "),e("dd",[t._v('基于普通模拟电话线或标准异步串口 (COM1,COM2) 的 "异步 PPP" 支持. PPPoE ADSL 使用的就是这个. 不能与下面的 CONFIG_PPP_SYNC_TTY 同时并存.')]),t._v(" "),e("dt",[t._v("PPP support for sync tty ports\nCONFIG_PPP_SYNC_TTY")]),t._v(" "),e("dd",[t._v('基于同步 tty 设备 (比如 SyncLink 适配器) 的 "同步 PPP" 支持. 常用于高速租用线路(比如 T1/E1). 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("SLIP (serial line) support\nCONFIG_SLIP")]),t._v(" "),e("dd",[t._v('一个在串行线上 (例如电话线) 传输 IP 数据报的 TCP/IP 协议. 最原始的通过电话线拨号上网就用这个协议, 如今基本绝迹了. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("CSLIP compressed headers\nCONFIG_SLIP_COMPRESSED")]),t._v(" "),e("dd",[t._v("CSLIP 协议基于 SLIP, 但比 SLIP 快, 它将 TCP/IP 头 (而非数据) 进行压缩传送, 需要通信双方的支持才有效")]),t._v(" "),e("dt",[t._v("Keepalive and linefill\nCONFIG_SLIP_SMART")]),t._v(" "),e("dd",[t._v("让 SLIP 驱动支持 RELCOM linefill 和 keepalive 监视, 这在信号质量比较差的模拟线路上是个好主意")]),t._v(" "),e("dt",[t._v("Six bit SLIP encapsulation\nCONFIG_SLIP_MODE_SLIP6")]),t._v(" "),e("dd",[t._v('这种线路非常罕见, 选 "N".')]),t._v(" "),e("dt",[t._v("USB Network Adapters")]),t._v(" "),e("dd",[t._v("USB 网络适配器")]),t._v(" "),e("dt",[t._v("Wireless LAN\nCONFIG_WLAN")]),t._v(" "),e("dd",[t._v("[无线网卡](http://wireless.kernel.org/en/users/Drivers)")]),t._v(" "),e("dd",[e("dl",[e("dt",{staticClass:"omit"},[t._v("{省略的部分请按照实际的硬件状况进行选择, 这里仅以 Intel 公司的主流无线网卡为例进行说明}")]),t._v(" "),e("dt",[t._v("Intel Wireless WiFi Next Gen AGN - Wireless-N/Advanced-N/Ultimate-N (iwlwifi)\nCONFIG_IWLWIFI")]),t._v(" "),e("dd",[t._v('这是目前主流 Intel 无线网卡的驱动. 此驱动依赖于[二进制 uCode 微代码](http://intellinuxwireless.org/), 它通常被安装到 "/lib/firmware" 目录, 不过你最好亲自用眼睛检查一下其中是否存在 "iwlwifi-*.ucode" 这样的文件.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Intel Wireless WiFi DVM Firmware support\nCONFIG_IWLDVM")]),t._v(" "),e("dd",[t._v('DVM 固件支持 (这也是当前唯一可用的固件). 选 "Y/M".[提示] 如果你将此驱动静态编译进内核, 那么务必使用 CONFIG_EXTRA_FIRMWARE 功能将固件也一起编译进内核.')]),t._v(" "),e("dt",[t._v("Intel Wireless WiFi MVM Firmware support\nCONFIG_IWLMVM")]),t._v(" "),e("dd",[t._v("MVM 固件支持 (这是专用于 7000 系列无线网卡的固件).")])])]),t._v(" "),e("dt",[t._v("Debugging Options")]),t._v(" "),e("dd",[t._v('仅供调试使用, 其下所有选项都选 "N".')]),t._v(" "),e("dt",[t._v("iwlwifi experimental P2P support\nCONFIG_IWLWIFI_P2P")]),t._v(" "),e("dd",[t._v('iwlwifi 驱动实验性的 P2P 支持. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("WiMAX Wireless Broadband devices")]),t._v(" "),e("dd",[t._v("WiMAX 无线设备")]),t._v(" "),e("dt",[t._v("Wan interfaces support\nCONFIG_WAN")]),t._v(" "),e("dd",[t._v('[广域网](http://baike.baidu.com/view/21956.htm) (Wide Area Network) 网卡支持. 这种网卡很罕见. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("IEEE 802.15.4 drivers\nCONFIG_IEEE802154_DRIVERS")]),t._v(" "),e("dd",[t._v("[IEEE 802.15.4](http://baike.baidu.com/view/1915042.htm) 描述了低速率无线个人局域网的物理层和媒体接入控制协议")]),t._v(" "),e("dt",[t._v("Xen network device frontend driver\nCONFIG_XEN_NETDEV_FRONTEND")]),t._v(" "),e("dd",[t._v('XEN 半虚拟化网络设备前端驱动 (通常是被 "domain 0" 导出的)')]),t._v(" "),e("dt",[t._v("Xen backend network device\nCONFIG_XEN_NETDEV_BACKEND")]),t._v(" "),e("dd",[t._v('XEN 半虚拟化网络设备后端驱动, 通常被用在 "domain 0" 内核上, 用于向其他 domain 导出半虚拟化网络设备.')]),t._v(" "),e("dt",[t._v("VMware VMXNET3 ethernet driver\nCONFIG_VMXNET3")]),t._v(" "),e("dd",[t._v("VMware vmxnet3 虚拟以太网卡驱动")]),t._v(" "),e("dt",[t._v("FUJITSU Extended Socket Network Device driver\nCONFIG_FUJITSU_ES")]),t._v(" "),e("dd",[t._v("FUJITSU PRIMEQUEST 2000 E2 系列网卡")]),t._v(" "),e("dt",[t._v("Microsoft Hyper-V virtual network driver\nCONFIG_HYPERV_NET")]),t._v(" "),e("dd",[t._v("Microsoft [Hyper-V](http://baike.baidu.com/view/1359943.htm) 虚拟以太网卡驱动")]),t._v(" "),e("dt",[t._v("ISDN support\nCONFIG_ISDN")]),t._v(" "),e("dd",[t._v("上世纪在 ADSL 流行之前曾经有过短暂流行, 但现在已经绝迹了")])])]),t._v(" "),e("dt",[t._v("Open-Channel SSD target support\nCONFIG_NVM")]),t._v(" "),e("dd",[t._v("[Open-channel](http://www.ssdfans.com/?p=628) SSD 是一种遵守 [NVMe](http://diy.pconline.com.cn/611/6111798_all.html) 规范且不使用 [FTL](http://www.tuicool.com/articles/ba6rmi) 技术的固态硬盘. 目前此种 SSD 由于过于前卫还非常罕见. 但是非常有前途.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Open-Channel SSD debugging support\nCONFIG_NVM_DEBUG")]),t._v(" "),e("dd",[t._v('提供 /sys/module/lnvm/parameters/configure_debug 调试接口以允许创建 / 删除 "target". 仅供调试使用.')]),t._v(" "),e("dt",[t._v("Generic NVM manager for Open-Channel SSDs\nCONFIG_NVM_GENNVM")]),t._v(" "),e("dd",[t._v("为 Open-Channel SSD 提供 NVM 介质管理 (media manager) 支持, 也就是将数据存放位置与垃圾回收策略的决定权收归操作系统内核, 以剥夺固态硬盘设备自身的介质管理功能, 或者说允许使用自身不包含介质管理功能的固态硬盘.")]),t._v(" "),e("dt",[t._v("Round-robin Hybrid Open-Channel SSD target\nCONFIG_NVM_RRPC")]),t._v(" "),e("dd",[t._v("允许将 open-channel SSD 在主机上显示为一个块设备: 使用线性映射表实现, 使用基于开销 (cost-based) 的垃圾回收机制, 并对 4K 大小的 IO 操作进行了优化.")])])]),t._v(" "),e("dt",[t._v("Input device support")]),t._v(" "),e("dd",[t._v("输入设备")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Generic input layer (needed for keyboard, mouse, ...)\nCONFIG_INPUT")]),t._v(" "),e("dd",[t._v('通用输入层. 只要你有任何输入设备 (键盘, 鼠标, 手写板, 触摸板, 游戏杆, 方向盘, 游戏键盘...), 就必须选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Export input device LEDs in sysfs\nCONFIG_INPUT_LEDS")]),t._v(" "),e("dd",[t._v('将输入设备上的 LED 指示灯当作标准的 LED 类设备导出到 sysfs 中. 不确定的选 "Y".')]),t._v(" "),e("dt",[t._v("Support for memoryless force-feedback devices\nCONFIG_INPUT_FF_MEMLESS")]),t._v(" "),e("dd",[t._v("游戏玩家使用的[力反馈](http://baike.baidu.com/view/351163.htm)设备, 例如: [Logitech WingMan Force 3D 飞行摇杆](http://www.chiphell.com/forum.php?mod=viewthread&tid=94160), [ThrustMaster FireStorm Dual Power 2](http://www.dansdata.com/images/tmsticks/fsdp480.jpg). 如果你有此类设备, 除了本项之外, 还需要开启特定于硬件的驱动.")]),t._v(" "),e("dt",[t._v("Polled input device skeleton\nCONFIG_INPUT_POLLDEV")]),t._v(" "),e("dd",[t._v('使用轮询机制的输入设备支持, 此项主要是为源码树之外的驱动准备的, 内核自带的驱动若有需要会自动选中. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Sparse keymap support library\nCONFIG_INPUT_SPARSEKMAP")]),t._v(" "),e("dd",[t._v('使用 "sparse keymap" 的输入设备支持, 此项主要是为源码树之外的驱动准备的, 内核自带的驱动若有需要会自动选中. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Matrix keymap support library\nCONFIG_INPUT_MATRIXKMAP")]),t._v(" "),e("dd",[t._v('使用 "matrix keymap" 的输入设备支持, 此项主要是为源码树之外的驱动准备的, 内核自带的驱动若有需要会自动选中. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Mouse interface\nCONFIG_INPUT_MOUSEDEV")]),t._v(" "),e("dd",[t._v("鼠标接口 (/dev/input/mouseX,/dev/input/mice). 用鼠标的必选(包括 USB 鼠标).[提示] 如果系统上有多个鼠标, 那么, mouseX 对应单个特定的鼠标, 而 mice 则是所有鼠标的集合(所有鼠标的事件都会被发送到这个设备文件中).")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Provide legacy /dev/psaux device\nCONFIG_INPUT_MOUSEDEV_PSAUX")]),t._v(" "),e("dd",[t._v('仍然支持传统的 / dev/psaux 接口, 这是为兼容老旧的程序而设置. 选 "N".')]),t._v(" "),e("dt",[t._v("Horizontal screen resolution\nCONFIG_INPUT_MOUSEDEV_SCREEN_X")]),t._v(" "),e("dd",[t._v("作为鼠标使用的数字化转换器 (digitizer) 或[手写板](http://www.youliv.com/products/700187.aspx) (graphic tablet) 需要知道 X window 的水平分辩率. 一般可理解为显示屏的水平分辨率.")]),t._v(" "),e("dt",[t._v("Vertical screen resolution\nCONFIG_INPUT_MOUSEDEV_SCREEN_Y")]),t._v(" "),e("dd",[t._v("作为鼠标使用的数字化转换器 (digitizer) 或[手写板](http://www.zgcprice.org/pic/multipic/l/041500555/0415005550031_634109858768281250.jpg) (graphic tablet) 需要知道 X window 的垂直分辩率. 一般可理解为显示屏的垂直分辨率.")])])]),t._v(" "),e("dt",[t._v("Joystick interface\nCONFIG_INPUT_JOYDEV")]),t._v(" "),e("dd",[t._v("游戏杆 ([joystick](http://en.wikipedia.org/wiki/Joystick)) 和游戏键盘 ([gamepad](http://en.wikipedia.org/wiki/Gamepad)) 支持 (/dev/input/jsX)")]),t._v(" "),e("dt",[t._v("Event interface\nCONFIG_INPUT_EVDEV")]),t._v(" "),e("dd",[t._v('将所有的输入设备事件都通过 "/dev/input/eventX" 以一种通用的方式进行处理. Xorg 需要使用此接口. 不确定的选 "Y".')]),t._v(" "),e("dt",[t._v("Event debugging\nCONFIG_INPUT_EVBUG")]),t._v(" "),e("dd",[t._v('将所有输入设备的动作 (键盘按下, 鼠标移动等) 都记录到系统日志当中. 主要用于调试, 同时也会带来安全漏洞(键盘输入中很可能包含你的密码). 选 "N".')]),t._v(" "),e("dt",[t._v("Keyboards\nCONFIG_INPUT_KEYBOARD")]),t._v(" "),e("dd",[t._v("键盘驱动")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("AT keyboard\nCONFIG_KEYBOARD_ATKBD")]),t._v(" "),e("dd",[t._v('标准 AT 键盘或者 [PS/2](http://baike.baidu.com/view/1110237.htm) 键盘.[提示]除了台式机 PS/2 接口上的键盘外, 许多笔记本的键盘其实也是 PS/2 键盘. 使用 USB 键盘或者 ADB 键盘 (旧式苹果键盘) 的可以选 "N".')]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处被省略的键盘都很罕见, 基本上不必考虑}")])])]),t._v(" "),e("dt",[t._v("Mice\nCONFIG_INPUT_MOUSE")]),t._v(" "),e("dd",[t._v("鼠标驱动")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("PS/2 mouse\nCONFIG_MOUSE_PS2")]),t._v(" "),e("dd",[t._v('标准的两键或三键的 [PS/2](http://zh.wikipedia.org/wiki/PS/2%E6%8E%A5%E5%8F%A3) 鼠标, 同时兼容 Microsoft/Logitech/Genius 生产的带有滚轮或者额外按键的 PS/2 鼠标. 使用 Synaptics/ALPS/Elantech 触摸板的用户还可以看看其[专用的 X 驱动](http://xorg.freedesktop.org/archive/individual/driver/), 这些驱动可以提供更多的高级功能. 使用 USB 鼠标的可以选 "N". 其下的子项是针对各厂商特定产品的扩展协议支持. 按需选择即可.[提示] 除了台式机 PS/2 接口上的鼠标外, 许多笔记本的触摸板其实也是 PS/2 鼠标.')]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处被省略的鼠标都很罕见, 基本上不必考虑}")])])]),t._v(" "),e("dt",[t._v("Joysticks/Gamepads\n")]),t._v(" "),e("dd",[t._v("游戏杆, 6 自由度摇杆, 游戏键盘, 方向盘, 射击武器... 等各种游戏装置")]),t._v(" "),e("dt",[t._v("Tablets\nCONFIG_INPUT_TABLET")]),t._v(" "),e("dd",[t._v("平板输入设备")]),t._v(" "),e("dt",[t._v("Touchscreens\nCONFIG_INPUT_TOUCHSCREEN")]),t._v(" "),e("dd",[t._v("触摸屏输入设备")]),t._v(" "),e("dt",[t._v("Miscellaneous devices\nCONFIG_INPUT_MISC")]),t._v(" "),e("dd",[t._v("其他杂项输入设备")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("PC Speaker support\nCONFIG_INPUT_PCSPKR")]),t._v(" "),e("dd",[t._v("标准[蜂鸣器](http://www.help315.com.cn/ask/htmldata/detail/2010/03/04/93.html). 建议开启.")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处被省略的其他设备都很罕见, 基本上不必考虑}")])])])])]),t._v(" "),e("dt",[t._v("Hardware I/O ports")]),t._v(" "),e("dd",[t._v("硬件 I/O 端口")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Serial I/O support\nCONFIG_SERIO")]),t._v(" "),e("dd",[t._v('串行 I/O 硬件支持. 标准 AT 键盘, PS/2 鼠标, 串口鼠标, Sun 键盘, 游戏杆, 6 自由度摇杆等设备都依赖于它. 不确定的选 "Y".')]),t._v(" "),e("dt",[t._v("i8042 PC Keyboard controller\nCONFIG_SERIO_I8042")]),t._v(" "),e("dd",[t._v("标准 AT 键盘, PS/2 鼠标, 这两种设备需要它的支持.")]),t._v(" "),e("dt",[t._v("Serial port line discipline\nCONFIG_SERIO_SERPORT")]),t._v(" "),e("dd",[t._v("RS232 串口 (COM). 串口鼠标, 游戏杆, 6 自由度摇杆等设备都依赖于它.")]),t._v(" "),e("dt",[t._v("ct82c710 Aux port controller\nCONFIG_SERIO_CT82C710")]),t._v(" "),e("dd",[t._v("一种德州仪器 TravelMate 笔记本上使用 QuickPort 接口的鼠标")]),t._v(" "),e("dt",[t._v("Parallel port keyboard adapter\nCONFIG_SERIO_PARKBD")]),t._v(" "),e("dd",[t._v("并口键盘适配器, 用于将 AT/XT 键盘或 PS/2 鼠标转接到并口上. 非常罕见.")]),t._v(" "),e("dt",[t._v("PCI PS/2 keyboard and PS/2 mouse controller\nCONFIG_SERIO_PCIPS2")]),t._v(" "),e("dd",[t._v("接在移动式扩展坞 (Docking station) 上的 PS/2 键盘或鼠标")]),t._v(" "),e("dt",[t._v("PS/2 driver library\nCONFIG_SERIO_LIBPS2")]),t._v(" "),e("dd",[t._v("为 PS/2 接口上的设备提供驱动 (比如 PS/2 鼠标和标准 AT 键盘)")]),t._v(" "),e("dt",[t._v("Raw access to serio ports\nCONFIG_SERIO_RAW")]),t._v(" "),e("dd",[t._v('以 raw 方式访问 serio 接口 (echo -n "serio_raw"> /sys/bus/serio/devices/serioX/drvctl), 例如 i8042 键盘控制器的 AUX 端口. 看不懂的就别选了.')]),t._v(" "),e("dt",[t._v("Altera UP PS/2 controller\nCONFIG_SERIO_ALTERA_PS2")]),t._v(" "),e("dd",[t._v('Altera University Program PS/2 端口支持. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("TQC PS/2 multiplexer\nCONFIG_SERIO_PS2MULT")]),t._v(" "),e("dd",[t._v("TQC 板上的 PS/2 端口复用器 (multiplexer)")]),t._v(" "),e("dt",[t._v("ARC PS/2 support\nCONFIG_SERIO_ARC_PS2")]),t._v(" "),e("dd",[t._v("ARC FPGA 平台上的 PS/2 控制器")]),t._v(" "),e("dt",[t._v("Gameport support\nCONFIG_GAMEPORT")]),t._v(" "),e("dd",[t._v("15 针电脑游戏接口 ([Gameport](http://en.wikipedia.org/wiki/Game_port)). [图](http://content.answcdn.com/main/content/img/CDE/_PCPORTS.JPG)")])])])])]),t._v(" "),e("dt",[t._v("Character devices")]),t._v(" "),e("dd",[t._v("[字符设备](http://baike.baidu.com/view/1913432.htm)")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable TTY\nCONFIG_TTY")]),t._v(" "),e("dd",[t._v('字符终端和串口都需要 [TTY](http://baike.baidu.com/view/749979.htm) 的支持. 选 "Y", 除非你知道自己在干什么.[提示] 你想[在控制台上显示汉字](http://www.ibm.com/developerworks/cn/linux/l-cn-termi-hanzi/index.html)吗? 试试 [CJKTTY](https://github.com/gentoo-zh/linux-cjktty/) 补丁吧!')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Virtual terminal\nCONFIG_VT")]),t._v(" "),e("dd",[t._v('[虚拟终端](http://baike.baidu.com/view/694267.htm)可以在一个物理终端设备上虚拟出多个 "显示器 + 键盘" 的组合 (可以使用 "Alt+Fn" 组合键在多个虚拟终端间切换). 除非是嵌入式系统, 否则必选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable character translations in console\nCONFIG_CONSOLE_TRANSLATIONS")]),t._v(" "),e("dd",[t._v('在虚拟控制台 (console) 上支持字体映射和 Unicode 转换. 建议选 "Y", 否则将无法在控制台上显示 Unicode 字符.[提示]如果已经使用了 [CJKTTY](https://github.com/gentoo-zh/linux-cjktty/) 补丁, 则必选 "Y".')]),t._v(" "),e("dt",[t._v("Support for console on virtual terminal\nCONFIG_VT_CONSOLE")]),t._v(" "),e("dd",[t._v('内核默认将第一个虚拟终端 (/dev/tty0) 用作系统控制台(可以通过 "console=tty3" 这样的参数去修改), 将诸如模块错误 / 内核错误 / 启动信息之类的警告信息发送到这里, 而且以单用户模式登录时也需要使用这个控制台. 若选 "N" 则会导致黑屏. 除非是嵌入式系统, 否则必选 "Y".')]),t._v(" "),e("dt",[t._v("Support for binding and unbinding console drivers\nCONFIG_VT_HW_CONSOLE_BINDING")]),t._v(" "),e("dd",[t._v('虚拟终端是通过控制台驱动程序与物理终端交互的, 但在某些系统上可以使用多个控制台驱动程序 (如 framebuffer 控制台驱动程序), 该选项使得你可以选择其中之一. 如果你需要使用多个控制台驱动, 可以选 "Y", 不确定的选 "N". 参见 "[Documentation/console/console.txt](https://www.kernel.org/doc/Documentation/console/console.txt)"和"[Documentation/fb/fbcon.txt](https://www.kernel.org/doc/Documentation/fb/fbcon.txt)" 获取更多细节.')])])]),t._v(" "),e("dt",[t._v("Unix98 PTY support\nCONFIG_UNIX98_PTYS")]),t._v(" "),e("dd",[t._v('伪终端 (PTY) 是指一个 "软件终端", 它是由 slave(等价于一个物理终端)和 master(被一个诸如 xterm 之类的进程用来读写 slave 设备)两部分组成的软设备. 图形界面用户与需要支持 ssh/telnet 远程登录者必选.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Support multiple instances of devpts\nCONFIG_DEVPTS_MULTIPLE_INSTANCES")]),t._v(" "),e("dd",[t._v('允许多个 "devpts" 文件系统实例 (使用 "-o newinstance" 挂载选项), 以允许相互隔离的 PTY 命名空间 (比如在虚拟化容器中).Docker 依赖于它. systemd 的 PrivateNetwork/PrivateDevices 特性依赖于它.')])])]),t._v(" "),e("dt",[t._v("Legacy (BSD) PTY support\nCONFIG_LEGACY_PTYS")]),t._v(" "),e("dd",[t._v('使用过时的 BSD 风格的 / dev/ptyxx 作为 master,/dev/ttyxx 作为 slave, 这个方案有一些安全问题, 选 "N".')]),t._v(" "),e("dt",[t._v("Non-standard serial port support\nCONFIG_SERIAL_NONSTANDARD")]),t._v(" "),e("dd",[t._v('非标准串口支持. 这样的设备非常罕见, 选 "N".')]),t._v(" "),e("dt",[t._v("HSDPA Broadband Wireless Data Card - Globe Trotter\nCONFIG_NOZOMI")]),t._v(" "),e("dd",[t._v("一种 PCMCIA 接口的 [HSDPA](http://baike.baidu.com/view/10159.htm)(WCDMA) 3G 无线上网卡")]),t._v(" "),e("dt",[t._v("Multi-Tech multiport card support\nCONFIG_ISI")]),t._v(" "),e("dd",[t._v('[Multi-Tech](http://www.multi-tech.com.hk/) 公司生产的多端口卡 (拥有多个串口) 实验性支持. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("HDLC line discipline support\nCONFIG_N_HDLC")]),t._v(" "),e("dd",[t._v('Microgate SyncLink. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("GSM MUX line discipline support\nCONFIG_N_GSM")]),t._v(" "),e("dd",[t._v('GSM MUX(多路复用器) 支持. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Trace data router for MIPI P1149.7 cJTAG standard\nCONFIG_TRACE_ROUTER")]),t._v(" "),e("dd",[t._v("仅用于调试内含 modem 设备的手机系统.")]),t._v(" "),e("dt",[t._v("Trace data sink for MIPI P1149.7 cJTAG standard\nCONFIG_TRACE_SINK")]),t._v(" "),e("dd",[t._v("仅用于调试内含 modem 设备的手机系统.")])])]),t._v(" "),e("dt",[t._v("KCopy")]),t._v(" "),e("dd",[t._v("内核 Copy")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Memory-to-memory copies using kernel assist\nCONFIG_KCOPY")]),t._v(" "),e("dd",[t._v('高性能的进程间内存复制 (可以减少一次向共享内存的复制动作). 主要用于高性能并行计算领域, 比如基于[消息传递接口](http://zh.wikipedia.org/wiki/%E8%A8%8A%E6%81%AF%E5%82%B3%E9%81%9E%E4%BB%8B%E9%9D%A2) ([Message Passing Interface](http://wenku.baidu.com/view/ee8bf3390912a216147929f3.html)) 协议的开发的并行程序. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("/dev/mem virtual device support\nCONFIG_DEVMEM")]),t._v(" "),e("dd",[t._v('"[/dev/mem](http://blog.csdn.net/skyflying2012/article/details/47611399)" 虚拟设备是整个处理器地址空间的全映射 (包括所有物理内存 / 设备 IO 空间 / 总线映射空间), 可以用来直接存取物理内存, 常用于访问物理 IO 设备, 例如 [dmidecode](http://www.ha97.com/4120.html) 工具可以从中提取系统识别信息 (序列号, 制造商, 型号, 等等), 或者 Xorg 可以用来访问显卡的物理内存或者[实现用户空间驱动](http://blog.csdn.net/su_linux/article/details/8737690), 同时拥有 root 权限的攻击者也可以使用它完成很多标准 rootkit 的行为. 如果你需要使用用户空间的驱动或不确定, 那么选 "Y". 如果你觉得安全特别重要, 可以选 "N".')]),t._v(" "),e("dt",[t._v("/dev/kmem virtual device support\nCONFIG_DEVKMEM")]),t._v(" "),e("dd",[t._v('"/dev/kmem" 虚拟设备是内核看到的虚拟内存的全镜像, 可以用来访问内核内存. 一般可以用来查看内核变量或者用作 rootkit 之类 (! 危险!). 仅供调试, 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Serial drivers")]),t._v(" "),e("dd",[t._v('[串口](http://zh.wikipedia.org/zh-cn/%E4%B8%B2%E8%A1%8C%E7%AB%AF%E5%8F%A3) (COM) 驱动. 串口在台式机主板上正在逐渐消亡, 而在笔记本和服务器上早就已经绝迹了. 大多数人应该将所有子项都选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("8250/16550 and compatible serial support\nCONFIG_SERIAL_8250")]),t._v(" "),e("dd",[t._v('这是标准[串口 (COM)](http://zh.wikipedia.org/zh-cn/%E4%B8%B2%E8%A1%8C%E7%AB%AF%E5%8F%A3) 驱动. 只要你想使用串口, 就必选此项. 不过, 大多数人应该选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Support 8250_core.* kernel options\nCONFIG_SERIAL_8250_DEPRECATED_OPTIONS")]),t._v(" "),e("dd",[t._v('选 "N".')]),t._v(" "),e("dt",[t._v("8250/16550 PNP device support\nCONFIG_SERIAL_8250_PNP")]),t._v(" "),e("dd",[t._v('即插即用串口支持, 不确定的选 "Y".')]),t._v(" "),e("dt",[t._v("Console on 8250/16550 and compatible serial port\nCONFIG_SERIAL_8250_CONSOLE")]),t._v(" "),e("dd",[t._v('将串口当做系统控制台 (接受所有内核消息, 单用户模式登录) 使用(需要使用 "console=ttyS1" 参数). 仅在没有显示接口嵌入式设备上有用. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("DMA support for 16550 compatible UART controllers\nCONFIG_SERIAL_8250_DMA")]),t._v(" "),e("dd",[t._v('与标准 8250/16650 兼容的[通用异步收发传输器](http://baike.baidu.com/view/245027.htm) ([Universal Asynchronous Receiver/Transmitter](http://zh.wikipedia.org/wiki/UART)) 的 [DMA](http://zh.wikipedia.org/wiki/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96) 支持. 在嵌入式设计中, UART 用来主机与辅助设备通信, 如汽车音响与外接 AP 之间的通信, 与 PC 机通信包括与监控调试器和其它器件 (如 EEPROM) 通信. 不确定的选 "Y".')]),t._v(" "),e("dt",[t._v("8250/16550 PCI device support\nCONFIG_SERIAL_8250_PCI")]),t._v(" "),e("dd",[t._v('PCI 串口支持. 选 "N" 表示仅支持传统的标准串口.')]),t._v(" "),e("dt",[t._v("8250/16550 PCMCIA device support\nCONFIG_SERIAL_8250_CS")]),t._v(" "),e("dd",[t._v('16-bit PCMCIA 串口支持. 选 "N" 表示仅支持传统的标准串口.')]),t._v(" "),e("dt",[t._v("Maximum number of 8250/16550 serial ports\nCONFIG_SERIAL_8250_NR_UARTS")]),t._v(" "),e("dd",[t._v("允许的最大串口数量, 保持默认值即可.")]),t._v(" "),e("dt",[t._v("Number of 8250/16550 serial ports to register at runtime\nCONFIG_SERIAL_8250_RUNTIME_UARTS")]),t._v(" "),e("dd",[t._v('内核在启动时注册的串口数量 (可以通过 "8250.nr_uarts" 参数修改), 保持默认即可.')]),t._v(" "),e("dt",[t._v("Extended 8250/16550 serial driver options\nCONFIG_SERIAL_8250_EXTENDED")]),t._v(" "),e("dd",[t._v('非标准的串口驱动选项 (例如 HUB6, 中断共享, 多端口, 超过 4 个 COM 口). 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Support more than 4 legacy serial ports\nCONFIG_SERIAL_8250_MANY_PORTS")]),t._v(" "),e("dd",[t._v('如果你的板子上有超过 4 个 COM 接口就选 "Y".')]),t._v(" "),e("dt",[t._v("Support for sharing serial interrupts\nCONFIG_SERIAL_8250_SHARE_IRQ")]),t._v(" "),e("dd",[t._v('有些板子上集成了共享 IRQ 的硬件支持. 如果有就选 "Y".')]),t._v(" "),e("dt",[t._v("Autodetect IRQ on standard ports (unsafe)\nCONFIG_SERIAL_8250_DETECT_IRQ")]),t._v(" "),e("dd",[t._v('让内核去猜串口的 IRQ 号. 不安全, 选 "N".')]),t._v(" "),e("dt",[t._v("Support RSA serial ports\nCONFIG_SERIAL_8250_RSA")]),t._v(" "),e("dd",[t._v('RSA(Remote Supervisor Adapter) 串口, 是一种 IBM 特定的硬件. 看不懂的选 "N".')])])]),t._v(" "),e("dt",[t._v("Support for Synopsys DesignWare 8250 quirks\nCONFIG_SERIAL_8250_DW")]),t._v(" "),e("dd",[t._v("Synopsys DesignWare APB UART 中非标准特性的支持.")]),t._v(" "),e("dt",[t._v("Medfield High Speed UART support\nCONFIG_SERIAL_MFD_HSU")]),t._v(" "),e("dd",[t._v("[Medfield](http://baike.baidu.com/view/5112631.htm) 是 Intel 以 x86 为架构开发的 SoC 手机芯片.")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处被省略的都是非标准的串口设备, 按实际情况选择即可}")])])]),t._v(" "),e("dt",[t._v("TTY driver to output user messages via printk\nCONFIG_TTY_PRINTK")]),t._v(" "),e("dd",[t._v('通过 "/dev/ttyprintk" 设备使用 printk 发送用户消息. 用于在内核中嵌入用户消息. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Parallel printer support\nCONFIG_PRINTER")]),t._v(" "),e("dd",[t._v("并口打印机")]),t._v(" "),e("dt",[t._v("Support for user-space parallel port device drivers\nCONFIG_PPDEV")]),t._v(" "),e("dd",[t._v("用户空间的原始并口设备 (/dev/parportN) 支持, 这样用户空间的程序就可以用原始模式直接访问并口(相当于并口版本的 CONFIG_CHR_DEV_SG). 并口打印机 / CD-ROM / 硬盘都不依赖于此项, 所以大部分人可以关闭该选项.")]),t._v(" "),e("dt",[t._v("Xen Hypervisor Console support\nCONFIG_HVC_XEN")]),t._v(" "),e("dd",[t._v("XEN 虚拟控制台设备驱动")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Xen Hypervisor Multiple Consoles support\nCONFIG_HVC_XEN_FRONTEND")]),t._v(" "),e("dd",[t._v('如果你需要多个虚拟控制台, 可以选 "Y".')])])]),t._v(" "),e("dt",[t._v("Virtio console\nCONFIG_VIRTIO_CONSOLE")]),t._v(" "),e("dd",[t._v("[Virtio](http://www.ibm.com/developerworks/cn/linux/l-virtio/) 虚拟控制台设备驱动. 此外, 该驱动还可以作为普通的串口设备 (/dev/vportNpX), 用于客户机和宿主机之间的通信. 仅可用在基于 [lguest](http://lguest.ozlabs.org/) 或 [QEMU](http://wiki.qemu.org/Main_Page) 的半虚拟化客户机中 (一般是 [KVM](http://wiki.ubuntu.org.cn/Kvm%E6%95%99%E7%A8%8B) 或 [XEN](http://zh.wikipedia.org/zh-cn/Xen)).")]),t._v(" "),e("dt",[t._v("IPMI top-level message handler\nCONFIG_IPMI_HANDLER")]),t._v(" "),e("dd",[t._v('[智能平台管理接口](http://blog.csdn.net/yuxiaohui78/article/details/7585280) ([Intelligent Platform Management Interface](http://baike.baidu.com/view/1595174.htm))是标准的传感器 (温度, 电压, 风扇, 电源, 机箱入侵) 管理规范. IPMI 的核心是专用的基板管理控制器 (BMC) 硬件, BMC 并不依赖于服务器的 CPU/BIOS/OS, 是一个独立运行的管理子系统, 只要有 BMC 与 IPMI 固件便可工作. BMC 通常是一个安装在服务器主板上的独立的板卡(也有少数服务器主板内置).IPMI 良好的独立特性便克服了以往基于操作系统的管理方式所受的限制, 例如操作系统不响应或未加载的情况下, 仍然可以进行开关机等操作. 更多详情参见 "[Documentation/IPMI.txt](https://www.kernel.org/doc/Documentation/IPMI.txt)" 文档. 此项技术主要用于服务器领域, 个人 PC 和笔记本上是没有的.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Generate a panic event to all BMCs on a panic\nCONFIG_IPMI_PANIC_EVENT")]),t._v(" "),e("dd",[t._v("当内核 panic(发生紧急情况)时, IPMI 消息处理器将会向每一个已注册的底板管理控制器 (BMC) 接口生成一个描述该 panic 的 IPMI 事件, 这些事件可以引发日志记录 / 报警 / 重启 / 关机等动作.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Generate OEM events containing the panic string\nCONFIG_IPMI_PANIC_STRING")]),t._v(" "),e("dd",[t._v("当发生紧急情况 (panic) 时, IPMI 消息处理器将会产生 OEM 类型 (f0) 的事件")])])]),t._v(" "),e("dt",[t._v("Device interface for IPMI\nCONFIG_IPMI_DEVICE_INTERFACE")]),t._v(" "),e("dd",[t._v("为 IPMI 消息处理器提供一个 IOCTL 接口以便用户空间进程也可以使用 IPMI, 目前支持 poll() 和 select()")]),t._v(" "),e("dt",[t._v("IPMI System Interface handler\nCONFIG_IPMI_SI")]),t._v(" "),e("dd",[t._v('向系统提供接口 (KCS,SMIC), 建议选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Probe for all possible IPMI system interfaces by default\nCONFIG_IPMI_SI_PROBE_DEFAULTS")]),t._v(" "),e("dd",[t._v('较新的硬件通常使用 ACPI 或 DMI 机制导出 IPMI 接口, 但是老旧的硬件并不这么做, 所以驱动程序必须直接探测硬件, 这会导致启动延迟. 选 "N" 表示禁止直接探测. 选 "Y" 表示强制直接探测 (相当于使用 "ipmi_si_intf.trydefaults=1" 内核引导选项).')])])]),t._v(" "),e("dt",[t._v("IPMI SMBus handler (SSIF)\nCONFIG_IPMI_SSIF")]),t._v(" "),e("dd",[t._v('使用 I2C 总线上的 SMBus 接口访问 BMC(而不是标准接口). 建议选 "N".')]),t._v(" "),e("dt",[t._v("IPMI Watchdog Timer\nCONFIG_IPMI_WATCHDOG")]),t._v(" "),e("dd",[t._v('启用 IPMI Watchdog 定时器. 如果硬件有这种功能, 推荐选 "Y".')]),t._v(" "),e("dt",[t._v("IPMI Poweroff\nCONFIG_IPMI_POWEROFF")]),t._v(" "),e("dd",[t._v("允许通过 IPMI 消息处理器关闭机器")])])]),t._v(" "),e("dt",[t._v("Hardware Random Number Generator Core support\nCONFIG_HW_RANDOM")]),t._v(" "),e("dd",[t._v('硬件随机数发生器设备 (/dev/hw_random) 支持. 此设备并不会直接向内核的随机数发生器填充(这是 "[rngd](http://linux.die.net/man/8/rngd)"守护进程的职责). 详情参见"[Documentation/hw_random.txt](https://www.kernel.org/doc/Documentation/hw_random.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Timer IOMEM HW Random Number Generator support\nCONFIG_HW_RANDOM_TIMERIOMEM")]),t._v(" "),e("dd",[t._v("Technologic Systems 的 TS-7800 单板计算机, 这是一个嵌入式设备.")]),t._v(" "),e("dt",[t._v("Intel HW Random Number Generator support\nCONFIG_HW_RANDOM_INTEL")]),t._v(" "),e("dd",[t._v("Intel 基于 i8xx 芯片组 (这是 2005 年以前的老产品了) 的硬件随机数发生器")]),t._v(" "),e("dt",[t._v("AMD HW Random Number Generator support\nCONFIG_HW_RANDOM_AMD")]),t._v(" "),e("dd",[t._v("AMD 基于 76x 芯片组的硬件随机数发生器")]),t._v(" "),e("dt",[t._v("Atmel Random Number Generator support\nCONFIG_HW_RANDOM_ATMEL")]),t._v(" "),e("dd",[t._v("Atmel AT91 硬件随机数发生器")]),t._v(" "),e("dt",[t._v("VIA HW Random Number Generator support\nCONFIG_HW_RANDOM_VIA")]),t._v(" "),e("dd",[t._v("VIA 芯片组的硬件随机数发生器")]),t._v(" "),e("dt",[t._v("VirtIO Random Number Generator support\nCONFIG_HW_RANDOM_VIRTIO")]),t._v(" "),e("dd",[t._v("[Virtio](http://www.ibm.com/developerworks/cn/linux/l-virtio/) 虚拟的硬件随机数发生器. 仅可用在基于 [lguest](http://lguest.ozlabs.org/) 或 [QEMU](http://wiki.qemu.org/Main_Page) 的半虚拟化客户机中 (一般是 [KVM](http://wiki.ubuntu.org.cn/Kvm%E6%95%99%E7%A8%8B) 或 [XEN](http://zh.wikipedia.org/zh-cn/Xen)).")])])]),t._v(" "),e("dt",[t._v("EXYNOS HW random number generator support\nCONFIG_HW_RANDOM_EXYNOS")]),t._v(" "),e("dd",[t._v("基于 [EXYNOS](http://baike.baidu.com/view/5821967.htm) 的 SOC 嵌入式系统上的硬件随机数发生器")]),t._v(" "),e("dt",[t._v("TPM HW Random Number Generator support\nCONFIG_HW_RANDOM_TPM")]),t._v(" "),e("dd",[t._v("[可信赖平台模块](http://baike.baidu.com/view/1130324.htm) ([Trusted Platform Module](http://baike.baidu.com/view/687208.htm)) 提供的硬件随机数发生器")]),t._v(" "),e("dt",[t._v("/dev/nvram support\nCONFIG_NVRAM")]),t._v(" "),e("dd",[t._v('直接存取主板上 "CMOS RAM" 的接口, 太危险! 建议选 "N".')]),t._v(" "),e("dt",[t._v("Siemens R3964 line discipline\nCONFIG_R3964")]),t._v(" "),e("dd",[t._v("与使用西门子 R3964 协议的设备同步通信, 除非你有一些诸如 PLC 之类的特殊设备, 否则别选")]),t._v(" "),e("dt",[t._v("Applicom intelligent fieldbus card support\nCONFIG_APPLICOM")]),t._v(" "),e("dd",[t._v('Applicom international 公司生产的用于现场总线 (fieldbus) 的连接卡. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("PCMCIA character devices")]),t._v(" "),e("dd",[t._v("PCMCIA 接口的字符设备")]),t._v(" "),e("dt",[t._v("ACP Modem (Mwave) support\nCONFIG_MWAVE")]),t._v(" "),e("dd",[t._v("IBM Thinkpad 上的一种软猫, 古董产品")]),t._v(" "),e("dt",[t._v("RAW driver (/dev/raw/rawN)\nCONFIG_RAW_DRIVER")]),t._v(" "),e("dd",[t._v('[裸设备](http://czmmiao.iteye.com/blog/1587170)的含义是将一个原始块设备 (可以是一整块磁盘, 也可以是一个分区) 当做一个线性的字节流来访问. 它是一种没有经过格式化, 不经过操作系统缓存, 也不能通过文件系统来访问的特殊字符设备. 与 FreeBSD 不同, Linux 反对使用裸设备, 且被列入了废除计划(建议的做法是使用 "O_DIRECT" 标志打开对应的块设备文件, 例如 "/dev/hda1"). 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("HPET - High Precision Event Timer\nCONFIG_HPET")]),t._v(" "),e("dd",[t._v('高精度事件定时器 ([HPET Timer](http://en.wikipedia.org/wiki/High_Precision_Event_Timer)), 又被称为 "Multimedia Timer", 是一种取代传统 "ACPI Timer"(CONFIG_X86_PM_TIMER) 的硬件时钟发生器, 提供 14.31818MHz 固定频率. 2007 年以后的芯片组一般都支持 (有的主板还需要在 BIOS 里面明确开启 HPET 支持), 建议开启.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Allow mmap of HPET\nCONFIG_HPET_MMAP")]),t._v(" "),e("dd",[t._v('允许对 HPET 寄存器进行映射以提高访问速度. 但是某些包含 HPET 硬件寄存器的页中同时还含有其他不该暴露给用户的信息, 在此种情况下, 需要选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable HPET MMAP access by default\nCONFIG_HPET_MMAP_DEFAULT")]),t._v(" "),e("dd",[t._v("默认开启 HPET 寄存器映射")])])])])]),t._v(" "),e("dt",[t._v("Hangcheck timer\nCONFIG_HANGCHECK_TIMER")]),t._v(" "),e("dd",[t._v('宕机检测定时器周期性地检查系统任务调度程序以确定系统的运行状况, 如果超过阈值, 计算机将重新启动. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("TPM Hardware Support\nCONFIG_TCG_TPM")]),t._v(" "),e("dd",[t._v("基于硬件的[可信赖平台模块](http://baike.baidu.com/view/1130324.htm) ([Trusted Platform Module](http://baike.baidu.com/view/687208.htm)), 它实际上是一个含有密码运算部件和存储部件的小芯片上的系统, 由 CPU, 存储器, I/O, 密码运算器, 随机数产生器和嵌入式操作系统等部件组成. 使用此功能需要 [TrouSerS](http://sourceforge.net/projects/trousers/) 工具的帮助.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("TPM Interface Specification 1.2 Interface\nCONFIG_TCG_TIS")]),t._v(" "),e("dd",[t._v("TCG TIS 1.2 TPM 规范支持")]),t._v(" "),e("dt",[t._v("TPM Interface Specification 1.2 Interface (I2C - Infineon)\nCONFIG_TCG_TIS_I2C_INFINEON")]),t._v(" "),e("dd",[t._v('仅需要对 Infineon 的 TPM 设备选 "Y".')]),t._v(" "),e("dt",[t._v("National Semiconductor TPM Interface\nCONFIG_TCG_NSC")]),t._v(" "),e("dd",[t._v('仅需要对 National 的 TPM 设备选 "Y".')]),t._v(" "),e("dt",[t._v("Atmel TPM Interface\nCONFIG_TCG_ATMEL")]),t._v(" "),e("dd",[t._v('仅需要对 Atmel 的 TPM 设备选 "Y".')]),t._v(" "),e("dt",[t._v("Infineon Technologies TPM Interface\nCONFIG_TCG_INFINEON")]),t._v(" "),e("dd",[t._v('仅需要对 Infineon 的 TPM 设备 (SLD 9630 TT 1.1 或 SLB 9635 TT 1.2) 选 "Y". 此驱动支持的[硬件列表](http://www.trust.rub.de/projects/linux-device-driver-infineon-tpm/).')]),t._v(" "),e("dt",[t._v("STMicroelectronics ST33 I2C TPM\nCONFIG_TCG_ST33_I2C")]),t._v(" "),e("dd",[t._v("[意法半导体](http://www.st.com/web/cn/home.html) (STMicroelectronics) 出品的 I2C 总线的 TPM 安全芯片.")])])]),t._v(" "),e("dt",[t._v("Telecom clock driver for ATCA SBC\nCONFIG_TELCLOCK")]),t._v(" "),e("dd",[t._v('没见过这种硬件, 选 "N".')]),t._v(" "),e("dt",[t._v("Xillybus generic FPGA interface\nCONFIG_XILLYBUS")]),t._v(" "),e("dd",[t._v("[Xillybus](http://www.xillybus.com/) 是一个通用的 [FPGA](http://baike.baidu.com/view/51371.htm) 接口, 仅用于嵌入式设备.")])])]),t._v(" "),e("dt",[t._v("I2C support\nCONFIG_I2C")]),t._v(" "),e("dd",[t._v('[I2C 与 SMBus](http://blog.sina.com.cn/s/blog_697e8abb0100m5mf.html) 支持.[I2C](http://blog.csdn.net/apple_guet/article/details/21379425)(读着 "I-squared-C") 是用于[单片机](http://zh.wikipedia.org/wiki/%E5%8D%95%E7%89%87%E6%9C%BA) (又称 "微控制器") 的低速串行总线协议, 它为[微控制器](http://zhidao.baidu.com/question/221932968.html) (Microcontroller) 与各种不同的低速设备通信提供了一种廉价的总线 (因为只需要使用两个引脚, 称为 "2 线"), 因此广泛的应用于嵌入式环境.[SMBus](http://baike.baidu.com/view/1835675.htm)(System Management Bus)差不多相当于是 I2C 的子集, 最初的目的是为了管理智能电池, 现在常用于硬件监控 (电压 / 风扇转速 / 温度 / 电池等) 以及内存模块的配置(使用 I2C EEPROM), 因此所有 PC 主板都依赖于 SMBus 协议. 系统硬件监控工具 [lm_sensors](http://www.lm-sensors.org/) 和 [i2c-tools](http://www.lm-sensors.org/wiki/I2CTools) 依赖于此模块, 硬件传感器和 "Video For Linux" 也需要该模块的支持. 详情参见 "[Documentation/i2c/summary](https://www.kernel.org/doc/Documentation/i2c/summary)"文档及整个"i2c"文件夹. 不确定的选"Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("ACPI I2C Operation region support\nCONFIG_ACPI_I2C_OPREGION")]),t._v(" "),e("dd",[t._v("3.17 版内核新增功能, 允许 BIOS 中的代码通过 I2C 主机控制器驱动访问 I2C slave 设备 (例如智能电池).")]),t._v(" "),e("dt",[t._v("Enable compatibility bits for old user-space\nCONFIG_I2C_COMPAT")]),t._v(" "),e("dd",[t._v("为了与 lm-sensors 3.1.2 之前的版本兼容而设置. 某些 2011 年之前版本的 i2c 相关程序也需要此兼容性.")]),t._v(" "),e("dt",[t._v("I2C device interface\nCONFIG_I2C_CHARDEV")]),t._v(" "),e("dd",[t._v('I2C 设备通常都是由内核控制的, 但此选项可以向用户空间提供 I2C 设备接口, 以允许用户空间的程序通过 / dev/i2c-* 字符设备文件使用 I2C 总线."[sensors-detect](http://dl.lm-sensors.org/lm-sensors/files/sensors-detect)"工具依赖于此功能. 详情参见"[Documentation/i2c/dev-interface](https://www.kernel.org/doc/Documentation/i2c/dev-interface)"文档. 建议选"M".')]),t._v(" "),e("dt",[t._v("I2C bus multiplexing support\nCONFIG_I2C_MUX")]),t._v(" "),e("dd",[t._v('多路复用 I2C 总线支持. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Multiplexer I2C Chip support")]),t._v(" "),e("dd",[t._v("I2C 多路复用芯片, 其下的子项按实际情况选择就 OK 了")])])]),t._v(" "),e("dt",[t._v("Autoselect pertinent helper modules\nCONFIG_I2C_HELPER_AUTO")]),t._v(" "),e("dd",[t._v('有一些 I2C 驱动程序需要 "I2C algorithm" 的帮助才能工作. 而 "I2C 算法" 本质上是 I2C 接口的纯软件抽象. 开启此项后, 如有需要, 则会自动选上这些算法, 而无需你再手动选择. 推荐选 "Y". 仅在你想使用额外的算法时, 才选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("SMBus-specific protocols\nCONFIG_I2C_SMBUS")]),t._v(" "),e("dd",[t._v('SMBus 特有的扩展支持. 目前唯一实际支持的扩展是 SMBus 报警协议. 建议选 "Y".')])])]),t._v(" "),e("dt",[t._v("I2C Algorithms")]),t._v(" "),e("dd",[t._v("I2C 算法, 子项可以全不选, 若有其他部分依赖其子项时, 会自动选上")]),t._v(" "),e("dt",[t._v("I2C Hardware Bus support")]),t._v(" "),e("dd",[t._v("I2C 硬件支持")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("*** PC SMBus host controller drivers ***")]),t._v(" "),e("dd",[t._v('这部分按照主板芯片组的实际情况选择就 OK 了.[提示] 可用 "[sensors-detect](http://dl.lm-sensors.org/lm-sensors/files/sensors-detect)" 工具帮助检测')]),t._v(" "),e("dt",[t._v("SMBus Control Method Interface\nCONFIG_I2C_SCMI")]),t._v(" "),e("dd",[t._v('[SMBus 控制方法接口](http://wenku.baidu.com/view/f3e3550a763231126edb112a.html) (Control Method Interface) 是 SMBus 的 ACPI 接口. 用于在 ACPI 环境中使用 SMBus 设备. 不确定的选 "M"(i2c-scmi).')]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{其余被省略的都是用于嵌入式系统或者额外的 I2C/SMBus 扩展卡, 按实际情况选择即可}")])])]),t._v(" "),e("dt",[t._v("I2C/SMBus Test Stub\nCONFIG_I2C_STUB")]),t._v(" "),e("dd",[t._v('用于帮助开发 SMBus client 驱动 (特别是某些传感器芯片). 详情参见 "[Documentation/i2c/i2c-stub](https://www.kernel.org/doc/Documentation/i2c/i2c-stub)"文档. 不确定的选"N".')]),t._v(" "),e("dt",[t._v("I2C slave support\nCONFIG_I2C_SLAVE")]),t._v(" "),e("dd",[t._v('[I2C slave 模式](http://www.zybang.com/question/55e97b751975a03c9481271ee78ecff8.html)支持. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("I2C Core debugging messages\nCONFIG_I2C_DEBUG_CORE")]),t._v(" "),e("dd",[t._v("向系统日志中传递大量的 I2C Core 调试信息. 仅用于调试 I2C 设备故障")]),t._v(" "),e("dt",[t._v("I2C Algorithm debugging messages\nCONFIG_I2C_DEBUG_ALGO")]),t._v(" "),e("dd",[t._v("向系统日志中传递大量的 I2C Algorithm 调试信息. 仅用于调试 I2C 设备故障")]),t._v(" "),e("dt",[t._v("I2C Bus debugging messages\nCONFIG_I2C_DEBUG_BUS")]),t._v(" "),e("dd",[t._v("向系统日志中传递大量的 I2C Bus 调试信息. 仅用于调试 I2C 设备故障")])])]),t._v(" "),e("dt",[t._v("SPI support\nCONFIG_SPI")]),t._v(" "),e("dd",[t._v('串行外设接口 (Serial Peripheral Interface) 是一种标准的四线同步双向串行总线.[SPI 类似于 I2C](http://wenku.baidu.com/view/99164c1dfad6195f312ba6e4.html), 但比 I2C 的 "2 线" 稍微复杂一些, SPI 需要 4 个引脚 ("4 线"), 不但传输速率比 I2C 更高, 还能实现全双工通信. 大多数 SPI 设备不支持动态设备检测, 有些甚至是只读或者只写的. SPI 常用于微控制器(Microcontroller) 与外围设备 (RTC, 传感器, EEPROM,FLASH, 解 / 编码器, 模数转换器, 数字信号处理器) 之间的通信, MMC 和 SD 卡也可以通过 SPI 协议访问, 而 MMC 接口的 DataFlash 卡则必须通过 SPI 才能访问. 仅用于嵌入式环境, PC 平台上没有这样的设备.')]),t._v(" "),e("dt",[t._v("SPMI support\nCONFIG_SPMI")]),t._v(" "),e("dd",[t._v("系统电源管理接口 (SPMI, System Power Management Interface) 是一种连接 PMIC(Power Management Integrated Circuits)的双线串行接口. 仅用于嵌入式环境.")]),t._v(" "),e("dt",[t._v("Qualcomm MSM SSBI bus support\nCONFIG_SSBI")]),t._v(" "),e("dd",[t._v("[高通 (Qualcomm) 骁龙](http://www.qualcomm.cn/snapdragon/processors)系列智能手机处理器内嵌的单线串行总线接口 (Single-wire Serial Bus Interface)")]),t._v(" "),e("dt",[t._v("HSI support\nCONFIG_HSI")]),t._v(" "),e("dd",[t._v("高速同步串行接口 ([High speed synchronous Serial Interface](http://www.mipi.org/specifications/high-speed-synchronous-serial-interface-hsi)) 是移动产业处理器接口 ([MIPI](http://zh.wikipedia.org/wiki/MIPI))联盟的高速同步接口工作组发布的一项技术规范. MIPI(Mobile Industry Processor Interface)是 2003 年由 ARM,Nokia,ST,TI 等公司成立的一个联盟, 目的是把手机内部的接口 (如摄像头, 显示屏接口, 射频 / 基带接口等) 标准化, 从而减少手机设计的复杂程度和增加设计灵活性. MIPI 联盟下面有不同的工作组, 分别定义了一系列的手机内部接口标准, 比如摄像头接口 CSI, 显示接口 DSI, 射频接口 DigRF, 麦克风 / 扬声器接口 SLIMbus 等. 统一接口标准的好处是手机厂商根据需要可以从市面上灵活选择不同的芯片和模组, 更改设计和功能时更加快捷方便. 目前, MIPI 联盟的董事成员包括英特尔, 摩托罗拉, 诺基亚, 三星, 意法半导体, 德州仪器.")]),t._v(" "),e("dt",[t._v("PPS support\nCONFIG_PPS")]),t._v(" "),e("dd",[t._v("秒脉冲 (Pulse Per Second) 驱动用来控制电流脉冲速率, 可用于计时. PPS 的精度可以到纳秒级, 而且没有累积误差. 这通常是 GPS 天线的一项功能, 用于获取 GPS 卫星的授时.")]),t._v(" "),e("dt",[t._v("PTP clock support\nCONFIG_PTP_1588_CLOCK")]),t._v(" "),e("dd",[t._v("[精密时间协议](http://wenku.baidu.com/view/004716040740be1e650e9a49) ([Precision Time Protocol](http://en.wikipedia.org/wiki/Precision_Time_Protocol)) 是 [IEEE 1588](http://baike.baidu.com/view/1885838.htm) 定义的一种基于以太网的高精度时间同步协议. PTP 采用硬件与软件结合设计, 可以提供比纯软件方式的 NTP(网络时间协议) 高的多的精度 (微秒级). 与 GPS 授时相比, 在提供和 GPS 相同的精度情况下, PTP 不需要为每个设备安装 GPS 那样昂贵的组件, 只需要一个高精度的本地时钟和提供高精度时钟戳的部件, 成本较低. 一般的 PC 和服务器上没有 PTP 硬件.")]),t._v(" "),e("dt",[t._v("Pin controllers")]),t._v(" "),e("dd",[t._v("Pin 控制器. 其下的各选项请根据实际硬件状况选择 (皆为低功耗或嵌入式平台).")]),t._v(" "),e("dt",[t._v("GPIO Support\nCONFIG_GPIOLIB")]),t._v(" "),e("dd",[t._v('每个芯片都会有至少一个引脚 (PIN), 像 CPU 或者芯片组这种复杂的芯片, 其引脚会有成白上千个, 这些 PIN 就是芯片与外部沟通的渠道, 每个 PIN 都会有它特定的功能.[GPIO](http://baike.baidu.com/view/980829.htm)([General Purpose I/O](http://en.wikipedia.org/wiki/General-purpose_input/output)) 就是芯片上的一种通用功能的引脚, 其功能可由使用者通过编程的方式自定义 (所谓 "可编程引脚"), 比如使用两条 PIN 就可以组成 I2C, 使用 4 条 PIN 就可以组成 SPI. 嵌入式系统经常需要控制结构简单但数量众多的外部设备 (比如 LED 的亮与灭), 使用传统的串口或者并口就太 "大炮打蚊子", 而 GPIO 则非常适合用于控制此类数量众多的简单设备. GPIO 在嵌入式设备中使用广泛, 但 PC 平台的芯片组南桥大多也集成有 [GPIO](http://blog.csdn.net/gjsisi/article/details/7712538) 引脚 (但只有 BIOS 才知道如何使用他们), 以支持某些特殊的定制硬件. 详情参见 "[Documentation/gpio/gpio.txt](https://www.kernel.org/doc/Documentation/gpio/gpio.txt)"文档. 不确定的选"N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Debug GPIO calls\nCONFIG_DEBUG_GPIO")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("/sys/class/gpio/... (sysfs interface)\nCONFIG_GPIO_SYSFS")]),t._v(" "),e("dd",[t._v('为 GPIO 设备添加 sysfs 接口. 主要用于调试和问题排查. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Generic memory-mapped GPIO controller support (MMIO platform device)\nCONFIG_GPIO_GENERIC_PLATFORM")]),t._v(" "),e("dd",[t._v('这是最简单的 GPIO 控制器驱动 ([platform 总线](http://wenku.baidu.com/view/7673feacdd3383c4bb4cd211)驱动), 仅支持单独一个 "data" 寄存器, 用于读 / 写 GPIO 的状态. 不确定的选 "Y".')]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{这里被省略的部分, 按主板上实际集成的芯片选择即可}")])])]),t._v(" "),e("dt",[t._v("Dallas's 1-wire support\nCONFIG_W1")]),t._v(" "),e("dd",[t._v("Dallas 公司发明的单总线是比 I2C 更简单的总线, 仅使用一个引脚 (1-wire), 使用 Master-Slave 结构, 用于连接慢速的单引脚设备, 比如 [iButton](http://baike.baidu.com/view/2521664.htm) 和热传感器. 主要用于嵌入式系统.")]),t._v(" "),e("dt",[t._v("Power supply class support\nCONFIG_POWER_SUPPLY")]),t._v(" "),e("dd",[t._v("允许用户空间程序通过 sysfs/uevent 接口对电源 (电池, 交流电, USB) 进行监控. 主要用于笔记本与嵌入式设备.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Power supply debug\nCONFIG_POWER_SUPPLY_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Generic PDA/phone power driver\nCONFIG_PDA_POWER")]),t._v(" "),e("dd",[t._v("通用的 PDA/phone 电源切换驱动. 用于在内部电池和外部电源 (AC/USB) 之间进行切换.")]),t._v(" "),e("dt",[t._v("Generic battery support using IIO\nCONFIG_GENERIC_ADC_BATTERY")]),t._v(" "),e("dd",[t._v("为使用 IIO 总线 (CONFIG_IIO) 的电池提供的通用驱动")]),t._v(" "),e("dt",[t._v("Test power driver\nCONFIG_TEST_POWER")]),t._v(" "),e("dd",[t._v("仅供测试使用")]),t._v(" "),e("dt",[t._v("SBS Compliant gas gauge\nCONFIG_BATTERY_SBS")]),t._v(" "),e("dd",[t._v("与[智能电池系统](http://baike.baidu.com/view/1938623.htm) ([Smart Battery System](http://www.chinacpec.com/news/display.php?aid=88))规范兼容的气压计 (集成在电池组中) 支持.")]),t._v(" "),e("dt",[t._v("GPIO charger\nCONFIG_CHARGER_GPIO")]),t._v(" "),e("dd",[t._v("支持充电器通过 GPIO 引脚报告其在线状态.")]),t._v(" "),e("dt",[t._v("Board level reset or power off\nCONFIG_POWER_RESET")]),t._v(" "),e("dd",[t._v("允许通过操作板载的主电源, 关闭或重启整个系统. 仅用于嵌入式系统.")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{这里被省略的部分, 按实际电池控制芯片选择即可}")])])]),t._v(" "),e("dt",[t._v("Adaptive Voltage Scaling class support\nCONFIG_POWER_AVS")]),t._v(" "),e("dd",[t._v('自适应电压调节 (Adaptive Voltage Scaling) 技术能够动态的对设备工作电压进行精细的调整, 拥有比 [DVFS](http://baike.baidu.com/view/7861420.htm) 更佳的电力利用效率, 是一种降低功耗与优化性能并举的电源与性能管理技术. AVS 在 OMAP 设备上也被称为 "[SmartReflex](http://yanqin.spaces.eepw.com.cn/articles/article/item/50555)". 目前仅用于嵌入式领域.')]),t._v(" "),e("dt",[t._v("Hardware Monitoring support\nCONFIG_HWMON")]),t._v(" "),e("dd",[t._v('当前主板大多都有一个监控硬件温度 / 电压 / 风扇转速等状况的设备, 请按照主板实际使用的芯片选择相应的子项. 如果你不知道究竟需要使用哪个驱动, 可以使用 [Superiotool](http://www.coreboot.org/Superiotool) 和 [sensors-detect](http://www.lm-sensors.org/wiki/man/sensors-detect) 工具进行检测. 另外, 某些子项可能还需要 CONFIG_I2C 的支持. 更多详情参见 "[Documentation/hwmon/userspace-tools](https://www.kernel.org/doc/Documentation/hwmon/userspace-tools)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Hardware Monitoring Chip debugging messages\nCONFIG_HWMON_DEBUG_CHIP")]),t._v(" "),e("dd",[t._v("在系统日志中输出大量的 I2C 调试信息, 仅用于故障调试")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{被省略的部分, 按实际的硬件监控芯片选择即可}")]),t._v(" "),e("dt",[t._v("GPIO fan\nCONFIG_SENSORS_GPIO_FAN")]),t._v(" "),e("dd",[t._v("连接在 GPIO 引脚上的风扇")]),t._v(" "),e("dt",[t._v("PMBus support\nCONFIG_PMBUS")]),t._v(" "),e("dd",[t._v("[电源管理总线](http://baike.baidu.com/view/2526981.htm) (Power Management Bus) 是一种基于 SMBus(CONFIG_I2C) 的开放标准的数字电源管理协议, 可以用于配置 / 监控 / 操作电源变换器, 目前全球有[超过 40 个 IC 厂商](http://smiforum.org/members.html)提供[满足 PMBus 标准的产品](http://pmbus.org/products.html). 最新的 [PMBus+ 1.3](http://pmbus.org/docs/20130815PMBus+(tm)_PLUS_Announce.pdf) 标准增加 AVS(CONFIG_POWER_AVS) 支持, 可以动态控制设备的工作电压. 根据你的实际硬件状况选择子项.")]),t._v(" "),e("dt",[t._v("ACPI 4.0 power meter\nCONFIG_SENSORS_ACPI_POWER")]),t._v(" "),e("dd",[t._v('将 [ACPI](http://www.acpi.info/) 4.0(2009 年 6 月发布)中定义的瓦特表 (用于测量功耗) 当做硬件监控设备导出到用户空间. 需要固件支持 ACPI 4.0 规范, 并且有一个瓦特表. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("ASUS ATK0110\nCONFIG_SENSORS_ATK0110")]),t._v(" "),e("dd",[t._v("许多华硕主板都有这种 ACPI 硬件监控接口. 此驱动可以通过主板固件读取风扇 / 电压 / 温度信息.")])])]),t._v(" "),e("dt",[t._v("Generic Thermal sysfs driver\nCONFIG_THERMAL")]),t._v(" "),e("dd",[t._v('为 ACPI 规范中定义的 "thermal"(发热控制) 提供一个通用的 sysfs 接口, 以方便与诸如温度传感器和风扇之类的设备通信. 由于目前所有 PC 和服务器都已支持 ACPI, 并且发热控制也越来越重要, 所以建议选 "Y". 详情参见 "[Documentation/thermal/sysfs-api.txt](https://www.kernel.org/doc/Documentation/thermal/sysfs-api.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Expose thermal sensors as hwmon device\nCONFIG_THERMAL_HWMON")]),t._v(" "),e("dd",[t._v("将温度传感器同时注册为一个硬件监控设备, 从而让温度传感器同样在 sysfs 中拥有 hwmon 接口.")]),t._v(" "),e("dt",[t._v("Enable writable trip points\nCONFIG_THERMAL_WRITABLE_TRIPS")]),t._v(" "),e("dd",[t._v("允许用户空间程序更改温度报警阀值 (trip temperature).")]),t._v(" "),e("dt",[t._v("Default Thermal governor")]),t._v(" "),e("dd",[t._v('选择默认的热调节器, 建议选 "step_wise".')]),t._v(" "),e("dt",[t._v("Fair-share thermal governor\nCONFIG_THERMAL_GOV_FAIR_SHARE")]),t._v(" "),e("dd",[t._v('此调节器根据设备对所属区域的 "贡献"(contribution) 进行调节.')]),t._v(" "),e("dt",[t._v("Step_wise thermal governor\nCONFIG_THERMAL_GOV_STEP_WISE")]),t._v(" "),e("dd",[t._v("此调节器以线性方式进行调节, 也就是每次调节都只在紧邻的两档之间进行切换.")]),t._v(" "),e("dt",[t._v("Bang Bang thermal governor\nCONFIG_THERMAL_GOV_BANG_BANG")]),t._v(" "),e("dd",[t._v("此调节器仅能让散热风扇处于开 / 关两种状态 (根据温度阀值) 而不能调节风扇的速度. 某些 Acer 笔记本风扇驱动 (acerhdf) 依赖于此调节器. 不能将此调节器设为默认调节器.")]),t._v(" "),e("dt",[t._v("User_space thermal governor\nCONFIG_THERMAL_GOV_USER_SPACE")]),t._v(" "),e("dd",[t._v("此调节器让用户空间程序去决定如何调节")]),t._v(" "),e("dt",[t._v("Power allocator thermal governor\nCONFIG_THERMAL_GOV_POWER_ALLOCATOR")]),t._v(" "),e("dd",[t._v('此调节器可对特定的设备动态分配和限制能量的使用. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("generic cpu cooling support\nCONFIG_CPU_THERMAL")]),t._v(" "),e("dd",[t._v('通用的 CPU 降温机制 (通过降低频率来实现, 而不是通过 ACPI 接口). 显然通过 ACPI 接口是更好的机制, 所以建议选 "N".')]),t._v(" "),e("dt",[t._v("Thermal emulation mode support\nCONFIG_THERMAL_EMULATION")]),t._v(" "),e("dd",[t._v('"Thermal" 模拟. 仅供调试使用, 切勿用于生产系统!!')]),t._v(" "),e("dt",[t._v("Intel PowerClamp idle injection driver\nCONFIG_INTEL_POWERCLAMP")]),t._v(" "),e("dd",[t._v('Intel [PowerClamp](http://lwn.net/Articles/528124/) 驱动通过利用 [Nehalem](http://zh.wikipedia.org/wiki/Intel_Nehalem) 之后的 CPU 支持的 "package-level C-state" 特性, 强制为在线的 CPU 注入 "idle" 指令 (通过 "/sys/class/thermal/" 接口设定 "idle" 百分比), 以确保 CPU 的功耗不会超过特定的阈值 (发热量也就不会超过特定的阈值). 这样刻意的降低系统性能峰值还有一个好处, 那就是相对于传统的动态频率调节技术而言, 能够达到更高的每瓦特性能. 详见 [Documentation/thermal/intel_powerclamp.txt](https://www.kernel.org/doc/Documentation/thermal/intel_powerclamp.txt) 文档. 如果你对节能和限制发热量特别在意, 同时又不在乎系统峰值性能的降低, 可以选 "Y".')]),t._v(" "),e("dt",[t._v("X86 package temperature thermal driver\nCONFIG_X86_PKG_TEMP_THERMAL")]),t._v(" "),e("dd",[t._v('所谓 "[CPU 温度](https://forum-sc.msi.com/index.php?topic=247.0) "实际上是个多重概念:(1)Socket 温度, 是指 CPU 插座里的测温二极管探测到的温度, 相当于 CPU 外表面的温度;(2)Package 温度, 是封装在 CPU 内部的测温二极管探测到的温度, 是真正的 CPU 内部的温度, 此温度永远比 Socket 温度高;(3)Core 温度, 是每个 CPU 核心内嵌的温度传感器检测到的温度, 有多少个核心就有多少个 Core 温度; 此选项提供了检测 Package 温度的驱动. 并将此温度用于监控 CPU 温度 (对于拥有多颗物理 CPU 的服务器来说每颗物理 CPU 对应一个 Package 温度). 同时, 选中此项后, 温度报警阀值也变为可以设置两个严重级别不同的值. 建议选"Y".')]),t._v(" "),e("dt",[t._v("Intel SoCs DTS thermal driver\nCONFIG_INTEL_SOC_DTS_THERMAL")]),t._v(" "),e("dd",[t._v("专用于 Intel SoC(BayTrail 等) 平台的 CPU 内嵌温度传感器驱动.")]),t._v(" "),e("dt",[t._v("ACPI INT340X thermal drivers\nCONFIG_INT340X_THERMAL")]),t._v(" "),e("dd",[t._v("除了 CPU/SOC 内置的温度传感器之外, 新式笔记本或平板电脑还经常包含探测整机不同位置温度的传感器, 这些温度传感器以 INT3400 ACPI 设备作为主设备 (master), 并以 INT3401~INT340B ACPI 设备为从设备 (slave), 此选项提供了对此类温度传感器的驱动支持.")]),t._v(" "),e("dt",[t._v("Intel PCH Thermal Reporting Driver\nCONFIG_INTEL_PCH_THERMAL")]),t._v(" "),e("dd",[t._v("专用于 Intel PCH 芯片组内置温度传感器的驱动.")])])]),t._v(" "),e("dt",[t._v("Watchdog Timer Support\nCONFIG_WATCHDOG")]),t._v(" "),e("dd",[t._v('选 "Y" 并选中下面相应的驱动之后, 再创建一个主 / 次设备号为 10/130 的字符设备 "/dev/watchdog", 即可拥有一只[看门狗](https://www.ibm.com/developerworks/cn/linux/l-cn-watchdog/). 其工作原理是: 当 / dev/watchdog 设备被打开后, 如果[喂狗守护进程](http://ibiblio.org/pub/Linux/system/daemons/watchdog/)超过 60 秒没有喂狗 (写入 "/dev/watchdog"), 那么底层的看门狗硬件将会触发整个机器硬重启 (相当于按下面板上的 "RESET" 按钮). 这对于提高服务器的在线率来说意义重大. 详情参见 "[Documentation/watchdog/watchdog-api.txt](https://www.kernel.org/doc/Documentation/watchdog/watchdog-api.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("WatchDog Timer Driver Core\nCONFIG_WATCHDOG_CORE")]),t._v(" "),e("dd",[t._v('看门狗核心驱动, 它为所有特定于具体硬件的看门狗驱动提供了统一的框架和 "/dev/watchdog" 接口 (未来还会包括 sysfs 接口). 使用看门狗的必选.')]),t._v(" "),e("dt",[t._v("Disable watchdog shutdown on close\nCONFIG_WATCHDOG_NOWAYOUT")]),t._v(" "),e("dd",[t._v('默认情况下 (此项 ="N") 如果喂狗进程关闭 "/dev/watchdog" 文件, 那么表示停止看门狗功能. 开启此项后, 看门狗一旦启用就不能被停止(即使关闭 "/dev/watchdog" 文件也不会停止).')]),t._v(" "),e("dt",[t._v("Software watchdog\nCONFIG_SOFT_WATCHDOG")]),t._v(" "),e("dd",[t._v('内核提供的 "软看门狗". 使用它不需要有任何硬件的支持, 但可靠性不如硬件看门狗, 仅能应对喂狗进程的崩溃, 不能应对内核本身的崩溃. 在某些情况下 (例如 Oracle 数据库),CONFIG_HANGCHECK_TIMER 是比 "软看门狗" 更好的选择.')]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处省略的看门狗硬件请按照实际使用的芯片进行选择}")])])]),t._v(" "),e("dt",[t._v("Sonics Silicon Backplane support\nCONFIG_SSB")]),t._v(" "),e("dd",[t._v("SSB(Sonics Silicon Backplane) 是一种仅在嵌入式环境中使用的总线.")]),t._v(" "),e("dt",[t._v("Broadcom specific AMBA\nCONFIG_BCMA")]),t._v(" "),e("dd",[t._v("Broadcom 特有的 [AMBA](http://blog.163.com/meteora_wzh/blog/static/369626752007102752315710/)(Advanced Microcontroller Bus Architecture) 总线支持. 仅用于嵌入式环境")]),t._v(" "),e("dt",[t._v("Multifunction device drivers")]),t._v(" "),e("dd",[t._v('MFD(多功能设备)的含义是 "在单个芯片上集成多个功能 (GPIO, 触摸屏, 键盘, 电流调节, 电源管理...)". 此种芯片通常通过一个或多个 IRQ 线和低速数据总线(SPI/I2C/GPIO) 与主 CPU 进行通信. 对于主系统来说, 它们通过数据总线显示为一个单独的 MFD 设备. 但透过 MFD 框架, 又可以拥有多个相互独立的子设备(子功能).')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Intel ICH LPC\nCONFIG_LPC_ICH")]),t._v(" "),e("dd",[t._v('[LPC](http://zh.wikipedia.org/wiki/LPC%E5%8C%AF%E6%B5%81%E6%8E%92)(Low Pin Count) 总线是 Intel 于 1998 年发布的一个旨在取代传统 ISA 总线的接口规范, 用于连接南桥和 [Super I/O](http://zh.wikipedia.org/wiki/Super_I/O) 芯片 (用于连接低速外设: 串口, 并口, PS/2 键鼠, 软盘控制器, TPM(可信平台模块), 温度传感器, 风扇速度监测器) 以及 Flash 芯片(BIOS). 以往南桥必须保留 ISA 总线, 以连接老旧的 ISA 插槽和 [Super I/O 芯片](http://www.esupport.com/techsupport/award/superio.php) (可以使用 [Superiotool](http://www.coreboot.org/Superiotool) 和 [sensors-detect](http://www.lm-sensors.org/wiki/man/sensors-detect) 工具检测) 以及 Flash 芯片. 但是 ISA 需要占用大量针脚, 主板的线路设计也比较复杂. 随着 ISA 插槽的消失, LPC 就顺理成章的出现了, 它与 ISA 在软件层面是类似的, 同时 LPC 工作速率由 PCI 总线速率同步驱动, 但是引脚数大大降低, 以方便在拥挤的现代主板上布局, 这也是取名 "Low Pin Count" 的原因. 此选项支持几乎所有 Intel 芯片组的 LPC 总线, 以方便其他驱动控制 MFD(目前仅有 GPIO 和 watchdog). 具体[支持的芯片](https://cateee.net/lkddb/web-lkddb/LPC_ICH.html)可以查看 "drivers/mfd/lpc_ich.c" 文件. 不确定的选 "Y".')]),t._v(" "),e("dt",[t._v("Intel SCH LPC\nCONFIG_LPC_SCH")]),t._v(" "),e("dd",[t._v("用于 Intel Atom 处理器的 Intel SCH(System Controller Hub) LPC 总线支持. 目前仅支持 SMBus 和 GPIO.")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处省略的硬件请按照实际使用的芯片进行选择}")])])]),t._v(" "),e("dt",[t._v("Voltage and Current Regulator Support\nCONFIG_REGULATOR")]),t._v(" "),e("dd",[t._v("通用的电压与电流调节器框架. 除了提供通用的电压与电流调节接口外, 还能通过 sysfs 向用户空间提供电压与电流的状态信息. 目的在于通过动态调节电压和电流, 降低能耗, 延长电池寿命. 主要用于嵌入式环境.")]),t._v(" "),e("dt",[t._v("Multimedia support\nCONFIG_MEDIA_SUPPORT")]),t._v(" "),e("dd",[t._v("多媒体设备: 摄像头, 视频采集, 模拟电视, 数字电视, 机顶盒, 收音机, 遥控器, 数字视频广播 (DVB)... 内核多媒体子系统由 [LinuxTV](http://linuxtv.org/) 项目负责维护.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Cameras/video grabbers support\nCONFIG_MEDIA_CAMERA_SUPPORT")]),t._v(" "),e("dd",[t._v("摄像头, 视频采集卡")]),t._v(" "),e("dt",[t._v("Analog TV support\nCONFIG_MEDIA_ANALOG_TV_SUPPORT")]),t._v(" "),e("dd",[t._v("模拟电视信号接收器, 包括那些既能接收模拟信号又能接收数字信号的电视卡")]),t._v(" "),e("dt",[t._v("Digital TV support\nCONFIG_MEDIA_DIGITAL_TV_SUPPORT")]),t._v(" "),e("dd",[t._v("数字电视信号接收器, 包括那些既能接收模拟信号又能接收数字信号的电视卡")]),t._v(" "),e("dt",[t._v("AM/FM radio receivers/transmitters support\nCONFIG_MEDIA_RADIO_SUPPORT")]),t._v(" "),e("dd",[t._v("AM/FM 无线电接收机和发射机, 包括那些带有收音机功能的电视卡")]),t._v(" "),e("dt",[t._v("Remote Controller support\nCONFIG_MEDIA_RC_SUPPORT")]),t._v(" "),e("dd",[t._v("基于红外线 / 射频的遥控器, 用于控制视频采集卡或者电视卡. 大多数电视卡和视频采集卡都需要它的支持, 即使这些卡实际并不需要遥控器.")]),t._v(" "),e("dt",[t._v("Media Controller API\nCONFIG_MEDIA_CONTROLLER")]),t._v(" "),e("dd",[t._v("此 API 用于查询多媒体设备内部的拓扑结构, 并进行动态配置. 主要用于嵌入式环境中的摄像头配置.")]),t._v(" "),e("dt",[t._v("V4L2 sub-device userspace API\nCONFIG_VIDEO_V4L2_SUBDEV_API")]),t._v(" "),e("dd",[t._v("此 API 用于配置视频的格式 / 尺寸 / 帧率. 主要用于嵌入式环境中的摄像头配置.")]),t._v(" "),e("dt",[t._v("Enable advanced debug functionality on V4L2 drivers\nCONFIG_VIDEO_ADV_DEBUG")]),t._v(" "),e("dd",[t._v('开启 [V4L2](http://baike.baidu.com/view/5494174.htm) 驱动程序的高级调试特性, 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Enable old-style fixed minor ranges on drivers/video devices\nCONFIG_VIDEO_FIXED_MINOR_RANGES")]),t._v(" "),e("dd",[t._v('仅在你使用 mknod 而不是 udev 进行设备管理时才需要开启. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("V4L2 int device (DEPRECATED)\nCONFIG_VIDEO_V4L2_INT_DEVICE")]),t._v(" "),e("dd",[t._v('仅用于旧式的图像传感器驱动 (omap24xxcam 和 tcm825x), 反对使用此项. 选 "N".')]),t._v(" "),e("dt",[t._v("DVB Network Support\nCONFIG_DVB_NET")]),t._v(" "),e("dd",[t._v("[DVB](http://zh.wikipedia.org/wiki/DVB)([数字视频广播](http://baike.baidu.com/view/73510.htm#sub5082257))是一系列国际公认的数字电视标准. 此项提供了 DVB 网络 (DVB 标准的一部分) 支持, 可用于数字机顶盒 (Set-Top-Box) 的自动固件升级以及通过 DVB 卡访问互联网.")]),t._v(" "),e("dt",[t._v("maximum number of DVB/ATSC adapters\nCONFIG_DVB_MAX_ADAPTERS")]),t._v(" "),e("dd",[t._v('最大允许的 [DVB/ATSC](http://www.eefocus.com/pixela/blog/08-03/144874_3fa2b.html) 电视卡数量. 取值范围是 [1,255], 但经过测试的范围是 [4,32]. 不确定的请保持默认值 "8".')]),t._v(" "),e("dt",[t._v("Dynamic DVB minor allocation\nCONFIG_DVB_DYNAMIC_MINORS")]),t._v(" "),e("dd",[t._v("为 DVB 设备节点动态分配次设备号, 这样每张 DVB 卡就可以拥有最多 4 个同类型的设备 (例如 demux(分离器) 和 frontend(前端)). 此特性需要 udev 的支持.")]),t._v(" "),e("dt",[t._v("Compile Remote Controller keymap modules\nCONFIG_RC_MAP")]),t._v(" "),e("dd",[t._v('将各种遥控器的 keymap 表编译进内核. 这些表都很小, 但是如果你不打算使用遥控器, 或者更喜欢使用 [v4l-utils](http://linuxtv.org/downloads/v4l-utils/) 包内的 [ir-keytable](http://manpages.ubuntu.com/manpages/natty/man1/ir-keytable.1.html) 工具从用户空间加载这些表, 可以选 "N".')]),t._v(" "),e("dt",[t._v("Remote controller decoders\nCONFIG_RC_DECODERS")]),t._v(" "),e("dd",[t._v("遥控器解码器. 其下的子项是各种不同的遥控通信协议.")]),t._v(" "),e("dt",[t._v("Remote Controller devices\nCONFIG_RC_DEVICES")]),t._v(" "),e("dd",[t._v("各种遥控器产品. 其下子项按实际的厂商和型号选择即可.")]),t._v(" "),e("dt",[t._v("Media USB Adapters\nCONFIG_MEDIA_USB_SUPPORT")]),t._v(" "),e("dd",[t._v("各种 USB 总线的多媒体设备")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("USB Video Class (UVC)\nCONFIG_USB_VIDEO_CLASS")]),t._v(" "),e("dd",[t._v('[UVC](http://zh.wikipedia.org/wiki/USB%E8%A6%96%E9%A0%BB%E9%A1%9E%E5%88%A5)([USB Video Class](http://en.wikipedia.org/wiki/USB_video_device_class)) 是一个开放的通用 USB 视频捕获标准. 目前大多数摄像头都是 UVC 摄像头, 也就是俗称的 "免驱摄像头". 所有符合 UVC 规格的硬件都可以使用[通用 UVC 驱动程序](http://linux-uvc.berlios.de/), 而无需再使用专用驱动.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("UVC input events device support\nCONFIG_USB_VIDEO_CLASS_INPUT_EVDEV")]),t._v(" "),e("dd",[t._v("某些 UVC 摄像头上会带有按钮 (常用于开关 LED 灯 / 拍照), 此选项可以将此按钮注册为一个输入设备, 以用于报告按钮事件.")])])]),t._v(" "),e("dt",[t._v("GSPCA based webcams\nCONFIG_USB_GSPCA")]),t._v(" "),e("dd",[t._v('基于 GSPCA 框架的摄像头驱动 (依赖于 CONFIG_VIDEO_V4L2), 这是[一位 60 岁的法国医生的杰作](http://news.mydrivers.com/1/82/82885.htm). 该驱动适用于大多数常见的非 UVC 摄像头. 具体支持的芯片列表可以查看 "[Documentation/video4linux/gspca.txt](https://www.kernel.org/doc/Documentation/video4linux/gspca.txt)" 文档.')]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处省略的非 GSPCA 摄像头, 电视卡, 电视棒等其他硬件请按照实际使用的芯片进行选择}")])])]),t._v(" "),e("dt",[t._v("Media PCI Adapters\nCONFIG_MEDIA_PCI_SUPPORT")]),t._v(" "),e("dd",[t._v("各种 PCI/PCIe 总线的多媒体设备")]),t._v(" "),e("dt",[t._v("V4L platform devices\nCONFIG_V4L_PLATFORM_DRIVERS")]),t._v(" "),e("dd",[t._v("特定于平台的 V4L(Video For Linux) 设备, 这些设备不是通过 USB/PCI 这样的总线连接的. 一般用于单片机之类的嵌入式环境.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("SoC camera support\nCONFIG_SOC_CAMERA")]),t._v(" "),e("dd",[t._v('所谓 "SoC Camera" 是指那些不通过 PCI 或 USB 总线连接的摄像头 (例如通过 I2C 直接与 SoC 数据总线连接). 此选项为这类摄像头提供了通用的支持.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("platform camera support\nCONFIG_SOC_CAMERA_PLATFORM")]),t._v(" "),e("dd",[t._v("仅用于调试目的")])])]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处省略的部分请按照实际使用的芯片进行选择}")])])]),t._v(" "),e("dt",[t._v("Memory-to-memory multimedia devices\nCONFIG_V4L_MEM2MEM_DRIVERS")]),t._v(" "),e("dd",[t._v('使用系统内存作为源和目标缓存 (Memory-to-memory) 的多媒体设备. 一般的采集输出驱动仅将系统内存用于源或目标缓存之一. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Media test drivers\nCONFIG_V4L_TEST_DRIVERS")]),t._v(" "),e("dd",[t._v("仅用于调试目的.")]),t._v(" "),e("dt",[t._v("Siano SMS1xxx based MDTV via SDIO interface\nCONFIG_SMS_SDIO_DRV")]),t._v(" "),e("dd",[t._v("使用 [SDIO](http://bbs.ednchina.com/BLOG_ARTICLE_198217.HTM) 接口的一种移动数字电视 (MDTV) 卡, 基于 [Siano SMS1xxx](http://www.ic72.com/technology/circuit_info_104158.html) 芯片. 主要用于嵌入式设备")]),t._v(" "),e("dt",[t._v("ISA and parallel port devices\nCONFIG_MEDIA_PARPORT_SUPPORT")]),t._v(" "),e("dd",[t._v("使用 ISA 或并口的多媒体设备, 古董级别的设备")]),t._v(" "),e("dt",[t._v("Radio Adapters\nCONFIG_RADIO_ADAPTERS")]),t._v(" "),e("dd",[t._v("AM/FM 无线电广播接收设备")]),t._v(" "),e("dt",[t._v("FireDTV and FloppyDTV\nCONFIG_DVB_FIREDTV")]),t._v(" "),e("dd",[t._v("[Digital Everywhere](http://www.digital-everywhere.com/) 生产的 FireWire(IEEE 1394) 接口的 DVB 电视接收卡")]),t._v(" "),e("dt",[t._v("Cypress firmware helper routines\nCONFIG_CYPRESS_FIRMWARE")]),t._v(" "),e("dd",[t._v("[Cypress](http://baike.baidu.com/view/1367502.htm)([赛普拉斯](http://china.cypress.com/)) 多媒体产品的固件加载帮助程序.")]),t._v(" "),e("dt",[t._v("Enable Remote Controller support for Siano devices\nCONFIG_SMS_SIANO_RC")]),t._v(" "),e("dd",[t._v("[Siano](http://www.siano-ms.com/CN/) 多媒体设备遥控器")]),t._v(" "),e("dt",[t._v("Enable debugfs for smsdvb\nCONFIG_SMS_SIANO_DEBUGFS")]),t._v(" "),e("dd",[t._v("仅供调试使用, 当前仅可用于 Siano USB 设备")]),t._v(" "),e("dt",[t._v("Autoselect ancillary drivers (tuners, sensors, i2c, frontends)\nCONFIG_MEDIA_SUBDRV_AUTOSELECT")]),t._v(" "),e("dd",[t._v('为多媒体设备驱动自动选择所有相关的辅助驱动 (tuner[调谐器],sensor[传感器], 视频编 / 解码器以及前端), 以免去手动选择的麻烦. 通常这是个好主意, 建议选 "Y". 但是对于某些嵌入式环境来说, 却希望去掉部分有用的辅助驱动以保持内核尽可能短小, 这时应该选 "N".')]),t._v(" "),e("dt",[t._v("I2C module for IR\nCONFIG_VIDEO_IR_I2C")]),t._v(" "),e("dd",[t._v("大多数板子都通过 GPIO 总线连接红外线芯片, 但少数板子却使用 I2C 总线连接. 此项即是对 I2C 总线连接的红外线芯片提供支持.")]),t._v(" "),e("dt",[t._v("Encoders, decoders, sensors and other helper chips")]),t._v(" "),e("dd",[t._v("编码器, 解码器, 传感器, 混频器... 等辅助芯片")]),t._v(" "),e("dt",[t._v("Sensors used on soc_camera driver")]),t._v(" "),e("dd",[t._v('用于 "SoC Camera"(CONFIG_SOC_CAMERA) 的各种传感器')]),t._v(" "),e("dt",[t._v("Customize TV tuners")]),t._v(" "),e("dd",[t._v("各种专用的电视调谐器")]),t._v(" "),e("dt",[t._v("Customise DVB Frontends")]),t._v(" "),e("dd",[t._v("各种专用的数字电视前端")])])]),t._v(" "),e("dt",[t._v("Graphics support")]),t._v(" "),e("dd",[t._v('图形设备 / 显卡支持. 对于不需要使用图形界面的服务器环境来说, 必须的最小选项集取决于平台 (BIOS/UEFI) 和引导程序 (GRUB/LILO/GRUB4DOS) 的设置 (全选 "N" 则屏幕将无任何显示). 具体如下:(1) 以 UEFI 方式启动的, 一律都必须 "CONFIG_FB=y,CONFIG_FB_EFI=y,CONFIG_FRAMEBUFFER_CONSOLE=y"[补充说明: 对于 3.12 或以上版本, 则应该是 "CONFIG_X86_SYSFB=y,CONFIG_FB=y,CONFIG_FB_SIMPLE=y,FRAMEBUFFER_CONSOLE=y"];(2)以 BIOS+GRUB2 启动, 且在\'grub.cfg\'中明确将 "gfxpayload" 变量设置为非\'text\'值或者内核引导参数中存在\'vga=...\', 那么必须 "CONFIG_FB=y,CONFIG_FB_VESA=y,CONFIG_FRAMEBUFFER_CONSOLE=y"[补充说明: 对于 3.12 或以上版本, 则应该是 "CONFIG_X86_SYSFB=y,CONFIG_FB=y,CONFIG_FB_SIMPLE=y,FRAMEBUFFER_CONSOLE=y"];(3)以 BIOS 方式启动的其他情况, 必须 "CONFIG_VGA_CONSOLE=y"')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("/dev/agpgart (AGP Support)\nCONFIG_AGP")]),t._v(" "),e("dd",[t._v('[GART](http://en.wikipedia.org/wiki/Graphics_address_remapping_table)([图形地址重映射表](http://blog.csdn.net/zkami/article/details/3576809)) 可以看做一种被各种显卡 (不只是 [AGP](http://zh.wikipedia.org/wiki/AGP) 显卡, 还包括 [PCI-E](http://zh.wikipedia.org/wiki/PCI_Express) 显卡与[集成显卡](http://baike.baidu.com/view/9082.htm)以及[核心显卡](http://baike.baidu.com/view/4503595.htm)) 使用的 " 伪 [IOMMU](http://server.zdnet.com.cn/files/all-1836536.htm)"(参见 CONFIG_GART_IOMMU 选项), 它将物理地址不连续的系统内存映射成连续的" 显存 " 供 GPU 使用. 当物理显存容量不够时 (大多数集成显卡甚至根本没有物理显存),GART 允许通过 DMA([直接内存访问](http://blog.csdn.net/wzhwho/article/details/5638045)) 方式将这部分 "显存" 用于[纹理贴图](http://zh.wikipedia.org/wiki/%E6%9D%90%E8%B4%A8%E8%B4%B4%E5%9B%BE),[Z 轴缓冲](http://www.cnblogs.com/jiahuafu/archive/2011/02/19/1958467.html),[ALPHA 混合](http://baike.baidu.com/view/736358.htm), [多边形网格](http://en.wikipedia.org/wiki/Polygon_mesh)生成... 等各种 3D 操作. 如果没有 GART 支持,[OpenGL](http://zh.wikipedia.org/zh-cn/OpenGL) 直接渲染将会变得特别慢.[GLX](http://liyanrui.is-programmer.com/2009/2/7/glx-notes.7061.html) 与 [DRI](http://www.linuxgraphics.cn/xwindow/dri_intro.html)(CONFIG_DRM) 也依赖于此. 简而言之, 需要使用图形化界面的人都应该选 "Y". 不需要图形界面的用户应该选 "N".[注意] 对于使用 304 或更老版本的 nVidia 闭源驱动的用户, 如果使用的是[某些老旧的芯片组](http://us.download.nvidia.com/XFree86/Linux-x86/304.108/README/configuringagp.html), 那么此处应该选 "N". 因为在这些特定的芯片组上, 闭源驱动自己的 agpgart 实现 ([NvAGP](http://en.wikipedia.org/wiki/NvAGP)) 是更好的选择.[提示] 老版本的 AMD/ATI/NVIDIA 闭源驱动都曾经有自己的 agpgart 实现, 但在新版本中都已经被移除. 而 Intel 显卡一直使用的都是内核的 agpgart 实现.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("AMD Opteron/Athlon64 on-CPU GART support\nCONFIG_AGP_AMD64")]),t._v(" "),e("dd",[t._v('该项仅适用于如下 AMD 处理器:(1)[AMD K8](http://zh.wikipedia.org/wiki/AMD_K8) 微架构 CPU[cpu family : 15] (2)[AMD K10](http://en.wikipedia.org/wiki/AMD_10h) 微架构 CPU[cpu family : 16] (3)[AMD 推土机](http://zh.wikipedia.org/wiki/AMD_Bulldozer)微架构 CPU[cpu family : 21 并且 model: 小于 15].[提示]除了前面列出的三种 CPU 外, 其他 AMD 处理器 (例如 A4/A6/A8 系列 APU) 并不需要此选项. 具体支持的 CPU 可以查看 "arch/x86/kernel/amd_nb.c" 文件中的 "AMD_NB_GART" 常量的使用.')]),t._v(" "),e("dt",[t._v("Intel 440LX/BX/GX, I8xx and E7x05 chipset support\nCONFIG_AGP_INTEL")]),t._v(" "),e("dd",[t._v('该项仅适用于:(1) 某些 [Intel 芯片组](http://en.wikipedia.org/wiki/List_of_Intel_chipsets) (440LX/BX/GX, 8xx 系列, E7205/E7505/E7221, 9xx 系列, 所有 3/4 系列). (2) 全部 [Intel 集成显卡](http://en.wikipedia.org/wiki/Intel_GMA) (包括 [Intel 核心显卡](http://zh.wikipedia.org/wiki/Intel_HD_Graphics)). 具体支持的芯片组和集显可以查看 "drivers/char/agp/intel-*" 系列文件.[提示] 如果你使用的既不是此处所列的芯片组 (例如 [Xeon 芯片组](http://en.wikipedia.org/wiki/Intel_Xeon_chipsets)或者 [5/6/7/8/9 系列芯片组](https://en.wikipedia.org/wiki/List_of_Intel_chipsets#5.2F6.2F7.2F8.2F9_Series_chipsets)) 也不是 Intel 的集成显卡 (例如 AMD/nVidia 独立显卡), 那么应该选 "N".')]),t._v(" "),e("dt",[t._v("SiS chipset support\nCONFIG_AGP_SIS")]),t._v(" "),e("dd",[t._v("该项仅适用于 [SiS](http://zh.wikipedia.org/wiki/%E7%9F%BD%E7%B5%B1%E7%A7%91%E6%8A%80) 芯片组, 但不包括上世纪古董级的 SiS 5591/5592 芯片组.")]),t._v(" "),e("dt",[t._v("VIA chipset support\nCONFIG_AGP_VIA")]),t._v(" "),e("dd",[t._v('该项仅适用于 [VIA](http://zh.wikipedia.org/wiki/%E5%A8%81%E7%9B%9B%E9%9B%BB%E5%AD%90) 芯片组. 具体支持的芯片组型号可以查看 "drivers/char/agp/via-agp.c" 中的 "via_agp_device_ids" 数组.')])])]),t._v(" "),e("dt",[t._v("VGA Arbitration\nCONFIG_VGA_ARB")]),t._v(" "),e("dd",[t._v('图形设备是通过 I/O 或内存的特定地址范围进行访问的. 大多数现代的显卡都允许对这个范围进行重新定位, 但是某些基于 PCI 的 "传统"VGA 设备仍然使用 "硬编码" 的地址范围, 无法对其进行重新定位. 如果系统上有多个这样的 "传统"VGA 设备, 就会造成地址冲突, 这时候就需要进行 [VGA 仲裁](http://www.x.org/wiki/VgaArbiter/). 此选项主要用于处理多个显卡 (比如集成显卡和独立显卡) 之间的切换. 如果你的系统上有多个显卡, 可以选 "Y", 否则应该选 "N". 详情参见 "[Documentation/vgaarbiter.txt](https://www.kernel.org/doc/Documentation/vgaarbiter.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Maximum number of GPUs\nCONFIG_VGA_ARB_MAX_GPUS")]),t._v(" "),e("dd",[t._v("最多允许支持多少个显卡")])])]),t._v(" "),e("dt",[t._v("Laptop Hybrid Graphics - GPU switching support\nCONFIG_VGA_SWITCHEROO")]),t._v(" "),e("dd",[t._v('支持多个显卡之间的切换 (通常是在集显和独显之间), 这项技术有多个不同的名称:"[Hybrid Graphics](http://www.amd.com/cn/products/technologies/ati-hybrid-graphics/Pages/ati-hybrid-graphics.aspx)","[PowerXpress](http://baike.baidu.com/view/2165615.htm)","[HybridPower](http://baike.baidu.com/view/1632721.htm)". 这项特性主要用于笔记本, 台式机一般不支持.')]),t._v(" "),e("dt",[t._v("Direct Rendering Manager (XFree86 4.1.0 and higher DRI support)\nCONFIG_DRM")]),t._v(" "),e("dd",[t._v('[DRI](http://blog.csdn.net/datangsoc/article/details/5900025)([Direct Rendering Infrastructure](http://en.wikipedia.org/wiki/Direct_Rendering_Infrastructure)) 允许应用程序以高效安全的方式直接访问 GPU, 主要用于硬件 3D 加速. 不需要图形界面的用户应该选 "N". 桌面用户建议选 "Y".[提示]KMS+DRI2+GEM+UXA+[Wayland](http://linuxtoy.org/archives/gnome-to-wayland-roadmap.html) 是 [Linux 图形革命](http://muses2006.blog.163.com/blog/static/11436549520094411927792/)的基石, 这里还有两篇需要越墙的文章可以帮助加深对 Linux 图形技术的理解:(1) [关于 Xorg 的一些整理](http://huanhaoadam.wordpress.com/2010/03/03/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E7%99%BE%E5%9B%9B%E5%8D%81%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8Exorg%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%B4%E7%90%86/),(2) [厘清了 xorg 里的一些概念](http://www.linuxgraphics.cn/xwindow/some_concepts_of_xorg.html).')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable legacy fbdev support for your modesetting driver\nCONFIG_DRM_FBDEV_EMULATION")]),t._v(" "),e("dd",[t._v('为传统的 fbdev 设备提供支持, 由于 CONFIG_FRAMEBUFFER_CONSOLE 依赖于 fbdev 设备, 因此务必选 "Y", 否则将会遭遇控制台黑屏.')])])]),t._v(" "),e("dt",[t._v("Allow to specify an EDID data set instead of probing for it\nCONFIG_DRM_LOAD_EDID_FIRMWARE")]),t._v(" "),e("dd",[t._v('[EDID](http://zh.wikipedia.org/wiki/EDID)([扩展显示器识别数据](http://blog.csdn.net/zhouzhuan2008/article/details/8072745)) 是一种 [VESA(视频电子标准协会)](http://zh.wikipedia.org/wiki/VESA) 制定的标准数据格式, 其中包含有关显示器的各种参数: 供应商信息, 最大图像尺寸, 颜色设置, 厂商预设置, 频率范围, 显示器名, 序列号字符串等等. EDID 保存在显示器的 PROM 或 EEPROM 中, 显卡或 [read-edid](http://www.polypux.org/projects/read-edid/) 一般通过 I2C 总线使用 DDC 协议进行读取. 但是在某些脑残的硬件 (显示器或显卡) 上却不能正确获取 EDID 数据. 此选项就是为了解决这个问题而设置的. 此选项可以允许从 "/lib/firmware/" 目录加载 EDID 数据, 或者将 EDID 数据在编译时直接嵌入内核. 不确定的选 "N". 详情参见 "[Documentation/EDID/HOWTO.txt](https://www.kernel.org/doc/Documentation/EDID/HOWTO.txt)" 文档.[提示]EDID 的继任者是 [DisplayID](http://wenku.baidu.com/view/ee4dcfc608a1284ac850439e), 但目前 DisplayID 尚未被广泛应用.')]),t._v(" "),e("dt",[t._v("I2C encoder or helper chips")]),t._v(" "),e("dd",[t._v("I2C 编码器或辅助芯片")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Chrontel ch7006 TV encoder\nCONFIG_DRM_I2C_CH7006")]),t._v(" "),e("dd",[t._v("[Chrontel ch7006](http://www.chrontel.com/index.php/ch7006-tv-encoder) 电视解码器支持. 某些 nVidia 显卡上有这个芯片. 此选项仅对 NVIDIA 显卡开源驱动 ([nouveau](http://nouveau.freedesktop.org/wiki/)) 有意义.")]),t._v(" "),e("dt",[t._v("Silicon Image sil164 TMDS transmitter\nCONFIG_DRM_I2C_SIL164")]),t._v(" "),e("dd",[t._v("[Silicon Image SIL164](http://www.siliconimage.com/solutions/pc/hdmi-dvi-tx/) [最小化传输差分信号](http://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E5%8C%96%E5%82%B3%E8%BC%B8%E5%B7%AE%E5%88%86%E8%A8%8A%E8%99%9F) ([TMDS](http://www.dzsc.com/data/html/2009-6-16/76874.html)) 发送器, 用于实现 [DVI](http://zh.wikipedia.org/wiki/DVI) 信号的合成和发送. TMDS 不如 [LVDS](http://zh.wikipedia.org/wiki/%E4%BD%8E%E9%9B%BB%E5%A3%93%E5%B7%AE%E5%88%86%E4%BF%A1%E8%99%9F) 应用广泛, 仅在某些 nVidia 显卡上有出现.")]),t._v(" "),e("dt",[t._v("NXP Semiconductors TDA998X HDMI encoder\nCONFIG_DRM_I2C_NXP_TDA998X")]),t._v(" "),e("dd",[t._v("[NXP(恩智浦)](http://www.cn.nxp.com/) TDA998X [HDMI](http://zh.wikipedia.org/wiki/HDMI) 发射器. 用于实现 [HDMI](http://diy.pconline.com.cn/display/study_screen/1102/2348992_all.html) 信号的合成和发送.")])])]),t._v(" "),e("dt",[t._v("3dfx Banshee/Voodoo3+\nCONFIG_DRM_TDFX")]),t._v(" "),e("dd",[t._v("[3dfx](http://baike.baidu.com/view/993916.htm) Banshee/Voodoo3+ 系列古董显卡")]),t._v(" "),e("dt",[t._v("ATI Rage 128\nCONFIG_DRM_R128")]),t._v(" "),e("dd",[t._v("[ATI Rage 128](http://baike.baidu.com/view/1493224.htm) 系列古董显卡")]),t._v(" "),e("dt",[t._v("ATI Radeon\nCONFIG_DRM_RADEON")]),t._v(" "),e("dd",[t._v('Radeon 系列显卡开源驱动 ([radeon](http://wiki.x.org/wiki/radeon/)).[提示]R600 及更新的 GPU 需要额外的固件 / 微代码 ([radeon-ucode](http://git.exherbo.org/summer/packages/firmware/radeon-ucode/))的帮助才能使用开源驱动. 如果你打算在 R600 及更新的 GPU 上使用此开源驱动, 那么建议选 "M" 而不是 "Y". 因为 "Y" 需要将微代码 (通常位于 "/lib/firmware/radeon/" 目录) 一起编译进内核(使用 CONFIG_EXTRA_FIRMWARE="radeon/[GPU-MODEL](http://wiki.gentoo.org/wiki/Radeon#Firmware).bin").[注意] 如果你打算使用目前尚不支持 [KMS](https://wiki.archlinux.org/index.php/Kernel_Mode_Setting_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29) 的 Radeon 闭源驱动 ([Catalyst/fglrx](http://support.amd.com/US/GPUDOWNLOAD/Pages/index.aspx)), 那么此项必须选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable userspace modesetting on radeon (DEPRECATED)\nCONFIG_DRM_RADEON_UMS")]),t._v(" "),e("dd",[t._v('禁用 KMS 支持. 目的是为了兼容远古版本的 DDX 驱动. 除非你有充足的理由, 否则请选 "N".')])])]),t._v(" "),e("dt",[t._v("Nouveau (nVidia) cards\nCONFIG_DRM_NOUVEAU")]),t._v(" "),e("dd",[t._v('nVidia 系列显卡开源驱动 ([nouveau](http://nouveau.freedesktop.org/wiki/)).[注意] 如果你打算使用也许永远不会支持 [KMS](http://zh.wikipedia.org/wiki/%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F%E8%AE%BE%E5%AE%9A) 的 nVidia 闭源驱动 ([nvidia-drivers](http://www.nvidia.com/object/unix.html)), 那么此项必须选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Maximum debug level\nCONFIG_NOUVEAU_DEBUG")]),t._v(" "),e("dd",[t._v('最大调试级别, 也就是最高允许显示的调试信息详细程度. 取值范围是 [0,7], 数字越大, 在内核中编入的调试信息就越多, 建议设为 "4", 过大的级别会导致驱动运行缓慢.')]),t._v(" "),e("dt",[t._v("Default debug level\nCONFIG_NOUVEAU_DEBUG_DEFAULT")]),t._v(" "),e("dd",[t._v('默认调试级别, 必须小于等于 CONFIG_NOUVEAU_DEBUG 的值. 数字越大, 输出的调试信息就越详细, 建议设为 "2", 过大的级别会导致驱动运行缓慢.')]),t._v(" "),e("dt",[t._v("Support for backlight control\nCONFIG_DRM_NOUVEAU_BACKLIGHT")]),t._v(" "),e("dd",[t._v('允许调整显示器背光亮度, 主要用于液晶显示屏等使用背光技术的显示器. 建议选 "Y".')])])]),t._v(" "),e("dt",[t._v("Intel I810\nCONFIG_DRM_I810")]),t._v(" "),e("dd",[t._v("专为古董级 Intel 集成显卡 (i810/i815) 准备的驱动")]),t._v(" "),e("dt",[t._v("Intel 8xx/9xx/G3x/G4x/HD Graphics\nCONFIG_DRM_I915")]),t._v(" "),e("dd",[t._v("Intel [GMA](http://en.wikipedia.org/wiki/Intel_GMA)(芯片组集成显卡) 与 [HD Graphics](http://zh.wikipedia.org/wiki/Intel_HD_Graphics)(核心集成显卡) 开源驱动 ([intel](https://01.org/linuxgraphics/)). 除了个别老古董 (i810/i815) 与基于 PowerVR 的芯片 (Atom z5xx) 之外, 此驱动支持所有 Intel 集成显卡(包括 Atom 中的集成显卡).[提示] [三大主流显卡厂商对 Linux 的驱动支持](http://linuxtoy.org/archives/compare-linux-driver-support-between-three-major-gpus.html),Intel 是最彻底的, 官方只提供开源驱动.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable modesetting on intel by default\nCONFIG_DRM_I915_KMS")]),t._v(" "),e("dd",[t._v('默认开启 [KMS](http://zh.wikipedia.org/wiki/%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F%E8%AE%BE%E5%AE%9A)([Kernel Mode Setting](https://wiki.archlinux.org/index.php/Kernel_Mode_Setting_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29))特性, 作用是可以在内核级别 (而不是用户级别) 设置显示分辨率和颜色深度. KMS 使用了更新的技术, 可以减少失真, 增强 3D 性能, 甚至可以使用内核的节能功能. KMS 是大势所趋, 只要用户层软件不太旧 (2010 年之后), 都建议开启.[注意] 开启此项后, 应该:(1)关闭 CONFIG_FB_INTEL 选项并禁止加载任何 framebuffer 驱动 (包括 CONFIG_FB_UVESA),(2) 取消内核引导参数 "vga=xxx" 和 "video=xxx",(3)必须开启 CONFIG_FRAMEBUFFER_CONSOLE 选项.')]),t._v(" "),e("dt",[t._v("Enable legacy fbdev support for the modesetting intel driver\nCONFIG_DRM_I915_FBDEV")]),t._v(" "),e("dd",[t._v('使用此驱动为传统的 fbdev 设备提供支持, 由于 CONFIG_FRAMEBUFFER_CONSOLE 依赖于 fbdev 设备, 因此务必选 "Y", 否则将会遭遇控制台黑屏.')]),t._v(" "),e("dt",[t._v("Enable preliminary support for prerelease Intel hardware by default\nCONFIG_DRM_I915_PRELIMINARY_HW_SUPPORT")]),t._v(" "),e("dd",[t._v('为尚未正式发布的显卡提供支持, 相当于设置 "i915.preliminary_hw_support=1" 引导参数. 一般应该选 "N"')]),t._v(" "),e("dt",[t._v("Enable userspace modesetting on Intel hardware (DEPRECATED)\nCONFIG_DRM_I915_UMS")]),t._v(" "),e("dd",[t._v('为古董级的 DDX 驱动提供用户空间模式设置支持. 选 "N".')])])]),t._v(" "),e("dt",[t._v("Matrox g200/g400\nCONFIG_DRM_MGA")]),t._v(" "),e("dd",[t._v("Matrox G200, G400, G450 系列古董显卡")]),t._v(" "),e("dt",[t._v("SiS video cards\nCONFIG_DRM_SIS")]),t._v(" "),e("dd",[t._v("SiS 630 系列古董显卡")]),t._v(" "),e("dt",[t._v("Via unichrome video cards\nCONFIG_DRM_VIA")]),t._v(" "),e("dd",[t._v("Via unichrome 系列古董显卡")]),t._v(" "),e("dt",[t._v("Savage video cards\nCONFIG_DRM_SAVAGE")]),t._v(" "),e("dd",[t._v("Savage3D/4/SuperSavage/Pro/Twister 系列古董显卡")]),t._v(" "),e("dt",[t._v("DRM driver for VMware Virtual GPU\nCONFIG_DRM_VMWGFX")]),t._v(" "),e("dd",[t._v('VMware SVGA2 虚拟显卡驱动. 支持 3D 加速, 支持 KMS. 如果你打算在 VMware 内使用图形化界面, 建议选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable framebuffer console under vmwgfx by default\nCONFIG_DRM_VMWGFX_FBCON")]),t._v(" "),e("dd",[t._v('如果你使用的 VMware Tools 不太旧就选 "Y".')])])]),t._v(" "),e("dt",[t._v("Intel GMA5/600 KMS Framebuffer\nCONFIG_DRM_GMA500")]),t._v(" "),e("dd",[t._v("Intel 基于 Poulsbo 架构的集成显卡实验性支持. 此类显卡并不常见, 仅用于 Atom z5xx 系列处理器.")]),t._v(" "),e("dt",[t._v("DisplayLink\nCONFIG_DRM_UDL")]),t._v(" "),e("dd",[t._v("[DisplayLink](http://baike.baidu.com/view/1485403.htm) 是一个通过 USB 接口实现显示器连接到电脑的连接技术, 可以非常简单的连接电脑和多个显示设备, 常用于通过 USB 接口扩展虚拟的电脑的桌面. 目前 DisplayLink 技术最多可以支持 [6 台显示器同时显示](http://publish.it168.com/2008/0825/20080825015701.shtml) 32 位色彩的任意分辨率画面.")]),t._v(" "),e("dt",[t._v("AST server chips\nCONFIG_DRM_AST")]),t._v(" "),e("dd",[t._v("AST 系列显卡实验性支持. 此种显卡仅出现在服务器环境.")]),t._v(" "),e("dt",[t._v("Kernel modesetting driver for MGA G200 server engines\nCONFIG_DRM_MGAG200")]),t._v(" "),e("dd",[t._v("[MGA G200 系列服务器显卡芯片](https://cateee.net/lkddb/web-lkddb/DRM_MGAG200.html)的 KMS 支持.[注意] 仅用于服务器芯片, 不要用于桌面芯片! 此驱动需要 v0.3.0 版本的用户空间 modesetting 驱动.")]),t._v(" "),e("dt",[t._v("Cirrus driver for QEMU emulated device\nCONFIG_DRM_CIRRUS_QEMU")]),t._v(" "),e("dd",[t._v("这是 [QEMU](http://www.ibm.com/developerworks/cn/linux/l-qemu/) 虚拟的 cirrus 显卡 KMS 驱动, 仅可用于客户机中. 千万不要用于真正的物理 cirrus 显卡.")]),t._v(" "),e("dt",[t._v("QXL virtual GPU\nCONFIG_DRM_QXL")]),t._v(" "),e("dd",[t._v("用于 [SPICE](http://os.51cto.com/art/201104/255032.htm) 的虚拟桌面的 QXL 虚拟显卡 (cirrus)KMS 支持.")]),t._v(" "),e("dt",[t._v("Lowlevel video output switch controls\nCONFIG_VIDEO_OUTPUT_CONTROL")]),t._v(" "),e("dd",[t._v('底层视频输出开关控制 (通过 sysfs 接口). 这是 ACPI 视频控制所依赖的功能, 也被许多显卡驱动所依赖. 可以选 "N", 若有其它驱动需要它, 会被自动选中.')]),t._v(" "),e("dt",[t._v("Support for frame buffer devices\nCONFIG_FB")]),t._v(" "),e("dd",[t._v("[帧缓冲](http://baike.baidu.com/view/1040793.htm) ([framebuffer](http://bbs.chinaunix.net/thread-1932291-1-1.html))设备 (/dev/fb*) 是一种对图形硬件的抽象, 它把屏幕上的所有像素点都直接映射到一段线性的内存空间, 这样就为软件提供了访问图形硬件的统一接口, 这些软件不需要了解硬件的底层细节(例如寄存器), 只要简单的改变相应内存位置的值, 就能改变屏幕上显示的内容(颜色 / 亮度等).Xorg 的高度可移植性也就根源于此. 图形界面用户必选.[CJKTTY](https://github.com/gentoo-zh/linux-cjktty/) 补丁也依赖于它.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable firmware EDID\nCONFIG_FIRMWARE_EDID")]),t._v(" "),e("dd",[t._v('[EDID](http://zh.wikipedia.org/wiki/EDID)([扩展显示器识别数据](http://av.imaschina.com/issue/t_obs/2010/5476.html)) 保存在显示器的 PROM 或 EEPROM 中, 显卡或 [read-edid](http://www.polypux.org/projects/read-edid/) 一般通过 I2C 总线使用 DDC 协议进行读取. 但是在某些脑残的硬件 (显示器或显卡) 上却不能正确获取 EDID 数据. 此选项就是为了解决这个问题而设置的 (参见 CONFIG_DRM_LOAD_EDID_FIRMWARE). 开启此项后, 将允许三种驱动(nvidiafb,i810fb,savagefb) 通过 Video BIOS 获取 EDID. 建议选 "N", 仅在你确实遭遇 EDID 读取失败, 并且确实需要使用 nvidiafb/i810fb/savagefb 驱动的时候才需要考虑选 "Y".[提示]EDID 的继任者是 [DisplayID](http://wenku.baidu.com/view/ee4dcfc608a1284ac850439e), 但目前 DisplayID 尚未被广泛应用.')]),t._v(" "),e("dt",[t._v("Framebuffer foreign endianness support\nCONFIG_FB_FOREIGN_ENDIAN")]),t._v(" "),e("dd",[t._v('如果你想混合使用不同[字节序](http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F)的主板和显卡 (在 Little-Endian 主板上使用 Big-Endian 显卡, 或者相反), 可以选 "Y". 绝大多数人都应该选 "N". 除非你确实知道自己在做什么.')]),t._v(" "),e("dt",[t._v("Enable Video Mode Handling Helpers\nCONFIG_FB_MODE_HELPERS")]),t._v(" "),e("dd",[t._v('使用 [GTF](http://en.wikipedia.org/wiki/Generalized_Timing_Formula) 和 EDID 解析程序来帮助处理显示模式, 建议选 "N", 若有其他选项依赖于它时, 会自动选上.')]),t._v(" "),e("dt",[t._v("Enable Tile Blitting Support\nCONFIG_FB_TILEBLITTING")]),t._v(" "),e("dd",[t._v('此项仅对 matroxfb 驱动有意义, 建议选 "N", 若有其他选项依赖于它时, 会自动选上')]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{虽然此处省略的各种 Framebuffer 驱动提供了对图形硬件的统一抽象, 让 Xorg 不必与硬件直接对话, 但这些 Framebuffer 驱动仅能提供 2D 功能, 在如今 3D 硬件加速和视频硬件解码早已铺天盖地的情况下, 让 Xorg 直接与 GPU 硬件对话才更符合潮流, 而传统的 Framebuffer 驱动 (CONFIG_FB_*) 反而成为了绊脚石, 不但没有必要与新的 DRI 驱动 (CONFIG_DRM_*) 共存, 而且还会相互冲突. 所以切勿选中这里省略的任何 Framebuffer 驱动. 除非你确实知道自己在做什么.}")])])]),t._v(" "),e("dt",[t._v("Exynos Video driver support\nCONFIG_EXYNOS_VIDEO")]),t._v(" "),e("dd",[t._v("三星基于 ARM 构的 [EXYNOS](http://baike.baidu.com/view/5821967.htm) 处理器内置显卡")]),t._v(" "),e("dt",[t._v("Backlight & LCD device support\nCONFIG_BACKLIGHT_LCD_SUPPORT")]),t._v(" "),e("dd",[t._v("背光与液晶支持.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Lowlevel LCD controls\nCONFIG_LCD_CLASS_DEVICE")]),t._v(" "),e("dd",[t._v("液晶 (LCD) 底层控制框架. 用于控制对比度和 LCD 开关(而不是背光亮度). 这些 LCD 硬件目前仅用于智能手机 / 平板电脑等嵌入式环境.")]),t._v(" "),e("dt",[t._v("Lowlevel Backlight controls\nCONFIG_BACKLIGHT_CLASS_DEVICE")]),t._v(" "),e("dd",[t._v("背光 (Backlight) 底层控制框架. 用于控制背光源的亮度和开关. 选中此项后还需要从子项中选择特定于硬件的驱动.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Generic PWM based Backlight Driver\nCONFIG_BACKLIGHT_PWM")]),t._v(" "),e("dd",[t._v("液晶显示器 (包括台式机和笔记本) 的[背光亮度调整方式](http://www.zhihu.com/question/21127560)有两种:(1)[PWM 调光](http://www.cnledw.com/knowledge/detail-21714.htm),(2) 非 PWM 调光. 目前主流的液晶显示器基本上都是 PWM 调光, 仅有少数是[非 PWM 调光型号](http://www.chiphell.com/thread-650884-1-1.html) (而且越来越少).")]),t._v(" "),e("dt",[t._v("Apple Backlight Driver\nCONFIG_BACKLIGHT_APPLE")]),t._v(" "),e("dd",[t._v("基于 Intel 处理器的苹果 Macbook 笔记本和 iMac 台式机显示器背光控制")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{其它省略的驱动仅用于智能手机 / 平板电脑等嵌入式环境}")])])])])]),t._v(" "),e("dt",[t._v("Console display driver support")]),t._v(" "),e("dd",[t._v('控制台显示驱动. 每个人都需要. 下面的 "VGA text" 与 "Framebuffer" 至少应该选中一个.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("VGA text console\nCONFIG_VGA_CONSOLE")]),t._v(" "),e("dd",[t._v('VGA 文本模式控制台. 建议选 "N". 仅某些服务器环境可以考虑选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable Scrollback Buffer in System RAM\nCONFIG_VGACON_SOFT_SCROLLBACK")]),t._v(" "),e("dd",[t._v('标准的 VGA 控制台回滚缓冲区位于 VGA RAM 中, 但是其空间非常小, 并且是固定的. 开启此项后, 就可以在内存中开辟更大的屏幕回滚缓冲区, 这将允许你回滚更多的屏幕 (Shift+PageUp), 但是控制台的速度会略有下降. 经常使用文本控制台的可以选 "Y", 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Scrollback Buffer Size (in KB)\nCONFIG_VGACON_SOFT_SCROLLBACK_SIZE")]),t._v(" "),e("dd",[t._v("在内存中开辟的屏幕回滚缓冲区大小. 每个 80x25 屏幕需要 4KB 内存")])])])])]),t._v(" "),e("dt",[t._v("Framebuffer Console support\nCONFIG_FRAMEBUFFER_CONSOLE")]),t._v(" "),e("dd",[t._v('基于 Framebuffer 的图形模式控制台. KMS 特性依赖于它.[CJKTTY](https://github.com/gentoo-zh/linux-cjktty/) 补丁也依赖于它. 桌面用户必选 "Y"(使用了 CONFIG_DRM_* 的用户必须开启), 服务器以 UEFI 方式启动的也必选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Map the console to the primary display device\nCONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY")]),t._v(" "),e("dd",[t._v('选 "Y" 表示自动将控制台映射到 "主" 显卡, 选 "N" 表示自动将控制台映射到第一个加载的显卡驱动. 无论是否选中此项, 都可以通过 "fbcon=map:N" 内核引导参数更改映射关系. 仅在系统拥有多个显卡时此选项才有意义. 参见 "[Documentation/fb/fbcon.txt](https://www.kernel.org/doc/Documentation/fb/fbcon.txt)" 文档.')]),t._v(" "),e("dt",[t._v("Framebuffer Console Rotation\nCONFIG_FRAMEBUFFER_CONSOLE_ROTATION")]),t._v(" "),e("dd",[t._v('显示画面旋转, 由于是纯软件方式实现, 所以会大大降低显示速度, 除非你确实需要, 否则建议选 "N". 若使用了 [CJKTTY](https://github.com/gentoo-zh/linux-cjktty/) 补丁, 则必须选 "N".')]),t._v(" "),e("dt",[t._v("Support for the Framebuffer Console Decorations\nCONFIG_FB_CON_DECOR")]),t._v(" "),e("dd",[t._v('允许在控制台上显示[背景图像](http://linux-wiki.cn/images/b/bf/Debian_bootsplash.jpg), 例如在系统启动时, 在一堆滚动的字符背后显示漂亮的[背景图像](http://fatcat.ftj.agh.edu.pl/~przyboro/other/kon.png). 当然, 要实现这个功能, 还需要用户空间程序的帮助. 详见 "[Documentation/fb/fbcondecor.txt](https://www.kernel.org/doc/Documentation/fb/fbcondecor.txt)" 文档以及 [fbsplash](http://wiki.gentoo.org/wiki/Fbsplash) 的 wiki 页.')])])])])]),t._v(" "),e("dt",[t._v("Bootup logo\nCONFIG_LOGO")]),t._v(" "),e("dd",[t._v("启动时显示 linux 的 logo(一幅企鹅图像), 企鹅的数量表示内核检测到的 CPU 数目, 喜欢炫一下的就选吧. 子项是三种不同质量的图片, 分别是黑白, 16 色, 224 色. 按需选择.")])])]),t._v(" "),e("dt",[t._v("Sound card support\nCONFIG_SOUND")]),t._v(" "),e("dd",[t._v("声卡支持")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Preclaim OSS device numbers\nCONFIG_SOUND_OSS_CORE_PRECLAIM")]),t._v(" "),e("dd",[t._v('开启此项后, 只要 OSS 支持被开启, 无论相应的模块是否被加载, 内核都会预先声明所有 OSS 设备号. 当其中一个设备被打开时, 将会尝试使用 "sound-slot/service-*" 与 "char-major-*" 两种别名去加载相应的模块. 关闭此项后, 内核将仅声明实际使用中的 OSS 设备号. 当打开一个不存在的设备时, 将会仅尝试使用标准的 "char-major-*" 别名去加载相应的模块. 由于 "sound-slot/service-*" 将会在未来移除, 此选项仅是一个为了兼容性而保留的过渡选项, 未来会被移除 (相当于设为 "N").')]),t._v(" "),e("dt",[t._v("Advanced Linux Sound Architecture\nCONFIG_SND")]),t._v(" "),e("dd",[t._v("[ALSA](http://blog.csdn.net/absurd/article/details/1323006)(高级 Linux 声音架构) 是内核默认的声音子系统. ALSA 除了提供了声音设备的驱动, 还提供了一个用户空间的函数库, 这样用户空间程序就可以通过统一的 API 使用驱动功能, 而不必直接与内核驱动交互.[吐槽][Linux 音频系统](http://www.cnblogs.com/jiqingwu/p/linux_sound_system.html), 比意大利面条更混乱的系统!")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Sequencer support\nCONFIG_SND_SEQUENCER")]),t._v(" "),e("dd",[t._v("[MIDI](http://baike.baidu.com/view/7969.htm) "),e("pangu"),t._v(' [音序器](http://baike.baidu.com/view/494975.htm)支持, 如果你是 MIDI 玩家, 请选 "Y", 但如果你不知道 MIDI 是什么, 请选 "N".')],1),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Sequencer dummy client\nCONFIG_SND_SEQ_DUMMY")]),t._v(" "),e("dd",[t._v("除非你要同时连接到多个 MIDI 设备或应用程序, 否则请不要选中")])])]),t._v(" "),e("dt",[t._v("OSS Mixer API\nCONFIG_SND_MIXER_OSS")]),t._v(" "),e("dd",[t._v("模拟 OSS 混音器 API(/dev/mixer*), 某些老旧的程序仍然使用它, 建议不选")]),t._v(" "),e("dt",[t._v("OSS PCM (digital audio) API\nCONFIG_SND_PCM_OSS")]),t._v(" "),e("dd",[t._v("模拟 OSS 数字音频 ([PCM](http://blog.csdn.net/DroidPhone/article/details/6308006))API(/dev/dsp*), 某些老旧的程序仍然使用它, 建议不选.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("OSS PCM (digital audio) API - Include plugin system\nCONFIG_SND_PCM_OSS_PLUGINS")]),t._v(" "),e("dd",[t._v('让 ALSA 模拟的 OSS PCM API 支持 channel/format/rate 的转换. 选 "N", 除非你确实知道为什么要选 "Y".')])])]),t._v(" "),e("dt",[t._v("OSS Sequencer API\nCONFIG_SND_SEQUENCER_OSS")]),t._v(" "),e("dd",[t._v("模拟 OSS 音序器 (/dev/sequencer,/dev/music), 某些老旧的程序仍然使用它, 建议不选")]),t._v(" "),e("dt",[t._v("HR-timer backend support\nCONFIG_SND_HRTIMER")]),t._v(" "),e("dd",[t._v("允许将高精度定时器 (CONFIG_HIGH_RES_TIMERS) 用作 ALSA 高精度时间源, 建议选中")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Use HR-timer as default sequencer timer\nCONFIG_SND_SEQ_HRTIMER_DEFAULT")]),t._v(" "),e("dd",[t._v("将高精度定时器 (HR-timer) 当作默认的时序脉冲发生器时间源, 建议选中")])])]),t._v(" "),e("dt",[t._v("Dynamic device file minor numbers\nCONFIG_SND_DYNAMIC_MINORS")]),t._v(" "),e("dd",[t._v('动态分配 ALSA 设备的次设备号. 如果你有 8 个以上的声卡, 可以选 "Y", 否则应该选 "N".')]),t._v(" "),e("dt",[t._v("Support old ALSA API\nCONFIG_SND_SUPPORT_OLD_API")]),t._v(" "),e("dd",[t._v('支持已被废弃的老旧版本的 ALSA PCM API, 选 "N".')]),t._v(" "),e("dt",[t._v("Verbose procfs contents\nCONFIG_SND_VERBOSE_PROCFS")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Verbose printk\nCONFIG_SND_VERBOSE_PRINTK")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Debug\nCONFIG_SND_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Generic sound devices\nCONFIG_SND_DRIVERS")]),t._v(" "),e("dd",[t._v("通用声音设备")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("PC-Speaker support (READ HELP!)\nCONFIG_SND_PCSP")]),t._v(" "),e("dd",[t._v('如果你有声卡, 务必选 "N". 如果你的系统没有声卡, 仅在认真阅读了帮助之后, 确实知道自己在干什么的情况下, 才可以开启此项.')]),t._v(" "),e("dt",[t._v("Dummy (/dev/null) soundcard\nCONFIG_SND_DUMMY")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Generic loopback driver (PCM)\nCONFIG_SND_ALOOP")]),t._v(" "),e("dd",[t._v("[PCM](http://zh.wikipedia.org/wiki/%E8%84%88%E8%A1%9D%E7%B7%A8%E7%A2%BC%E8%AA%BF%E8%AE%8A) 环回 (loopback) 设备非常类似于网卡的环回接口(127.0.0.1), 它会将输入的音频流原封不动的返回给用户空间. PCM 回环设备常用来将 A 程序输出的音频流作为 B 程序的输入(A 以写模式打开环回设备, 而 B 以读模式打开), 比如用 B 程序记录 A 程序的输出, 或做进一步的处理.")]),t._v(" "),e("dt",[t._v("Virtual MIDI soundcard\nCONFIG_SND_VIRMIDI")]),t._v(" "),e("dd",[t._v('虚拟 [MIDI](http://zh.wikipedia.org/wiki/MIDI) 驱动, 允许将使用原始 MIDI 设备的应用程序连接到音序器客户端, 如果你不知道 MIDI 是什么就选 "N".')]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处省略几种 MIDI 设备 (事实上大部分人都没有这些设备)}")]),t._v(" "),e("dt",[t._v("AC97 Power-Saving Mode\nCONFIG_SND_AC97_POWER_SAVE")]),t._v(" "),e("dd",[t._v('[AC97](http://baike.baidu.com/view/117423.htm)(Audio Codec 97) 自动节能模式支持. 在此模式下, 如果音频设备闲置超过 "/sys/module/snd_ac97_codec/parameters/power_save" 设定的秒数 ("0" 表示关闭节能模式), 那么驱动程序将会关闭音频设备以节约电力. 建议选 "Y". 详见 "[Documentation/sound/alsa/powersave.txt](https://www.kernel.org/doc/Documentation/sound/alsa/powersave.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Default time-out for AC97 power-save mode\nCONFIG_SND_AC97_POWER_SAVE_DEFAULT")]),t._v(" "),e("dd",[t._v('默认的超时秒数, 也就是 "/sys/module/snd_ac97_codec/parameters/power_save" 的默认值."0" 表示关闭节能模式. 建议设为 "10" 这个久经考验的合理数字.')])])])])]),t._v(" "),e("dt",[t._v("ISA sound devices\nCONFIG_SND_ISA")]),t._v(" "),e("dd",[t._v("基于 ISA 总线的声卡, 已经绝种了.")]),t._v(" "),e("dt",[t._v("PCI sound devices\nCONFIG_SND_PCI")]),t._v(" "),e("dd",[t._v("基于 PCI 总线的声卡, 绝大多数声卡都是 PCI 接口")]),t._v(" "),e("dd",[e("dl",[e("dt",{staticClass:"omit"},[t._v("{此处省略的声卡按实际情况选择即可 (都是些比较旧的 AC97 声卡)}")]),t._v(" "),e("dt",[t._v("Intel HD Audio\nCONFIG_SND_HDA_INTEL")]),t._v(" "),e("dd",[t._v('符合 [Intel HD Audio](http://acc.pconline.com.cn/vocality/study_vocality/0801/1212973_all.html) 规范的声卡是目前的主流声卡. 如果选 "M", 那么下面的每个驱动也都会被编译成模块, 如果选 "Y", 那么下面的每个驱动也都会直接编译进内核.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Pre-allocated buffer size for HD-audio driver\nCONFIG_SND_HDA_PREALLOC_SIZE")]),t._v(" "),e("dd",[t._v('为 HD-audio 驱动程序预先分配的缓冲区大小 (kB), 较大的值拥有更好的性能, 例如对于使用 [PulseAudio](http://zh.wikipedia.org/zh-cn/PulseAudio) 声音服务器的系统来说, 推荐使用 "4096". 默认值 "64" 仅仅是为了历史兼容的原因.[提示]ALSA+PulseAudio 是目前的主流搭配.')]),t._v(" "),e("dt",[t._v("Build hwdep interface for HD-audio driver\nCONFIG_SND_HDA_HWDEP")]),t._v(" "),e("dd",[t._v("为 HD-audio 驱动添加 hwdep 接口. 仅用于调试目的")]),t._v(" "),e("dt",[t._v("Support digital beep via input layer\nCONFIG_SND_HDA_INPUT_BEEP")]),t._v(" "),e("dd",[t._v('为 HD-audio 驱动添加数字蜂鸣 (beep) 接口. 如果你的主板没有[蜂鸣器](http://www.help315.com.cn/ask/htmldata/detail/2010/03/04/93.html) (不是能够播放音乐的扬声器), 可以考虑选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Digital beep registration mode (0=off, 1=on)\nCONFIG_SND_HDA_INPUT_BEEP_MODE")]),t._v(" "),e("dd",[t._v('设为 "0" 表示默认禁用数字蜂鸣接口, 设为 "1" 表示默认启用数字蜂鸣接口.')])])]),t._v(" "),e("dt",[t._v("Support jack plugging notification via input layer\nCONFIG_SND_HDA_INPUT_JACK")]),t._v(" "),e("dd",[t._v('通过输入层支持 [JACK](http://zh.wikipedia.org/wiki/JACK_Audio_Connection_Kit) 插件通知. JACK 是一个比 PulseAudio 更专业的声音服务器, 重点是低延迟, 是专业音频软件 (例如:[Ardour](http://zh.wikipedia.org/wiki/Ardour_%28%E8%BD%AF%E4%BB%B6%29),Rezound,LinuxSampler) 首选的音频服务器. 如果你打算使用 JACK, 可以选 "Y".[提示] 如果要[将 JACK 和 PulseAudio 一起使用](http://tonychee1989.diandian.com/about-jack-audio-connection-kit), 需要安装 PulseAudio 的 JACK 支持模块.')]),t._v(" "),e("dt",[t._v("Support initialization patch loading for HD-audio\nCONFIG_SND_HDA_PATCH_LOADER")]),t._v(" "),e("dd",[t._v("仅用于调试目的")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处省略的 HD-audio 声卡按实际情况选择即可.[提示] 如果 CONFIG_SND_HDA_INTEL 被编译为模块, 这里的每一个驱动也都会被编译成模块.}")]),t._v(" "),e("dt",[t._v("Build HDMI/DisplayPort HD-audio codec support\nCONFIG_SND_HDA_CODEC_HDMI")]),t._v(" "),e("dd",[t._v('在 HD-audio 驱动中添加 [HDMI 和 DisplayPort](http://diy.pconline.com.cn/display/study_screen/1102/2348992_all.html) 支持. 如果你需要使用 [HDMI/DisplayPort](http://tv.ea3w.com/20/206229_all.html) 接口, 可以选 "Y".')]),t._v(" "),e("dt",[t._v("Enable generic HD-audio codec parser\nCONFIG_SND_HDA_GENERIC")]),t._v(" "),e("dd",[t._v("通用 HD-audio 编解码器 ([codec](http://zh.wikipedia.org/wiki/%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8)) 支持, 必选.")]),t._v(" "),e("dt",[t._v("Default time-out for HD-audio power-save mode\nCONFIG_SND_HDA_POWER_SAVE_DEFAULT")]),t._v(" "),e("dd",[t._v('HD-audio 自动节能模式默认的超时秒数."0" 表示关闭节能模式. 建议设为 "10" 这个久经考验的合理数字. 详见 "[Documentation/sound/alsa/powersave.txt](https://www.kernel.org/doc/Documentation/sound/alsa/powersave.txt)" 文档与 CONFIG_SND_AC97_POWER_SAVE_DEFAULT 选项.')])])])])]),t._v(" "),e("dt",[t._v("SPI sound devices\nCONFIG_SND_SPI")]),t._v(" "),e("dd",[t._v("基于 SPI 总线的声卡, 仅出现在嵌入式设备上")]),t._v(" "),e("dt",[t._v("USB sound devices\nCONFIG_SND_USB")]),t._v(" "),e("dd",[t._v("基于 USB 总线的声卡, 主要是外接声卡, 并不常用")]),t._v(" "),e("dt",[t._v("FireWire sound devices\nCONFIG_SND_FIREWIRE")]),t._v(" "),e("dd",[t._v("基于 IEEE-1394/FireWire/iLink 总线的声卡, 主要用于苹果的产品")]),t._v(" "),e("dt",[t._v("PCMCIA sound devices\nCONFIG_SND_PCMCIA")]),t._v(" "),e("dd",[t._v("基于 PCMCIA 接口的声卡, 主要是外接声卡, 并不常用")]),t._v(" "),e("dt",[t._v("ALSA for SoC audio support\nCONFIG_SND_SOC")]),t._v(" "),e("dd",[t._v("SoC 系统音频设备支持, 重点是节能支持. 仅用于嵌入式设备")])])]),t._v(" "),e("dt",[t._v("Open Sound System (DEPRECATED)\nCONFIG_SOUND_PRIME")]),t._v(" "),e("dd",[t._v('OSS 早已被废弃 (已被 ALSA 取代). 选 "N".')])])]),t._v(" "),e("dt",[t._v("HID support")]),t._v(" "),e("dd",[t._v("[HID](http://en.wikipedia.org/wiki/Human_interface_device)([人机接口设备](http://wenku.baidu.com/view/7fd4df21192e45361066f5f2.html)) 是一种定义计算机如何与人类交互的规范, 常与 USB 或蓝牙搭配使用, 常见的设备有: 键盘, 鼠标, 触摸板, 游戏杆, 遥控器, 蓝牙耳机, 游戏手柄, 手写板, 等等. 不过 HID 设备不一定要有人机接口, 只要符合 HID 规范, 就是 HID 设备.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("HID bus support\nCONFIG_HID")]),t._v(" "),e("dd",[t._v("[HID](http://www.usb.org/developers/hidpage/)(human interface device) 总线及通用 HID 层. 要使用 HID 设备就必须开启.[提示]PS/2 接口的鼠标和键盘不是 HID 设备, USB 或蓝牙接口的才是 HID 设备.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Battery level reporting for HID devices\nCONFIG_HID_BATTERY_STRENGTH")]),t._v(" "),e("dd",[t._v("为那些支持 power_supply 类的 HID 电池, 向用户空间报告电池的剩余电量 (可以通过 [upower](http://upower.freedesktop.org/) 工具显示).")]),t._v(" "),e("dt",[t._v("/dev/hidraw raw HID device support\nCONFIG_HIDRAW")]),t._v(" "),e("dd",[t._v('如果你想支持那些严格说来并不属于人机交互设备的硬件 (使用额外的 / dev/hidraw 接口), 例如显示控制装置(monitor control) 或不间断电源 (UPS) 以及某些罗技的无线鼠标接收器, 可以选 "Y". 与 CONFIG_USB_HIDDEV 选项 (/dev/hiddev) 相比,/dev/hidraw 设备直接无视一切 hid 事件(既不解析也不查找), 这样就允许应用程序直接处理和操作原始的 hid 事件, 从而避免使用用户层 libhid/libusb 库. 详见 "[Documentation/hid/hidraw.txt](https://www.kernel.org/doc/Documentation/hid/hidraw.txt)" 文档.')]),t._v(" "),e("dt",[t._v("User-space I/O driver support for HID subsystem\nCONFIG_UHID")]),t._v(" "),e("dd",[t._v('HID 子系统需要两种驱动:(1)"HID I/O Driver" 是特定于硬件的驱动, 直接与底层总线交互, 并向 "HID Device Driver" 提供了一致接口用于收发 HID 数据.(2)"HID Device Driver" 是硬件无关的通用驱动, 其任务是按照 HID 规范解析和处理来自于 "HID I/O Driver" 的 HID 数据, 并将组装好的数据通过 "HID I/O Driver" 提供的统一接口发送给底层硬件. 开启此项后, 将允许在用户空间实现 "HID I/O Driver". 不确定的选 "N". 详见 "[Documentation/hid/uhid.txt](https://www.kernel.org/doc/Documentation/hid/uhid.txt)" 文档.')]),t._v(" "),e("dt",[t._v("Generic HID driver\nCONFIG_HID_GENERIC")]),t._v(" "),e("dd",[t._v('HID 总线通用驱动, 也就是前面说的 "HID Device Driver". 它实现了对各种常见 [HID 协议](http://wenku.baidu.com/view/e9a54a3467ec102de2bd89ff.html)的支持: 键盘, 鼠标, 游戏杆, 手写板, 数字画板. 不确定的选 "Y".')]),t._v(" "),e("dt",[t._v("Special HID drivers")]),t._v(" "),e("dd",[t._v('各种不严格遵守 HID 协议的 "HID Device Driver"')]),t._v(" "),e("dd",[e("dl",[e("dt",{staticClass:"omit"},[t._v("{此处省略的硬件按实际情况选择即可}")]),t._v(" "),e("dt",[t._v("Lenovo ThinkPad USB Keyboard with TrackPoint\nCONFIG_HID_LENOVO_TPKBD")]),t._v(" "),e("dd",[t._v('带有 "小红帽 (TrackPoint)" 的联想 (Lenovo)[ThinkPad USB 键盘](http://www.thinkpads.com/2009/08/31/finally-photos-of-new-thinkpad-usb-trackpoint-keyboard/).')]),t._v(" "),e("dt",[t._v("Logitech devices\nCONFIG_HID_LOGITECH")]),t._v(" "),e("dd",[t._v("某些并不完全遵从 HID 标准的罗技 (Logitech) 外设")]),t._v(" "),e("dt",[t._v("HID Multitouch panels\nCONFIG_HID_MULTITOUCH")]),t._v(" "),e("dd",[t._v("HID [多点触控](http://zh.wikipedia.org/wiki/%E5%A4%9A%E9%BB%9E%E8%A7%B8%E6%8E%A7) ([Multitouch](http://en.wikipedia.org/wiki/Multi-touch)) 板的通用支持")]),t._v(" "),e("dt",[t._v("HID Sensors framework support\nCONFIG_HID_SENSOR_HUB")]),t._v(" "),e("dd",[t._v('HID 传感器支持框架. 详见 "[Documentation/hid/hid-sensor.txt](https://www.kernel.org/doc/Documentation/hid/hid-sensor.txt)" 文档')])])])])]),t._v(" "),e("dt",[t._v("USB HID support")]),t._v(" "),e("dd",[t._v("基于 USB 接口的 HID 设备, 这是目前最常见的 HID 设备")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("USB HID transport layer\nCONFIG_USB_HID")]),t._v(" "),e("dd",[t._v('特定于 USB 接口的 "HID I/O Driver". 用于和 USB 总线上的硬件进行交互. 只要你想使用任何基于 USB 接口的 HID 设备 (键盘, 鼠标, 游戏杆, 手写板, 手绘板, 不间断电源(UPS), 显示控制装置(monitor control), 等等), 就必须选 "Y".[例外] 在嵌入式环境中使用的 HIDBP(HID Boot Protocol)键盘和鼠标不在此列, 而且两者也不能共存.')]),t._v(" "),e("dt",[t._v("PID device support\nCONFIG_HID_PID")]),t._v(" "),e("dd",[t._v("[PID](http://zh.wikipedia.org/wiki/PID%E6%8E%A7%E5%88%B6%E5%99%A8) 兼容的力反馈设备, 例如:[Microsoft Sidewinder Force Feedback 2](http://bak1.beareyes.com.cn/2/lib/200102/28/20010228026.htm)")]),t._v(" "),e("dt",[t._v("/dev/hiddev raw HID device support\nCONFIG_USB_HIDDEV")]),t._v(" "),e("dd",[t._v('如果你想支持那些严格说来并不属于人机交互设备的硬件 (使用额外的 / dev/usb/hiddevX[char 180:96~111] 接口), 例如显示控制装置 (monitor control) 或不间断电源 (UPS) 以及某些罗技的无线鼠标接收器, 可以选 "Y". 参见 CONFIG_HIDRAW 选项.')]),t._v(" "),e("dt",[t._v("USB HID Boot Protocol drivers")]),t._v(" "),e("dd",[t._v("如果你有绝对的把握确信不为自己的键盘和鼠标使用常规的 HID 驱动, 而要使用 Boot Protocol 模式的 HID 驱动 (常见于嵌入式环境) 就选吧")])])]),t._v(" "),e("dt",[t._v("I2C HID support")]),t._v(" "),e("dd",[t._v("基于 I2C 总线的 HID 设备")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("HID over I2C transport layer\nCONFIG_I2C_HID")]),t._v(" "),e("dd",[t._v('特定于 I2C 总线的 "HID I/O Driver". 用于和 I2C 总线上的硬件进行交互. 只要你想使用任何基于 I2C 总线的 HID 设备 (键盘, 触摸板, 触摸屏, 等等), 就必须选 "Y".I2C-HID 主要用于嵌入式设备.')])])])])]),t._v(" "),e("dt",[t._v("USB support\nCONFIG_USB_SUPPORT")]),t._v(" "),e("dd",[t._v('[通用串行总线](http://www.crifan.com/files/doc/docbook/usb_basic/release/html/usb_basic.html) ([Universal Serial Bus](http://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E4%B8%B2%E8%A1%8C%E7%B8%BD%E7%B7%9A)) 的目标是统一电脑的外设接口. 目前几乎找不到没有 USB 接口的电脑, 而且各种智能设备也大多带有 USB 接口. 不要犹豫, 选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Support for Host-side USB\nCONFIG_USB")]),t._v(" "),e("dd",[t._v('主机端 (Host-side)USB 支持. 通用串行总线(USB) 是一个串行总线子系统规范, 它比传统的串口速度更快并且特性更丰富 (供电, 热插拔, 最多可接 127 个设备等), 其目标是统一 PC 外设接口. USB 总体上呈现一种树型结构, USB 的 "Host"(主设备) 被称为 "根"(也可以理解为是主板上的 USB 控制器),USB 的 "Slave"(从设备)被称为 "叶子", 而内部的节点则称为 "hub"(集线器). 只要使用任何 USB 设备都必须选中此项. 另外, 你还需要从下面选中至少一个 HCD(Host Controller Driver), 比如适用于 USB1.1 的 "UHCI HCD support" 或 "OHCI HCD support", 适用于 USB2.0 的 "EHCI HCD (USB 2.0) support". 如果你拿不准的话把他们都选中一般也不会出问题. 如果你的系统有设备端的 USB 接口(也就是你的系统可以作为 "叶子" 使用), 请到 "USB Gadget" 中进行选择.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("USB verbose debug messages\nCONFIG_USB_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("USB announce new devices\nCONFIG_USB_ANNOUNCE_NEW_DEVICES")]),t._v(" "),e("dd",[t._v('在 syslog 中记录每个新接入系统的 USB 设备的详细标识信息 (idVendor,idProduct,Manufacturer,Product,SerialNumber), 主要用于系统调试. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Enable USB persist by default\nCONFIG_USB_DEFAULT_PERSIST")]),t._v(" "),e("dd",[t._v('根据 USB 规范, 当 USB 总线被挂起 (休眠) 后, 它必须继续提供挂起电流 (1-5 毫安), 以确保 USB 设备能保持其内部状态, 并且 USB 集线器(HUB) 能够检测连接变化 (设备插入和拔出). 这在技术上被称为 "电力会话"(power session). 如果一个 USB 设备的电力会话被中断, 那么系统必须按照该设备已经被拔出进行处理, 这是一种保守的做法, 因为没有挂起电流, 计算机不可能知道外围设备究竟发生了什么变化: 也许依然保持连接, 也许已经被拔出并在同一端口上插入了一个新设备. 系统必须做最坏的打算. 默认情况下, Linux 的行为符合 USB 规范的要求. 当整个电脑进入休眠状态(例如挂起到硬盘) 时, 包括 USB 总线在内所有总线都将掉电, 然后当系统被唤醒, 所有 USB 设备都会被当做在休眠前就已经被拔出来处理. 这样做始终是安全的, 并且也是 "官方正确" 的做法. 对于大多数 USB 设备来说, 这样做没有任何问题, 但是对于 USB 存储设备 (例如移动硬盘 / U 盘) 来说, 如果在休眠前有尚未卸载的文件系统 (特别是根文件系统), 当系统被唤醒之后, 由于无法访问该文件系统, 系统可能会立即崩溃! 其实不只有掉电, 只要 "power session" 被中断(例如 BIOS 在唤醒过程中重置了 USB 控制器), 都会导致这种故障. 此选项(USB-persist) 就是为了解决这个问题而设置的, 虽然解决的不甚完美(参见 "[Documentation/usb/persist.txt](https://www.kernel.org/doc/Documentation/usb/persist.txt)"), 但是依然推荐选"Y", 除非你确实有选"N" 的理由. 当然, 最保险的做法是在休眠之前先卸载所有 USB 设备上的文件系统, 而如果根文件系统位于 USB 设备上, 就根本不使用任何休眠功能 (不论是挂起到硬盘还是挂起到内存).')]),t._v(" "),e("dt",[t._v("Dynamic USB minor allocation\nCONFIG_USB_DYNAMIC_MINORS")]),t._v(" "),e("dd",[t._v('动态分配 USB 设备的次设备号 (仅限于主设备号为 180 的字符设备[通常位于 "/dev/usb/" 目录下]). 除非你有超过 16 个同类型(仅限: 打印机, 鼠标, 扫描仪) 的 USB 设备, 否则应选 "N".[提示]即使你有 100 个 U 盘或者 USB 移动硬盘, 也不需要开启此项, 因为他们不是 "主设备号为 180 的字符设备".')]),t._v(" "),e("dt",[t._v("OTG support\nCONFIG_USB_OTG")]),t._v(" "),e("dd",[t._v('传统上, 码照相机, 手机, 打印机, 播放器, 移动硬盘等设备之间要交换数据, 都要作为 PC 的外围设备, 在 PC 的控制下进行数据交换. 一旦离开了 PC, 由于没有一个设备能够充当 PC 的 "Host" 角色, 所以无法直接通信.[USB-OTG](http://baike.baidu.com/view/146799.htm)(On-The-Go) 就是为了解决这个问题而诞生的, 它是 USB2.0 规格的补充标准, 支持 "双角色" 设备 (既可以当 Host, 也可以当 Slave), 从而实现外围设备之间的数据传送. 例如, 将数码相机直接连接到打印机上将相片打印出来. 仅在你的主板上有 [Mini-AB](http://upload.wikimedia.org/wikipedia/commons/4/44/Mini-AB-Receptacle.jpg)/[Micro-AB](http://upload.wikimedia.org/wikipedia/commons/7/71/USB_Micro-AB_receptacle.jpg) 接口 (目前仅用于嵌入式设备) 时才需要选 "Y".')]),t._v(" "),e("dt",[t._v("Rely on OTG and EH Targeted Peripherals List\nCONFIG_USB_OTG_WHITELIST")]),t._v(" "),e("dd",[t._v('将 "otg_whitelist.h" 文件用作 "OTG Targeted Peripherals List"(外设白名单), 白名单之外的 USB 外设将按照 OTG 规范的要求不被枚举 (也就是初始化). 同样,"Embedded Host" 也只支持限定的外设. 如果选 "N", 那么白名单之外的外设也同样会被枚举 (但会产生一个警告), 这将大大方便嵌入式产品的开发.')]),t._v(" "),e("dt",[t._v("Disable external hubs\nCONFIG_USB_OTG_BLACKLIST_HUB")]),t._v(" "),e("dd",[t._v('选 "Y" 将禁止枚举 (也就是初始化) 外部 USB 集线器(HUB). 这样, OTG 主机就可以通过省去对外部集线器的支持, 降低系统软硬件的成本. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("USB ULPI PHY interface support\nCONFIG_USB_ULPI_BUS")]),t._v(" "),e("dd",[t._v("ULPI(UTMI+ Low Pin Interface) 是一种 2005 年开始兴起的通用 USB 2.0 PHY 接口. 可有效地减少主机 / 外设 / On-The-Go(OTG)USB 收发器的针脚数量 (从 32 个减少到 12 个). 仅用于嵌入式设备.")]),t._v(" "),e("dt",[t._v("USB Monitor\nCONFIG_USB_MON")]),t._v(" "),e("dd",[t._v('选 "Y" 后, 将可以捕获特定 USB 外设与 USB 主控器之间的数据流量,[usbdump](http://biot.com/usbdump/) 和 [usbmon](http://www.linuxcertif.com/man/8/usbmon/) 工具依赖于此项. 详见 "[Documentation/usb/usbmon.txt](https://www.kernel.org/doc/Documentation/usb/usbmon.txt)" 文档.')]),t._v(" "),e("dt",[t._v("Enable Wireless USB extensions\nCONFIG_USB_WUSB")]),t._v(" "),e("dd",[t._v("主机端的 [WUSB](http://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A%E9%80%9A%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%AF%E6%B5%81%E6%8E%92)([无线 USB](http://network.51cto.com/art/201111/300392.htm)) 支持.")]),t._v(" "),e("dt",[t._v("Support WUSB Cable Based Association (CBA)\nCONFIG_USB_WUSB_CBAF")]),t._v(" "),e("dd",[t._v('WUSB CBA(Cable Based Association) 是一项保障主机和 WUSB 设备之间通信安全的技术. 如果你的 WUSB 设备在建立无线连接前必须先建立有线连接, 可以选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable CBA debug messages\nCONFIG_USB_WUSB_CBAF_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")])])]),t._v(" "),e("dt",[t._v("Cypress C67x00 HCD support\nCONFIG_USB_C67X00_HCD")]),t._v(" "),e("dd",[t._v('[Cypress](http://china.cypress.com/?id=167) C67x00 ([EZ-Host](http://china.cypress.com/?id=187)/[EZ-OTG](http://china.cypress.com/?id=188)) USB 1.1 "双角色" 控制器')]),t._v(" "),e("dt",[t._v("xHCI HCD (USB 3.0) support\nCONFIG_USB_XHCI_HCD")]),t._v(" "),e("dd",[t._v('[xHCI](http://baike.baidu.com/view/9007709.htm)([eXtensible Host Controller Interface](http://en.wikipedia.org/wiki/Extensible_Host_Controller_Interface)) 就是当下大红大紫的 [USB3.0](http://www.expreview.com/20142-all.html)(SuperSpeed USB) 主机控制器规范.[提示] 因为 xHCI 移除了 EHCI 中为兼容 USB1.1 而引入的 "Companion" 模式, 所以仅用一个单独的 xHCI 驱动就可以兼容所有 USB3.0/2.0/1.1 外设. 也就是说, 对于蓝色的 USB3.0 接口来说, 开启此项之后, 就不需要再额外开启 EHCI/OHCI/UHCI 选项了.[注意] 如果你的电脑上除了蓝色的 USB3.0 接口, 还存在黑色的 USB2.0 接口, 那么你仍然需要开启 EHCI/OHCI/UHCI 选项, 除非你不想使用这些黑色的 USB2.0 接口.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Debugging for the xHCI host controller\nCONFIG_USB_XHCI_HCD_DEBUGGING")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Generic xHCI driver for a platform device\nCONFIG_USB_XHCI_PLATFORM")]),t._v(" "),e("dd",[t._v('通用 [platform](http://wenku.baidu.com/view/7673feacdd3383c4bb4cd211) 设备的 xHCI 驱动. 仅用于嵌入式环境. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("EHCI HCD (USB 2.0) support\nCONFIG_USB_EHCI_HCD")]),t._v(" "),e("dd",[t._v('[EHCI](http://baike.baidu.com/view/1678341.htm)(Enhanced Host Controller Interface) 就是渐成昨日黄花的 USB2.0(HighSpeed USB) 主机控制器规范.[提示] 因为 EHCI 通过 "Companion" 模式来支持 USB1.1 设备, 所以一般还需要额外再开启 OHCI 或 UHCI 选项 (除非你不想兼容任何 USB1.1 设备). 详见 "[Documentation/usb/ehci.txt](https://www.kernel.org/doc/Documentation/usb/ehci.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Root Hub Transaction Translators\nCONFIG_USB_EHCI_ROOT_HUB_TT")]),t._v(" "),e("dd",[t._v('带有 USB2.0 接口的主板上都有一个 "根集线器"(Root Hub)以允许在无需额外购买 hub 的情况下就可以提供多个 USB 插口, 而大多数主板还在其中集成了事务转换 (Transaction Translator) 功能, 这样就不需要再额外使用一个 OHCI 或 UHCI 控制器来兼容 USB1.1, 建议选 "Y", 除非你不想兼容任何 USB1.1 设备.')]),t._v(" "),e("dt",[t._v("Improved Transaction Translator scheduling\nCONFIG_USB_EHCI_TT_NEWSCHED")]),t._v(" "),e("dd",[t._v('改变周期性调度代码的工作方式, 当多个 USB1.1 设备连接在同一个 USB2.0 集线器上时, 可以获得更高的运行速度. 建议选 "Y"')])])]),t._v(" "),e("dt",[t._v("Generic EHCI driver for a platform device\nCONFIG_USB_EHCI_HCD_PLATFORM")]),t._v(" "),e("dd",[t._v('通用 [platform](http://wenku.baidu.com/view/7673feacdd3383c4bb4cd211) 设备的 EHCI 驱动. 仅用于嵌入式环境. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("OHCI HCD support\nCONFIG_USB_OHCI_HCD")]),t._v(" "),e("dd",[t._v("OHCI(Open Host Controller Interface) 是主要用于嵌入式环境的 USB1.1(LowSpeed/FullSpeed USB) 主机控制器规范. 但也存在于某些老旧的 SiS 芯片组的 PC 上.")]),t._v(" "),e("dt",[t._v("UHCI HCD (most Intel and VIA) support\nCONFIG_USB_UHCI_HCD")]),t._v(" "),e("dd",[t._v("UHCI(Universal Host Controller Interface) 是主要用于 PC 环境的 USB1.1(LowSpeed/FullSpeed USB) 主机控制器规范.")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处省略的 USB 控制器请按照实际硬件状况选择 (基本上都仅用于嵌入式环境)}")]),t._v(" "),e("dt",[t._v("Wireless USB Host Controller Interface (WHCI) driver\nCONFIG_USB_WHCI_HCD")]),t._v(" "),e("dd",[t._v('WHCI([Wireless USB](http://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A%E9%80%9A%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%AF%E6%B5%81%E6%8E%92) Host Controller Interface) 是[无线 USB](http://baike.baidu.com/view/1621053.htm) 主机控制器规范. 目前市场上带有 WUSB 主控器的主板很少. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Host Wire Adapter (HWA) driver\nCONFIG_USB_HWA_HCD")]),t._v(" "),e("dd",[t._v("USB 接口的 3G/4G [无线上网卡](http://baike.baidu.com/view/46275.htm) (通常需要搭配 SIM 卡使用), 常见制式有: WCDMA/LTE/HSPA 等.")]),t._v(" "),e("dt",[t._v("BCMA usb host driver\nCONFIG_USB_HCD_BCMA")]),t._v(" "),e("dd",[t._v("BCMA(Broadcom specific AMBA) 总线上的 EHCI/OCHI 主机控制器支持. 仅用于嵌入式环境.")]),t._v(" "),e("dt",[t._v("SSB usb host driver\nCONFIG_USB_HCD_SSB")]),t._v(" "),e("dd",[t._v("BCMA(Broadcom specific AMBA) 总线上的 EHCI/OCHI 主机控制器支持. 仅用于嵌入式环境.")]),t._v(" "),e("dt",[t._v("Inventra Highspeed Dual Role Controller (TI, ADI, ...)\nCONFIG_USB_MUSB_HDRC")]),t._v(" "),e("dd",[t._v("一系列基于 [Mentor Graphics](http://www.mentor.com/) 公司 silicon [IP 核](http://zh.wikipedia.org/wiki/IP%E6%A0%B8)的 USB 控制器. 仅用于嵌入式环境.")]),t._v(" "),e("dt",[t._v("Renesas USBHS controller\nCONFIG_USB_RENESAS_USBHS")]),t._v(" "),e("dd",[t._v("一系列基于 [Renesas](http://cn.renesas.com/) 公司 USBHS [IP 核](http://zh.wikipedia.org/wiki/IP%E6%A0%B8)的 USB 控制器. 仅用于嵌入式环境.")]),t._v(" "),e("dt",[t._v("USB Modem (CDC ACM) support\nCONFIG_USB_ACM")]),t._v(" "),e("dd",[t._v("USB 接口的猫或 ISDN 适配器, 基本没人用的东西.")]),t._v(" "),e("dt",[t._v("USB Printer support\nCONFIG_USB_PRINTER")]),t._v(" "),e("dd",[t._v("USB 接口的打印机, 这是主流的打印机")]),t._v(" "),e("dt",[t._v("USB Wireless Device Management support\nCONFIG_USB_WDM")]),t._v(" "),e("dd",[t._v("为符合 [CDC](http://justmei.blog.163.com/blog/static/1160998532010321112522467/)(Communication Device CIass) 和 [WMC](http://baike.baidu.com/view/397907.htm)(Wireless Mobile Communication) 标准的手机提供 WMC 设备管理支持, 这样你可以在这些手机上使用 [AT 命令](http://zh.wikipedia.org/wiki/%E6%B5%B7%E6%96%AF%E5%91%BD%E4%BB%A4%E9%9B%86) (被所有调制解调器制造商采用的一个调制解调器命令语言).")]),t._v(" "),e("dt",[t._v("USB Test and Measurement Class support\nCONFIG_USB_TMC")]),t._v(" "),e("dd",[t._v('[USBTMC](http://www.eet-china.com/ART_8800424718_675277_TA_b4a8c334.HTM)(USB Test and Measurement Class) 协议支持. 主要适用于测试仪器的 USB 通信开发. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("USB Mass Storage support\nCONFIG_USB_STORAGE")]),t._v(" "),e("dd",[t._v('USB 存储设备 (U 盘, USB 硬盘, USB 软盘, USB 光盘, USB 磁带, [记忆棒](http://baike.baidu.com/view/26952.htm), 数码相机, [读卡器](http://baike.baidu.com/view/6239.htm) [包括某些笔记本内置的 SD 卡读卡器] 等等). 该选项依赖于 CONFIG_SCSI 和 CONFIG_BLK_DEV_SD 选项. 选 "Y", 除非你确实知道自己在干什么.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("USB Mass Storage verbose debug\nCONFIG_USB_STORAGE_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{省略的部分请按照自己实际使用的硬件选择 (事实上大部分人都没有这些设备)}")])])]),t._v(" "),e("dt",[t._v("USB Mustek MDC800 Digital Camera support\nCONFIG_USB_MDC800")]),t._v(" "),e("dd",[t._v("一款上世纪生产的数码相机")]),t._v(" "),e("dt",[t._v("Microtek X6USB scanner support\nCONFIG_USB_MICROTEK")]),t._v(" "),e("dd",[t._v("几款上世纪生产的扫描仪")])])]),t._v(" "),e("dt",[t._v("DesignWare USB3 DRD Core Support\nCONFIG_USB_DWC3")]),t._v(" "),e("dd",[t._v("基于 DesignWare USB3 IP 核的 USB3.0 控制器. 仅用于嵌入式环境.")]),t._v(" "),e("dt",[t._v("ChipIdea Highspeed Dual Role Controller\nCONFIG_USB_CHIPIDEA")]),t._v(" "),e("dd",[t._v("基于 ChipIdea silicon IP 核的 USB2.0 控制器. 仅用于嵌入式环境.")]),t._v(" "),e("dt",[t._v("USS720 parport driver\nCONFIG_USB_USS720")]),t._v(" "),e("dd",[t._v('一种 USB 转并口的转换设备. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("USB Serial Converter support\nCONFIG_USB_SERIAL")]),t._v(" "),e("dd",[t._v('USB - 串口转换支持:(1)USB - 串口转换器,(2) 连接在 USB 口上的串口设备. 详情参见 "[Documentation/usb/usb-serial.txt](https://www.kernel.org/doc/Documentation/usb/usb-serial.txt)"文档. 不确定的选"N".')]),t._v(" "),e("dt",{staticClass:"omit"},[t._v('{此处省略的各种杂七杂八的 USB 设备, 要么是老古董, 要么是很罕见, 不确定的可以全部选 "N"}')]),t._v(" "),e("dt",[t._v("USB testing driver\nCONFIG_USB_TEST")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("USB DSL modem support\nCONFIG_USB_ATM")]),t._v(" "),e("dd",[t._v("USB DSL modem 已经是绝迹的古董猫了")]),t._v(" "),e("dt",[t._v("USB Physical Layer drivers\nCONFIG_USB_PHY")]),t._v(" "),e("dd",[t._v("这类设备仅在嵌入式系统上存在")]),t._v(" "),e("dt",[t._v("USB Gadget Support\nCONFIG_USB_GADGET")]),t._v(" "),e("dd",[t._v('USB 是一个主 / 从协议, 一个主机最多控制 127 个外设, 其结构是非对称的, 所以你无法把一个 "到主机" 的插头连接到外设上. Linux 既可以在 USB 主机上运行, 也可以在 USB 外设上运行. 外设 USB 控制器可以是单独的芯片, 也可以是集成在 CPU 中的微控制器, 而常见的主机端控制器通常集成在芯片组的南桥中 (xHCI/EHCI/OHCI/UHCI). 如果你打算在外设中运行 Linux, 那么就必须开启此项, 然后还需要为外设段的总线控制器配置一个硬件驱动, 以及一个用于外设协议的 "配件驱动". 不过对于大多数人来说, 并不将 Linux 运行于外设端, 因此可以放心的选 "N". 仅那些嵌入式设备(例如智能手机) 上运行的 Linux 才可能由此需求.')])])]),t._v(" "),e("dt",[t._v("Ultra Wideband devices\nCONFIG_UWB")]),t._v(" "),e("dd",[t._v('[UWB](http://baike.baidu.com/view/5958.htm)([Ultra Wideband](http://zh.wikipedia.org/wiki/%E8%B6%85%E5%AF%AC%E9%A0%BB))是一种高带宽, 低能耗, 点对点, 抗干扰性能强的无载波通信技术. UWB 在较宽的频谱 (3.1-10.6GHz) 上, 使用极低的功率 (约为蓝牙的 1/20), 以时间间隔极短(小于 1ns) 的脉冲信号进行通信. UWB 主要应用于室内通信(2 米范围内实现 480Mbps 速率, 10 米范围内实现 110Mbps 速率), 例如[作为 WUSB(Wireless USB) 协议的传输层](http://news.mydrivers.com/1/130/130214.htm). 如果你有 UWB 无线控制器, 可以选 "Y", 不确定的选 "N". 详见 "[Documentation/usb/WUSB-Design-overview.txt](https://www.kernel.org/doc/Documentation/usb/WUSB-Design-overview.txt)" 文档.')]),t._v(" "),e("dt",[t._v("MMC/SD/SDIO card support\nCONFIG_MMC")]),t._v(" "),e("dd",[t._v("[MMC](http://baike.baidu.com/view/8802.htm)([MultiMediaCard](http://zh.wikipedia.org/wiki/%E5%A4%9A%E5%AA%92%E9%AB%94%E8%A8%98%E6%86%B6%E5%8D%A1))/[SD](http://baike.baidu.com/view/2228.htm)([Secure Digital](http://zh.wikipedia.org/wiki/SD%E5%8D%A1))/[SDIO](http://baike.baidu.com/view/1456746.htm)([Secure Digital I/O](http://wenku.baidu.com/view/187c0ad1240c844769eaee19)) 主机控制器。[提示] 虽然许多笔记本上有 SD 卡插槽, 但其实它们大多使用的是 CONFIG_USB_STORAGE 驱动, 而不是这里的驱动.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("MMC debugging\nCONFIG_MMC_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Assume MMC/SD cards are non-removable (DANGEROUS)\nCONFIG_MMC_UNSAFE_RESUME")]),t._v(" "),e("dd",[t._v('假定在系统休眠的过程中, 所有 MMC/SD/SDIO 卡依然插在各自的插槽上没有变动. 也许只有嵌入式系统才可以做这样的假定. 不确定的选 "N". 参见 CONFIG_USB_DEFAULT_PERSIST 选项.')]),t._v(" "),e("dt",[t._v("MMC host clock gating\nCONFIG_MMC_CLKGATE")]),t._v(" "),e("dd",[t._v('尝试激进的 "gate the clock to the MMC card"(啥意思?). 这样当 MMC 卡不使用的时候, 就可以进入节电状态. 主机控制器必须支持此特性. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("MMC block device driver\nCONFIG_MMC_BLOCK")]),t._v(" "),e("dd",[t._v("MMC 块设备驱动. 基本上 MMC 卡都是作为块设备 (就像 U 盘一样) 使用. 所以只要使用 MMC 卡就应该开启.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Number of minors per block device\nCONFIG_MMC_BLOCK_MINORS")]),t._v(" "),e("dd",[t._v('为每个 MMC 块设备保留的次设备号数量. 取值范围是 [4,256]. 这里设置的值应该等于 "最大可能的分区数 + 1". 因为总的次设备号只有 256 个, 所以最大能支持的 MMC 块设备数量就等于 256 除以此处设置的值. 默认值 "8" 可以保证最大的向后兼容性. 不确定的请保持默认值.')]),t._v(" "),e("dt",[t._v("Use bounce buffer for simple hosts\nCONFIG_MMC_BLOCK_BOUNCE")]),t._v(" "),e("dd",[t._v('为 SD/MMC 控制器提供更多的缓存 (最大 64KB), 从而可以大幅提升其性能. 建议选 "Y".')])])]),t._v(" "),e("dt",[t._v("SDIO UART/GPS class support\nCONFIG_SDIO_UART")]),t._v(" "),e("dd",[t._v('实现了 [UART](http://zh.wikipedia.org/wiki/UART) 类的 SDIO 卡支持. 包括那些表现的像 UART 一样的 [GPS](http://baike.baidu.com/view/7773.htm) 类支持. 主要用于嵌入式设备. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("MMC host test driver\nCONFIG_MMC_TEST")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Secure Digital Host Controller Interface support\nCONFIG_MMC_SDHCI")]),t._v(" "),e("dd",[t._v("通用 SD 主控支持. 笔记本电脑上用的 SD 主控 (TI(德州仪器)/Ricoh(理光)/Toshiba(东芝) 等厂商)基本上都是这个驱动. 选中此项后, 还需要选中相应的总线驱动(见下, 通常是 CONFIG_MMC_SDHCI_PCI).")]),t._v(" "),e("dt",[t._v("SDHCI support on PCI bus\nCONFIG_MMC_SDHCI_PCI")]),t._v(" "),e("dd",[t._v("PCI 总线的 SD 主控支持, 目前的笔记本的 SD 主控基本都接在 PCI 总线上.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Ricoh MMC Controller Disabler\nCONFIG_MMC_RICOH_MMC")]),t._v(" "),e("dd",[t._v('用于修正 Ricoh(理光)MMC 主控的 bug, 如果你需要使用 Ricoh 主控, 就选 "Y".')])])]),t._v(" "),e("dt",[t._v("SDHCI support for ACPI enumerated SDHCI controllers\nCONFIG_MMC_SDHCI_ACPI")]),t._v(" "),e("dd",[t._v('专用于 "ACPI Compatibility ID" 等于 "PNP0D40" 的 SD 主控, 以及 "ACPI Hardware ID" 等于 "INT33C6,INT33BB,80860F14" 的 SD 主控.')]),t._v(" "),e("dt",[t._v("SDHCI platform and OF driver helper\nCONFIG_MMC_SDHCI_PLTFM")]),t._v(" "),e("dd",[t._v("基于 [platform](http://wenku.baidu.com/view/7673feacdd3383c4bb4cd211) 总线和 [OpenFirmware](http://www.openfirmware.org/) 的 SD 主控.")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处省略的 SD 主控请按照实际使用的芯片进行选择}")]),t._v(" "),e("dt",[t._v("MMC/SD/SDIO over SPI\nCONFIG_MMC_SPI")]),t._v(" "),e("dd",[t._v("基于 SPI 总线的 MMC/SD/SDIO 主控. 仅用于嵌入式环境.")])])]),t._v(" "),e("dt",[t._v("Sony MemoryStick card support\nCONFIG_MEMSTICK")]),t._v(" "),e("dd",[t._v("Sony [记忆棒](http://zh.wikipedia.org/wiki/Memory_Stick)是一种 Sony 专用的存储设备.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("MemoryStick debugging\nCONFIG_MEMSTICK_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Allow unsafe resume (DANGEROUS)\nCONFIG_MEMSTICK_UNSAFE_RESUME")]),t._v(" "),e("dd",[t._v('假定在系统休眠的过程中, 所有记忆棒依然插在各自的插槽上没有变动. 也许只有嵌入式系统才可以做这样的假定. 不确定的选 "N". 参见 CONFIG_USB_DEFAULT_PERSIST 选项.')]),t._v(" "),e("dt",[t._v("MemoryStick Pro block device driver\nCONFIG_MSPRO_BLOCK")]),t._v(" "),e("dd",[t._v('"Memory Stick PRO" 是 SONY 从 2003 开始引入的升级版标准, 早已成为主流, 所以应该选 "Y"(除非你仍在使用十年前的老 VAIO 笔记本).')]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处省略的 MemoryStick 主控请按照实际使用的芯片进行选择}")])])]),t._v(" "),e("dt",[t._v("LED Support\nCONFIG_NEW_LEDS")]),t._v(" "),e("dd",[t._v("发光二级管 (LED) 支持.[提示]标准键盘上的 LED 灯不在此列(由 input 子系统控制)")]),t._v(" "),e("dt",[t._v("Accessibility support\nCONFIG_ACCESSIBILITY")]),t._v(" "),e("dd",[t._v("无障碍 (Accessibility) 支持. 各种帮助残疾人使用计算机的软硬件技术. 例如: 盲文设备, 语音合成, 键盘映射, 等等.")]),t._v(" "),e("dt",[t._v("InfiniBand support\nCONFIG_INFINIBAND")]),t._v(" "),e("dd",[t._v("[InfiniBand](http://server.it168.com/a2012/0924/1401/000001401869_all.shtml) 是一种低延迟 / 高带宽数据中心互联架构, 采用远程直接内存存取 (RDMA) 实现高性能处理器间通信 (IPC), 同时对虚拟化技术也提供了良好的支持. 主要用于服务器集群与高性能计算(HPC) 领域.")]),t._v(" "),e("dt",[t._v("EDAC (Error Detection And Correction) reporting\nCONFIG_EDAC")]),t._v(" "),e("dd",[t._v('在电磁环境比较恶劣的情况下, 一些大规模集成电路常常会受到干扰, 特别是像 [RAM](http://baike.baidu.com/view/943101.htm) 这种利用双稳态进行存储的器件, 往往会在强干扰下发生翻转, 使原来存储的 "0" 变为 "1", 或者 "1" 变为 "0", 造成严重的后果 (例如控制程序跑飞, 关键数据出错). 随着芯片集成度的增加, 发生错误的可能性也在增大, 这已经成为一个不能忽视的问题. 错误检测与纠正 ([EDAC](http://blog.163.com/somen111@126/blog/static/115586684201356451437/)) 技术的目标就是发现并报告甚至纠正在计算机系统中发生的错误, 这些错误是由 CPU 或芯片组报告的底层错误 (内存错误 / 缓存错误 / PCI 错误 / 温度过高, 等等), 建议选 "Y". 如果这些代码报告了一个错误, 请到 [http://bluesmoke.sourceforge.net/](http://bluesmoke.sourceforge.net/) 和 [http://buttersideup.com/edacwiki](http://buttersideup.com/edacwiki) 查看更多信息. 详见 "[Documentation/edac.txt](https://www.kernel.org/doc/Documentation/edac.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("EDAC legacy sysfs\nCONFIG_EDAC_LEGACY_SYSFS")]),t._v(" "),e("dd",[t._v('仅在你需要使用老版本 [edac-utils](http://sourceforge.net/projects/edac-utils/) 的情况下才需要选 "Y".')]),t._v(" "),e("dt",[t._v("Debugging\nCONFIG_EDAC_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Decode MCEs in human-readable form (only on AMD for now)\nCONFIG_EDAC_DECODE_MCE")]),t._v(" "),e("dd",[t._v("将 [MCE](http://ilinuxkernel.com/?p=303)([](http://h10025.www1.hp.com/ewfrf/wc/document?cc=cn&lc=zh-hans&doc>Machine Check Exception"),t._v(") 解码为人类可读的形式 (目前仅支持 AMD). 建议选 )")]),t._v(" "),e("dd",[e("dl",[t._v(" ["),e("dt",[t._v("Simple MCE injection interface over /sysfs\nCONFIG_EDAC_MCE_INJ")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v("](http://h10025.www1.hp.com/ewfrf/wc/document?cc=cn&lc=zh-hans&doc>Machine Check Exception"),t._v(") 解码为人类可读的形式 (目前仅支持 AMD). 建议选 ) ")])]),t._v(" "),e("p",[t._v("[")]),e("dt",[t._v("Main Memory EDAC (Error Detection And Correction) reporting\nCONFIG_EDAC_MM_EDAC")]),t._v("](http://h10025.www1.hp.com/ewfrf/wc/document?cc=cn&lc=zh-hans&doc>Machine Check Exception"),t._v(") 解码为人类可读的形式 (目前仅支持 AMD). 建议选 )"),e("p"),t._v(" "),e("dd",[t._v("[一些系统能够检测和修正主内存中的错误, EDAC 能够报告这些信息 (EDAC 自己检测到的或者根据](http://h10025.www1.hp.com/ewfrf/wc/document?cc=cn&lc=zh-hans&doc>Machine Check Exception"),t._v(') 解码为人类可读的形式 (目前仅支持 AMD). 建议选 ) [ECC](http://baike.baidu.com/view/93728.htm) 得到的).EDAC 还会尽量检测这些错误发生在哪里以便于替换损坏的内存. 建议选 "Y" 并按照你实际硬件状况选取子项')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Output ACPI APEI/GHES BIOS detected errors via EDAC\nCONFIG_EDAC_GHES")]),t._v(" "),e("dd",[t._v('并不是所有机器都提供基于硬件的 EDAC 技术, 有部分机器提供的是基于 ACPI BIOS 的报告机制 (使用 CONFIG_ACPI_APEI_GHES 驱动). 开启此项后, 如果检测到 GHES BIOS, 那么 CONFIG_ACPI_APEI_GHES 驱动提供的错误报告将会通过 EDAC API 发送到用户空间, 同时, 硬件 EDAC 也会被禁用, 也就是进入 "固件优先" 模式. 注意: GHES BIOS 和硬件 EDAC 两者不能共存, 因为 BIOS 和操作系统在读取 error 寄存器时会相互竞争. 所以如果你不想使用 "固件优先" 模式, 应该选 "N", 或者使用 "ghes.disable=1" 内核引导参数. 否则应该选 "Y".')]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处省略的芯片请按照实际情况选择}")])])])])]),t._v(" "),e("dt",[t._v("Real Time Clock\nCONFIG_RTC_CLASS")]),t._v(" "),e("dd",[t._v('通用 [RTC](http://zh.wikipedia.org/wiki/%E5%AF%A6%E6%99%82%E6%99%82%E9%90%98)(实时时钟) 类支持. 所有的 PC 机主板都包含一个电池动力的[实时时钟芯片](http://www.ibm.com/developerworks/cn/linux/1307_liuming_linuxtime2/index.html), 以便在断电后仍然能够继续保持时间, RTC 通常与 [CMOS](http://zh.wikipedia.org/wiki/%E4%BA%92%E8%A3%9C%E5%BC%8F%E9%87%91%E5%B1%AC%E6%B0%A7%E5%8C%96%E7%89%A9%E5%8D%8A%E5%B0%8E%E9%AB%94) 集成在一起, 因此 BIOS 可以从中读取当前时间 (精度一般是秒级). 选中此项后你就可以在操作系统中使用一个或多个 RTC 设备 (你还必须从下面启用一个或多个 RTC 接口).[注意]Clock 与 Timer 没有任何关系, Timer 是定时器 (用于计量时长),Clock 是时钟 (用于记录当前的时刻 "年 - 月 - 日 时: 分: 秒")')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Set system time from RTC on startup and resume\nCONFIG_RTC_HCTOSYS")]),t._v(" "),e("dd",[t._v('系统启动时从指定的 RTC 设备 (CONFIG_RTC_HCTOSYS_DEVICE) 中读取时间, 以设定系统时间, 这将有助于避免时间不准导致的麻烦 (例如不必要的文件系统检测(fsck) 以及网络故障). 建议选 "Y".')]),t._v(" "),e("dt",[t._v("Set the RTC time based on NTP synchronization\nCONFIG_RTC_SYSTOHC")]),t._v(" "),e("dd",[t._v('如果用户空间报告了 "[NTP](http://baike.baidu.com/view/60648.htm) 已同步 ", 那么每隔大约 11 分钟, 内核将会自动把系统时间写入指定的 RTC 设备 (CONFIG_RTC_HCTOSYS_DEVICE) 中. 建议选"Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("RTC used to set the system time\nCONFIG_RTC_HCTOSYS_DEVICE")]),t._v(" "),e("dd",[t._v('默认的 RTC 设备 (通常是 "rtc0"). 该设备的驱动必须静态编译进内核 (而不能作为模块加载).')])])]),t._v(" "),e("dt",[t._v("RTC debug support\nCONFIG_RTC_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("/sys/class/rtc/rtcN (sysfs)\nCONFIG_RTC_INTF_SYSFS")]),t._v(" "),e("dd",[t._v("允许通过 sysfs 接口使用 RTC, 允许多个 RTC 设备, 也就是 / sys/class/rtc/rtc0~N")]),t._v(" "),e("dt",[t._v("/proc/driver/rtc (procfs for rtcN)\nCONFIG_RTC_INTF_PROC")]),t._v(" "),e("dd",[t._v('允许通过 proc 接口使用 RTC, 仅允许一个 RTC 设备, 也就是 / proc/driver/rtc(若有多个 RTC 设备, 则其将对应 "rtc0")')]),t._v(" "),e("dt",[t._v("/dev/rtcN (character devices)\nCONFIG_RTC_INTF_DEV")]),t._v(" "),e("dd",[t._v("允许通过 dev 接口使用 RTC, 允许多个 RTC 设备, 也就是 / dev/rtc0~N, 某些程序 (比如 [hwclock](http://baike.baidu.com/view/4808064.htm)) 需要使用 / dev/rtc(这是个软连接, udev 会自动将其指向默认的 RTC 设备)")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("RTC UIE emulation on dev interface\nCONFIG_RTC_INTF_DEV_UIE_EMUL")]),t._v(" "),e("dd",[t._v('如果底层 rtc 芯片驱动没有提供 RTC_UIE 就仿真一个 RTC_UIE. 选 "N", 除非你确实知道自己在做什么.')])])]),t._v(" "),e("dt",[t._v("Test driver/device\nCONFIG_RTC_DRV_TEST")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处省略的其他 RTC 设备一般仅用于非 PC 环境}")]),t._v(" "),e("dt",[t._v("PC-style 'CMOS'\nCONFIG_RTC_DRV_CMOS")]),t._v(" "),e("dd",[t._v('这是所有 PC 和基于 ACPI 的系统通用的 RTC 驱动. 必须选 "Y"(不能选 "M"), 除非你是嵌入式系统.')])])]),t._v(" "),e("dt",[t._v("DMA Engine support\nCONFIG_DMADEVICES")]),t._v(" "),e("dd",[t._v('DMA 引擎 ([DMA](http://en.wikipedia.org/wiki/Direct_memory_access) Engine)可以看做是传统 DMA 控制器 (DMA controller) 的新生. 在 DMA 引擎的协助下, CPU 只需初始化一个传输动作, 其余的动作就可以由 DMA 引擎独立完成 (完成后以中断的方式通知 CPU), 这对于高速传输大量数据以及 "分散 - 收集" 操作大有益处, 可以节约大量的 CPU 资源(有时也可节约大量的内存操作). 目前, DMA 引擎有两个用途:(1) 卸载高速网络栈中的内存 COPY 操作,(2)加速 CONFIG_MD_RAID456 驱动中的 RAID 操作."DMA 引擎" 只是一个统称, 在不同场合对应着不同的技术, 例如 [Intel I/OAT](http://www.intel.cn/content/www/cn/zh/wireless-network/accel-technology.html)(PC 平台) 和 [AHB](http://baike.baidu.com/view/1362076.htm)(嵌入式).[提示] 历史上, ISA 架构的电脑都有一个专用的 "DMA 控制器"(最常见的是 [Intel 8237](http://en.wikipedia.org/wiki/Intel_8237)), 但是到了 PCI 架构, 由于每一个 PCI 设备都可以控制 PCI 总线 (成为 "[bus master](http://en.wikipedia.org/wiki/Bus_mastering)") 并直接读写系统内存, 所以虽然 DMA 的操作方式依然存在, 但是"DMA 控制器 "却消失了. 现在新生的"DMA 引擎 " 目前仍然主要出现在 [Intel 的高端芯片](http://cateee.net/lkddb/web-lkddb/DMADEVICES.html)上.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("DMA Engine debugging\nCONFIG_DMADEVICES_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Intel MID DMA support for Peripheral DMA controllers\nCONFIG_INTEL_MID_DMAC")]),t._v(" "),e("dd",[t._v("Intel [MID](http://zh.wikipedia.org/wiki/%E8%A1%8C%E5%8B%95%E8%81%AF%E7%B6%B2%E8%A3%9D%E7%BD%AE) DMA 引擎, 搭配 Atom 处理器使用.")]),t._v(" "),e("dt",[t._v("Intel integrated DMA 64-bit support\nCONFIG_INTEL_IDMA64")]),t._v(" "),e("dd",[t._v("为 Intel 低功耗子系统 (Intel Low Power Subsystem) 中整合的 64 位 DMA 提供支持. Intel [Skylake](http://www.expreview.com/42154-all.html) [PCH](http://www.expreview.com/42166.html) 就是一个支持 Intel 低功耗子系统的例子.")]),t._v(" "),e("dt",[t._v("Intel I/OAT DMA support\nCONFIG_INTEL_IOATDMA")]),t._v(" "),e("dd",[t._v("带有[英特尔 I/O 加速技术](http://www.intel.cn/content/www/cn/zh/wireless-network/accel-technology.html) ([I/O Acceleration Technology](http://cateee.net/lkddb/web-lkddb/INTEL_IOATDMA.html)) 的至强芯片组 DMA 引擎")]),t._v(" "),e("dt",[t._v("Synopsys DesignWare AHB DMA support\nCONFIG_DW_DMAC")]),t._v(" "),e("dd",[t._v("基于 [Synopsys DesignWare](http://www.synopsys.com.cn/products-and-solutions/ip) IP 核的 [AHB](http://baike.baidu.com/view/1362076.htm) 总线 DMA 引擎. 例如 [Atmel](http://www.atmel.com/zh/cn/) [AT32ap7000](http://www.eet-china.com/ART_8800458944_617693_NP_375c2322.HTM) 中就整合了这个引擎.")]),t._v(" "),e("dt",[t._v("Timberdale FPGA DMA support\nCONFIG_TIMB_DMA")]),t._v(" "),e("dd",[t._v('Timberdale FPGA DMA 引擎."Timberdale FPGA" 是一个多功能设备, 出现在基于 Intel Atom 的车载信息娱乐系统 [IVI(In-Vehicle Infotainment)](http://wiki.meego.com/In-vehicle) 上.')]),t._v(" "),e("dt",[t._v("Intel EG20T PCH / LAPIS Semicon IOH(ML7213/ML7223/ML7831) DMA\nCONFIG_PCH_DMA")]),t._v(" "),e("dd",[t._v("所有与 [Intel EG20T PCH](http://www.youcpu.com/chipset/Intel-Platform-Controller-Hub-EG20T-Intel-EG20T-PCH) 兼容的芯片的 DMA 引擎支持, 具体型号可以查看内核帮助. 都是嵌入式芯片.")]),t._v(" "),e("dt",[t._v("Network: TCP receive copy offload\nCONFIG_NET_DMA")]),t._v(" "),e("dd",[t._v("通过在网络栈中利用 DMA 引擎来减少接收数据包时的 copy-to-user 操作以释放 CPU 资源, 仅在 CONFIG_INTEL_IOATDMA 开启的前提下才有意义.")]),t._v(" "),e("dt",[t._v("Async_tx: Offload support for the async_tx api\nCONFIG_ASYNC_TX_DMA")]),t._v(" "),e("dd",[t._v("如果你开启了 CONFIG_MD_RAID456, 同时你的硬件又支持 DMA 引擎, 那么开启此项后可以加速 RAID 操作.")]),t._v(" "),e("dt",[t._v("DMA Test client\nCONFIG_DMATEST")]),t._v(" "),e("dd",[t._v("仅供调试使用")])])]),t._v(" "),e("dt",[t._v("Auxiliary Display support\nCONFIG_AUXDISPLAY")]),t._v(" "),e("dd",[t._v("辅助显示设备. 例如基于 [KS0108](http://blog.sina.com.cn/s/blog_4a3946360100obaf.html) 控制器的 [Crystalfontz CFAG12864B](http://www.crystalfontz.com/product/CFAG12864BTFHV) 单色液晶屏 (分辨率: 128x64). 仅用于嵌入式系统.")]),t._v(" "),e("dt",[t._v("Userspace I/O drivers\nCONFIG_UIO")]),t._v(" "),e("dd",[t._v('[UIO](http://baike.baidu.com/view/8975902.htm)(Userspace I/O) 是运行在用户空间的 I/O 技术, 它为开发用户空间的驱动提供了一个简单的架构 (/dev/uioN). 使用 uio 的设备一般都属于嵌入式系统. 不确定的选 "N".[提示][lsuio](http://www.osadl.org/projects/downloads/UIO/user/) 工具可以列出所有 UIO 的模块和其映射的内存地址.')]),t._v(" "),e("dt",[t._v("VFIO Non-Privileged userspace driver framework\nCONFIG_VFIO")]),t._v(" "),e("dd",[t._v('[VFIO](https://www.ibm.com/developerworks/community/blogs/5144904d-5d75-45ed-9d2b-cf1754ee936a/entry/vfio) 是一套无特权用户空间 I/O 驱动框架, 需要有 [IOMMU 虚拟化硬件](http://en.wikipedia.org/wiki/List_of_IOMMU-supporting_hardware)支持 (AMD-Vi/[Intel VT-d](http://software.intel.com/zh-cn/articles/io-vt-d-io)). 此选项仅用于宿主机内核. VFIO 的目标是在 IOMMU 硬件的帮助下, 取代 CONFIG_UIO 和 CONFIG_KVM_DEVICE_ASSIGNMENT.VFIO 主要用于编写高效的用户态驱动, 以及在虚拟化环境的属主机中高效的实现[设备直通 (passthrough)](http://blog.csdn.net/halcyonbaby/article/details/37776211) 且无须 root 特权, 可用于详见 "[Documentation/vfio.txt](https://www.kernel.org/doc/Documentation/vfio.txt)" 文档.[提示][QEMU 1.3](http://wiki.qemu.org/ChangeLog/1.3) 以上版本才能利用 VFIO 特性. 不玩 KVM 虚拟化的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("VFIO support for PCI devices\nCONFIG_VFIO_PCI")]),t._v(" "),e("dd",[t._v('允许 PCI 设备使用 VFIO 框架. 这是 VFIO 框架当前的主要用途. 选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("VFIO PCI support for VGA devices\nCONFIG_VFIO_PCI_VGA")]),t._v(" "),e("dd",[t._v('让 VFIO PCI 支持 VGA 扩展, 此选项依赖于 CONFIG_VGA_ARB, 建议选 "Y".')])])])])]),t._v(" "),e("dt",[t._v("Virtualization drivers\nCONFIG_VIRT_DRIVERS")]),t._v(" "),e("dd",[t._v("这个选项仅对 [PowerPC](http://baike.baidu.com/view/405903.htm) 架构有意义")]),t._v(" "),e("dt",[t._v("Virtio drivers")]),t._v(" "),e("dd",[t._v("仅可用于客户机内核的 [Virtio](http://smilejay.com/2012/11/virtio-overview/) 驱动.[Virtio](http://www.linux-kvm.org/page/Virtio) 的目标是为各种半虚拟化的[虚拟机管理程序](http://www.ibm.com/developerworks/cn/linux/l-hypervisor/) (特别是 [KVM](http://smilejay.com/kvm_theory_practice/)) 提供一组通用的模拟设备, 目前已实现: network/block/balloon/console/hw_random, 未来还会实现更多. 下列驱动仅可用在基于 [lguest](http://lguest.ozlabs.org/) 或 [QEMU](http://wiki.qemu.org/Main_Page) 的半虚拟化客户机中 (一般是 [KVM](http://wiki.ubuntu.org.cn/Kvm%E6%95%99%E7%A8%8B) 或 [XEN](http://zh.wikipedia.org/zh-cn/Xen)).")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("PCI driver for virtio devices\nCONFIG_VIRTIO_PCI")]),t._v(" "),e("dd",[t._v('半虚拟化 PCI 设备驱动. VMM(虚拟机管理程序) 必须要有相应的 "PCI virtio backend". 基于 QEMU 的 VMM(KVM,Xen) 一般都支持该驱动.[提示] 由于目前的 ABI 尚不稳定, 建议使用时注意版本匹配.')]),t._v(" "),e("dt",[t._v("Virtio balloon driver\nCONFIG_VIRTIO_BALLOON")]),t._v(" "),e("dd",[t._v("[balloon](http://smilejay.com/2012/11/kvm-ballooning-overview/) 驱动支持按需扩展或减少 KVM 客户机内的内存大小.")]),t._v(" "),e("dt",[t._v("Platform bus driver for memory mapped virtio devices\nCONFIG_VIRTIO_MMIO")]),t._v(" "),e("dd",[t._v("支持使用内存映射机制的 virtio 设备驱动")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Memory mapped virtio devices parameter parsing\nCONFIG_VIRTIO_MMIO_CMDLINE_DEVICES")]),t._v(" "),e("dd",[t._v('允许通过 "virtio_mmio.device" 内核模块参数实例化 virtio-mmio 设备. 注意, 错误的参数 (特别是 "baseaddr" 错误) 会导致系统崩溃. 详见 "[Documentation/kernel-parameters.txt](https://www.kernel.org/doc/Documentation/kernel-parameters.txt)"文档中对"virtio_mmio.device" 的说明.')])])])])]),t._v(" "),e("dt",[t._v("Microsoft Hyper-V guest support")]),t._v(" "),e("dd",[t._v("仅在将此 Linux 内核作为[微软 Hyper-V 虚拟机](http://technet.microsoft.com/zh-cn/library/hh831531.aspx)的来宾操作系统运行时, 才需要开启这里的选项.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Microsoft Hyper-V client drivers\nCONFIG_HYPERV")]),t._v(" "),e("dd",[t._v("将 Linux 内核作为 Hyper-V 的来宾操作系统运行")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Microsoft Hyper-V Utilities driver\nCONFIG_HYPERV_UTILS")]),t._v(" "),e("dd",[t._v("[Hyper-V 管理工具](http://technet.microsoft.com/zh-cn/library/cc794756.aspx)驱动.")]),t._v(" "),e("dt",[t._v("Microsoft Hyper-V Balloon driver\nCONFIG_HYPERV_BALLOON")]),t._v(" "),e("dd",[t._v("Hyper-V [Balloon](http://technet.microsoft.com/zh-cn/library/hh831766.aspx) 驱动")])])])])]),t._v(" "),e("dt",[t._v("Xen driver support")]),t._v(" "),e("dd",[t._v("仅在将此 Linux 内核作为半虚拟化模式的 [XEN 虚拟机](http://cn.opensuse.org/Xen%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%80%E4%BB%8B)的来宾操作系统运行时, 才需要开启这里的选项. 由于 KVM 的高歌猛进, 特别是 Ubuntu 和 Redhat 的力挺, 与昔日的辉煌相比,[XEN 现在已经没落许多了](http://virtual.51cto.com/art/201212/375071.htm).")]),t._v(" "),e("dt",[t._v("Staging drivers\nCONFIG_STAGING")]),t._v(" "),e("dd",[t._v("尚在开发中或尚未完成的, 目前尚不完善的驱动, 切勿用于生产环境. 仅供测试人员或者开发者试用.")]),t._v(" "),e("dt",[t._v("X86 Platform Specific Device Drivers\nCONFIG_X86_PLATFORM_DEVICES")]),t._v(" "),e("dd",[t._v("特定于 X86 平台的设备驱动. 例如很多笔记本厂商的专有硬件和特色功能. 大多数笔记本用户都应该进去看看 (简单易懂, 一看即知).")]),t._v(" "),e("dd",[e("dl",[e("dt",{staticClass:"omit"},[t._v("{此处省略所有特定于笔记本厂商的驱动}")]),t._v(" "),e("dt",[t._v("Thermal Management driver for Intel menlow platform\nCONFIG_INTEL_MENLOW")]),t._v(" "),e("dd",[t._v("此驱动专用于 [Intel Menlow](http://www.inpai.com.cn/doc/hard/105589.htm) 平台 (搭配 Atom 处理器), 提供了增强的 ACPI 热量管理能力.")]),t._v(" "),e("dt",[t._v("WMI\nCONFIG_ACPI_WMI")]),t._v(" "),e("dd",[t._v('ACPI-WMI([Windows 管理规范](http://technet.microsoft.com/zh-cn/library/ee692772.aspx))映射设备 (find /sys/devices/ -name "PNP0C14*") 支持.[WMI](http://en.wikipedia.org/wiki/Windows_Management_Instrumentation) 是微软对 ACPI 规范的专有扩展, 可将部分 ACPI 固件内容通过 PNP0C14 设备映射到用户空间, 以方便用户空间调用 ACPI 固件的功能. 本选项仅为那些依赖于 WMI 的驱动提供支持 (并不真正导出到用户空间), 例如 CONFIG_DRM_NOUVEAU 驱动以及专用于 Acer/Asus/Dell/MSI/HP 等品牌笔记本的 WMI 驱动.')]),t._v(" "),e("dt",[t._v("Intel Intelligent Power Sharing\nCONFIG_INTEL_IPS")]),t._v(" "),e("dd",[t._v("Intel [Calpella](http://baike.baidu.com/view/1502112.htm) 平台支持 Intel 的智能电源共享 (Intelligent Power Sharing) 技术, 可以在保持功耗不变的前提下, 在 CPU 和 GPU 之间智能分配电力. 开启此项和 CONFIG_CPU_FREQ 以及 CONFIG_DRM_I915 之后, 即可实现此功能.")]),t._v(" "),e("dt",[t._v("WMI support for MXM Laptop Graphics\nCONFIG_MXM_WMI")]),t._v(" "),e("dd",[t._v("[MXM 接口](http://baike.baidu.com/view/776209.htm)笔记本显卡的 WMI 支持. 目前主要用于 nvidia 显卡.")]),t._v(" "),e("dt",[t._v("Intel Oaktrail Platform Extras\nCONFIG_INTEL_OAKTRAIL")]),t._v(" "),e("dd",[t._v("Intel [Oak Trail](http://baike.baidu.com/view/4045526.htm) 嵌入式平台需要此驱动来开关 WiFi / 相机 / 蓝牙等设备.")]),t._v(" "),e("dt",[t._v("Intel Rapid Start Technology Driver\nCONFIG_INTEL_RST")]),t._v(" "),e("dd",[t._v("[英特尔快速启动技术](http://www.360doc.com/content/13/1117/08/14641369_329810630.shtml) ([Intel Rapid Start Technology](http://tieba.baidu.com/p/2335330015)) 通过在 SSD 上建立与本机内存容量一致的休眠分区, 在休眠时将内存数据保存到 SSD 休眠分区上, 从而实现快速唤醒.")]),t._v(" "),e("dt",[t._v("Intel Smart Connect disabling driver\nCONFIG_INTEL_SMARTCONNECT")]),t._v(" "),e("dd",[t._v('禁用[英特尔智能连接技术](http://baike.baidu.com/view/10453085.htm) ([Intel Smart Connect Technology](http://www.dell.com/support/article/tw/en/twdhs1/SLN262060/zh))的驱动. 此技术旨在通过定期将处于睡眠 / 待机状态的 PC 唤醒一小段时间, 联网一段时间让应用程序 (如电子邮件) 更新, 但是不打开屏幕, 然后又自动回到睡眠状态, 以此循环重复. 这意味着, 当您唤醒 PC 时, 程序数据已经处于最新状态. 主要针对超级本用户且需要 BIOS 支持, 必须在 BIOS 中将 Intel Smart Connect Technology 设为 "Enabled". 如果你的超级本支持此技术且同时安装了 Windows 系统, 那么务必选 "Y".')]),t._v(" "),e("dt",[t._v("pvpanic device support\nCONFIG_PVPANIC")]),t._v(" "),e("dd",[t._v("pvpanic 是 [QEMU](http://www.ibm.com/developerworks/cn/linux/l-cn-qemu-monitor/) 提供的一种准虚拟化 (paravirtualized) 设备, 允许客户机向宿主机报告 panic 事件. 此驱动仅可用于客户机内核.")]),t._v(" "),e("dt",[t._v("Intel PMC IPC Driver\nCONFIG_INTEL_PMC_IPC")]),t._v(" "),e("dd",[t._v('为某些 Intel 平台的 PMC 控制器提供支持. 这里的 "PMC" 是一个 RISC 架构的 32 位 [ARC 处理器](http://book.2cto.com/201511/57901.html) (Argonaut RISC Core processor). 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("Platform support for Chrome hardware\nCONFIG_CHROME_PLATFORMS")]),t._v(" "),e("dd",[t._v("专用于 Google 公司的 [Chromebook](http://www.zhihu.com/question/19657427) 笔记本 /[Chromebox](http://tech2ipo.com/64234) 迷你机的设备驱动.")]),t._v(" "),e("dt",[t._v("Common Clock Framework")]),t._v(" "),e("dd",[t._v('CCF([Common Clock Framework](http://lwn.net/Articles/472998/)) 是从 3.4 内核开始引入的新时钟框架, 用于取代原有的 "Clock Framework". 详见 "[Documentation/clk.txt](https://www.kernel.org/doc/Documentation/clk.txt)" 文档. 这里还有一个[讲解 CCF 的 PDF](http://events.linuxfoundation.org/images/stories/slides/elc2013_clement.pdf).')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("DebugFS representation of clock tree\nCONFIG_COMMON_CLK_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处省略的时钟设备请按实际情况选择 (主要用于嵌入式设备)}")])])]),t._v(" "),e("dt",[t._v("Hardware Spinlock drivers")]),t._v(" "),e("dd",[t._v('硬件[自旋锁](http://blog.chinaunix.net/uid-20543672-id-3252604.html)驱动. 目前仅出现在嵌入式处理器上. 自旋锁是保护共享资源的一种锁机制, 与互斥锁比较类似, 都是为了解决对某项资源的互斥使用. 无论是互斥锁, 还是自旋锁, 在任何时刻, 最多只能有一个持有者. 也就是说, 在任何时刻最多只能有一个执行单元获得锁. 但是两者在调度机制上略有不同, 对于互斥锁, 如果资源已经被占用, 资源申请者只能进入睡眠状态. 但是自旋锁不会引起申请者睡眠, 如果自旋锁已经被别的执行单元保持, 调用者就一直在循环中 "忙等"(占用 CPU 但无事可做), 直到该自旋锁被释放."自旋" 一词就是因此而得名. 自旋锁的使用非常方便, 但仅适用于需要极短时间锁定的场合 (例如 1 毫秒), 以避免消耗太多的 CPU 空等时间.')]),t._v(" "),e("dt",[t._v("Clock Source drivers")]),t._v(" "),e("dd",[t._v('"时钟源" 驱动. 主要面向嵌入式设备.')]),t._v(" "),e("dt",[t._v("Mailbox Hardware Support\nCONFIG_MAILBOX")]),t._v(" "),e("dd",[t._v('Mailbox 硬件支持. 这里的 "Mailbox" 是一个框架, 通过消息队列和中断驱动信号, 控制芯片上的多个处理器之间的通信. 仅用于嵌入式环境.')]),t._v(" "),e("dt",[t._v("IOMMU Hardware Support\nCONFIG_IOMMU_SUPPORT")]),t._v(" "),e("dd",[t._v('[IOMMU](http://en.wikipedia.org/wiki/IOMMU) 硬件主要出现在[带有 I/O 虚拟化技术的硬件](http://en.wikipedia.org/wiki/List_of_IOMMU-supporting_hardware)上, 例如带有 [AMD-Vi](http://www.amd.com/cn/products/server/processors/Pages/amd-platform-specifications.aspx) 或 [VT-d](http://software.intel.com/zh-cn/articles/io-vt-d-io) 技术的芯片. IOMMU 主要作用:(1)内存地址转换 (例如 DMA 地址转换, scatter-gather),(2) 中断重映射,(3)对设备读取和写入的进行权限检查. 这对于提高虚拟化性能和安全性, 以及在 64 位系统上更好的使用 32 位设备, 意义重大.[提示]此选项仅对宿主机有意义, 如果此内核要作为来宾操作系统运行, 请选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("AMD IOMMU support\nCONFIG_AMD_IOMMU")]),t._v(" "),e("dd",[t._v("AMD IOMMU 硬件支持. 一般还需要在 BIOS 中开启相应选项.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Export AMD IOMMU statistics to debugfs\nCONFIG_AMD_IOMMU_STATS")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("AMD IOMMU Version 2 driver\nCONFIG_AMD_IOMMU_V2")]),t._v(" "),e("dd",[t._v("新一代的 AMD IOMMUv2 硬件 (支持 PCI PRI 和 PASID 接口) 支持. 首次出现在 AMD Opteron 4000/6000 系列平台上.")])])]),t._v(" "),e("dt",[t._v("Support for Intel IOMMU using DMA Remapping Devices\nCONFIG_INTEL_IOMMU")]),t._v(" "),e("dd",[t._v('让 Intel IOMMU 支持 DMA 重映射, 这是 IOMMU 的主要用途, 只要你的芯片支持 VT-d, 就选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Support for Shared Virtual Memory with Intel IOMMU\nCONFIG_INTEL_IOMMU_SVM")]),t._v(" "),e("dd",[t._v("[共享虚拟内存](http://server.zdnet.com.cn/files/all-1543447.htm) ([SVM](http://blog.csdn.net/zhangoi391/article/details/41674029), Shared Virtual Memory)允许不同设备 (例如 CPU 与 GPU) 以 PASID(Process Address Space ID)为各自的身份标识, 统一使用 CPU 地址空间访问系统内存的 DMA 资源, 也就是[内存统一寻址](http://diy.pconline.com.cn/485/4850158.html), 以提升异构计算性能. [传说 Skylake 会支持 SVM](http://news.mydrivers.com/1/307/307829.htm).")]),t._v(" "),e("dt",[t._v("Enable Intel DMA Remapping Devices by default\nCONFIG_INTEL_IOMMU_DEFAULT_ON")]),t._v(" "),e("dd",[t._v('默认开启 DMA 重映射支持, 相当于设置 "intel_iommu=on" 内核引导参数. 选 "Y".')])])]),t._v(" "),e("dt",[t._v("Support for Interrupt Remapping\nCONFIG_IRQ_REMAP")]),t._v(" "),e("dd",[t._v('支持对 IO-APIC 和 MSI 设备开启中断重映射, 这也是 IOMMU 的主要用途, 只要你的芯片支持 VT-d, 就选 "Y".')])])]),t._v(" "),e("dt",[t._v("Remoteproc drivers")]),t._v(" "),e("dd",[t._v('现代的 SoC 芯片一般都会以 [AMP](http://baike.baidu.com/view/6350155.htm)([非对称多处理器](http://www.go-gddq.com/html/QiTa-ZongHe_tx/2012-04/946163.htm)) 方式集成多个不同的处理器 (例如 [OMAP5432](http://www.ti.com.cn/general/cn/docs/wtbu/wtbuproductcontent.tsp?templateId=6123&navigationId=12864&contentId=103103) 就在单个芯片上集成了 2 个 Cortex-A15 处理器, 2 个 Cortex-M4 处理器, 1 个 C64x DSP), 这样就可在不同的处理器上分别运行多个不同的操作系统实例 (例如, 在 2 个 Cortex-A9 处理器上以 SMP(对称多处理器) 方式运行 Linux, 在 2 个 Cortex-M3 和 1 个 C64x 上分别运行不同的实时操作系统). 而 Remoteproc 驱动对此种场合下的处理器间通信非常有用. 详见 "[Documentation/remoteproc.txt](https://www.kernel.org/doc/Documentation/remoteproc.txt)"和"[Documentation/rpmsg.txt](https://www.kernel.org/doc/Documentation/rpmsg.txt)"文档. 目前仅对嵌入式系统有意义. 不确定的选"N".')]),t._v(" "),e("dt",[t._v("Rpmsg drivers")]),t._v(" "),e("dd",[t._v("此项和上面的 Remoteproc 紧密相关, 目前其下尚无子项可选.")]),t._v(" "),e("dt",[t._v("SOC (System On Chip) specific Drivers")]),t._v(" "),e("dd",[t._v("专用于单片机的设备驱动. 皆为嵌入式系统.")]),t._v(" "),e("dt",[t._v("Generic Dynamic Voltage and Frequency Scaling (DVFS) support\nCONFIG_PM_DEVFREQ")]),t._v(" "),e("dd",[t._v('DVFS([动态电压与频率调整](http://www.360doc.com/content/09/0710/14/74585_4212349.shtml))可以根据系统负载动态调节设备的运行频率和电压 (对于同一芯片, 频率越高, 需要的电压也越高), 从而达到节能目的. 此选项提供了一个类似 CPUfreq(CONFIG_CPU_FREQ) 的通用 DVFS 框架 (devfreq). 目前 DVFS 技术进在嵌入式设备(例如 Exynos4/Exynos5) 上普遍存在. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("External Connector Class (extcon) support\nCONFIG_EXTCON")]),t._v(" "),e("dd",[t._v('extcon(外部连接器类) 允许用户空间通过 sysfs 和 uevent 监控外部连接器, 同时也支持多状态外部连接器 (也就是拥有多个连接线缆的外部连接器). 例如, 一端连接到主机 USB 端口的多状态外部连接器, 另一端可以同时连接一条 [HDMI](http://baike.baidu.com/view/50611.htm) 线缆和一个 [AC 适配器](http://baike.baidu.com/view/3591885.htm).30 针的 [PDMI](http://zh.wikipedia.org/wiki/PDMI) 连接器也是多状态外部连接器的常见例子. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Memory Controller drivers\nCONFIG_MEMORY")]),t._v(" "),e("dd",[t._v('内存控制器驱动. 这里所说的 "内存控制器" 仅指嵌入式 SoC 系统中的各种控制器. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Industrial I/O support\nCONFIG_IIO")]),t._v(" "),e("dd",[t._v('[IIO 子系统](http://blog.chinaunix.net/uid-20543672-id-2976189.html)为各种不同总线 (i2c,spi, 等) 的嵌入式传感器驱动提供了一个统一的框架. 例如:(1)模数转换器,(2)加速度传感器,(3)陀螺仪,(4)惯性测量仪,(5)电容 - 数字转换器,(6)压力 / 温度 / 光线传感器, 等等. 主要用于工业领域和嵌入式领域. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Non-Transparent Bridge support\nCONFIG_NTB")]),t._v(" "),e("dd",[t._v('[PCI-E 非透明桥](http://www.chinabaike.com/2011/0324/599696.html)是一个点对点 PCI-E 总线, 用于连接两条对等的 PCI-E 总线. 例如英特尔 Atom S1200 处理器, Xeon C5500/C3500 嵌入式处理器等. 具体支持的设备号 (PCI_DEVICE_ID) 可以查看 "drivers/ntb/ntb_hw.h" 文件或 [NTB](https://cateee.net/lkddb/web-lkddb/NTB.html) 驱动数据库. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("VME bridge support\nCONFIG_VME_BUS")]),t._v(" "),e("dd",[t._v('[VME](http://baike.baidu.com/view/1548999.htm)(VersaModule Eurocard) 总线是一种通用的计算机总线, 主要用于工业控制 / 军用系统 / 航空航天 / 交通运输 / 医疗等嵌入式领域. 而 [VME 桥](http://zh.idt.com/products/interface-connectivity/vme/pci-vme-bridge)则是其他总线 (例如 PCI/PCI-E) 到 VME 总线之间的转换芯片. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Pulse-Width Modulation (PWM) Support\nCONFIG_PWM")]),t._v(" "),e("dd",[t._v('[PWM](http://zh.wikipedia.org/wiki/%E8%84%88%E8%A1%9D%E5%AF%AC%E5%BA%A6%E8%AA%BF%E8%AE%8A)([脉宽调制](http://baike.baidu.com/view/631384.htm)) 是将模拟信号转换为脉波的一种技术. 在计算机领域, 这项技术常被用于控制风扇转速和背光显示器的亮度. 很多微型处理器内部都包含有 PWM 控制器, 此选项为所有 PWM 控制器驱动提供了一个统一的框架. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Intel LPSS PWM support\nCONFIG_PWM_LPSS")]),t._v(" "),e("dd",[t._v('适用于 "Intel Low Power Subsystem" PWM 控制器的通用框架驱动. 适用于 Atom Z36xxx/Z37xxx 系列处理器.')]),t._v(" "),e("dt",[t._v("NXP PCA9685 PWM driver\nCONFIG_PWM_PCA9685")]),t._v(" "),e("dd",[t._v("适用于 NXP PCA9685 LED 亮度控制器.")])])]),t._v(" "),e("dt",[t._v("IndustryPack bus support\nCONFIG_IPACK_BUS")]),t._v(" "),e("dd",[t._v('[IndustryPack](http://www.acromag.com/catalog/818) 是工业控制领域常用的一种总线. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Reset Controller Support\nCONFIG_RESET_CONTROLLER")]),t._v(" "),e("dd",[t._v('为 GPIO 总线或者芯片内置的重启控制器提供通用支持. 仅用于嵌入式设备. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("FMC support\nCONFIG_FMC")]),t._v(" "),e("dd",[t._v("[FMC(FPGA Mezzanine Carrier)](http://www.eetrend.com/interview/100024251) 是一个定义如何将 FPGA 夹层卡 ([FPGA Mezzanine Card](http://www.iianews.com/ca/_01-ABC00000000000241496.shtml)) 连接到主机电路板的接口标准, 仅用于嵌入式环境.")]),t._v(" "),e("dt",[t._v("PHY Subsystem")]),t._v(" "),e("dd",[t._v("[PHY](http://www.cnblogs.com/jason-lu/articles/3195473.html) 子系统.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("PHY Core\nCONFIG_GENERIC_PHY")]),t._v(" "),e("dd",[t._v('为内核中的所有 PHY 设备提供一个通用的 [PHY](http://blog.chinaunix.net/uid-20528014-id-3050217.html) 框架. 不确定的选 "N". 内核中若有其他部分依赖它, 会自动选上.')]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处省略的部分请按照硬件的实际情况选择}")])])]),t._v(" "),e("dt",[t._v("Generic powercap sysfs driver\nCONFIG_POWERCAP")]),t._v(" "),e("dd",[t._v('"[power capping](http://server.it168.com/server/2008-07-09/200807090907703_all.shtml)"的意思是允许用户把设备的总功耗限定在指定的范围内. 此选项允许内核子系统将"power capping"的设置以 sysfs 的方式导出到用户空间. 不确定的选"N".')]),t._v(" "),e("dt",[t._v("MCB support\nCONFIG_MCB")]),t._v(" "),e("dd",[t._v('MCB(MEN Chameleon Bus) 是专用于德国 [MEN Mikro Elektronik](https://www.men.de/) 公司的 FPGA 设备的总线. MEN Mikro Elektronik 公司的嵌入式计算主要是为航空 / 航海 / 铁路及陆地车辆的应用, 以及自动化 / 电力 / 能源和医疗用途. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Performance monitor support")]),t._v(" "),e("dd",[t._v("专用于 ARM 架构的 CPU 性能监控框架.")]),t._v(" "),e("dt",[t._v("Reliability, Availability and Serviceability (RAS) features\nCONFIG_RAS")]),t._v(" "),e("dd",[t._v("RAS(可靠, 可用, 可维护) 是一个计算机硬件术语, 可靠性描述系统能够持续正确工作多长时间, 可用性描述系统能够正确工作的时间百分比, 可维护性描述系统从错误恢复到正常需要多长时间. 具有高等级 RAS 的硬件会有一系列额外的技术保障数据的可靠性与正确性.")]),t._v(" "),e("dt",[t._v("Thunderbolt support for Apple devices\nCONFIG_THUNDERBOLT")]),t._v(" "),e("dd",[t._v("苹果公司的[雷电接口](http://www.leiphone.com/news/201503/bIKjgTD7IHEkU3hs.html)支持.")]),t._v(" "),e("dt",[t._v("Android Drivers\nCONFIG_ANDROID")]),t._v(" "),e("dd",[t._v("安卓平台专用驱动")]),t._v(" "),e("dt",[t._v("NVDIMM (Non-Volatile Memory Device) Support\nCONFIG_LIBNVDIMM")]),t._v(" "),e("dd",[t._v("[NVDIMM](http://servers.pconline.com.cn/522/5222919.html)([非易失性内存](http://www.cnblogs.com/presida/p/3552935.html)) 支持.")]),t._v(" "),e("dt",[t._v("NVMEM Support\nCONFIG_NVMEM")]),t._v(" "),e("dd",[t._v('NVMEM(非易失性存储器) 设备支持. 包括:[EEPROM](http://baike.baidu.com/view/93707.htm),EFUSES... 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("System Trace Module devices\nCONFIG_STM")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Dummy STM driver\nCONFIG_STM_DUMMY")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Kernel console over STM devices\nCONFIG_STM_SOURCE_CONSOLE")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Intel(R) Trace Hub controller\nCONFIG_INTEL_TH")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("FPGA Configuration Framework\nCONFIG_FPGA")]),t._v(" "),e("dd",[t._v("FPGA 配置框架支持. 仅用于嵌入式系统.")])]),t._v(" "),e("h2",{attrs:{id:"firmware-drivers"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#firmware-drivers"}},[t._v("#")]),t._v(" Firmware Drivers")]),t._v(" "),e("p",[t._v("固件 ("),e("a",{attrs:{href:"http://baike.baidu.com/view/33738.htm",target:"_blank",rel:"noopener noreferrer"}},[t._v("Firmware"),e("OutboundLink")],1),t._v(") 驱动")]),t._v(" "),e("dl",[e("dt",[t._v("BIOS Enhanced Disk Drive calls determine boot disk\nCONFIG_EDD")]),t._v(" "),e("dd",[t._v('这是一个实验性选项, 支持[实模式](http://baike.baidu.com/view/404433.htm) BIOS 中的增强磁盘服务 (EDD), 从而允许内核从 BIOS 中获取第一启动盘 (可以从 sysfs 中查看具体是哪个硬盘), 大多数 BIOS 提供商都没有实现这个特性. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Sets default behavior for EDD detection to off\nCONFIG_EDD_OFF")]),t._v(" "),e("dd",[t._v('选 "Y" 相当于使用 "edd=off" 内核引导参数 (禁用 EDD), 选 "N" 相当于使用 "edd=on" 内核引导参数 (启用 EDD). 语法: edd={on|skipmbr|off}.')])])]),t._v(" "),e("dt",[t._v("Add firmware-provided memory map to sysfs\nCONFIG_FIRMWARE_MEMMAP")]),t._v(" "),e("dd",[t._v('将原始的固件内容映射到 "/sys/firmware/memmap" 文件. 主要用于调试目的, 以及 kexec 为下一个内核设置参数. 详见 "[Documentation/ABI/testing/sysfs-firmware-memmap](https://www.kernel.org/doc/Documentation/ABI/testing/sysfs-firmware-memmap)"文档. 不确定的选"N".')]),t._v(" "),e("dt",[t._v("BIOS update support for DELL systems via sysfs\nCONFIG_DELL_RBU")]),t._v(" "),e("dd",[t._v('允许 [Dell OpenManage](http://zh.community.dell.com/techcenter/systems-management/w/wiki/380.openmanage.aspx) 或 [DUP](http://wenku.baidu.com/view/1c00d6b2fd0a79563c1e72c9.html)(Dell Update Packages) 工具通过 sysfs 更新 DELL 服务器主板的 BIOS. 详见 "[Documentation/dell_rbu.txt](https://www.kernel.org/doc/Documentation/dell_rbu.txt)"文档. 即使你确实需要此功能, 也建议选"M"而不是"Y". 毕竟刷 BIOS 不能当做家常便饭. 留着刷 BIOS 的接口, 总是件危险的事.')]),t._v(" "),e("dt",[t._v("Dell Systems Management Base Driver\nCONFIG_DCDBAS")]),t._v(" "),e("dd",[t._v('该驱动为 DELL 服务器专用的系统管理软件 (Dell OpenManage) 提供了 sysfs 接口. 详见 "[Documentation/dcdbas.txt](https://www.kernel.org/doc/Documentation/dcdbas.txt)" 文档.')]),t._v(" "),e("dt",[t._v("Export DMI identification via sysfs to userspace\nCONFIG_DMIID")]),t._v(" "),e("dd",[t._v('将 [SMBIOS](http://baike.baidu.com/view/1790409.htm)([System Management BIOS](http://en.wikipedia.org/wiki/System_Management_BIOS))/[DMI](http://www.dmtf.org/standards/dmi)([Desktop Management Interface](http://en.wikipedia.org/wiki/Desktop_Management_Interface))中的系统识别信息 (序列号, 制造商, 型号, 等等) 导出到用户空间(/sys/class/dmi/id/). 开启此项后,[dmidecode](http://www.joecen.com/2007/04/19/view-bios-operating-system-in-the-dmi-smbios-information/) 工具就可以显示与制造商相关的信息. 此外, 基于 DMI 的模块的自动加载也依赖于此项. 建议选 "Y", 因为某些 Udev 规则和虚拟化检测需要它.')]),t._v(" "),e("dt",[t._v("DMI table support in sysfs\nCONFIG_DMI_SYSFS")]),t._v(" "),e("dd",[t._v("将 SMBIOS/DMI 中的原始数据 (包含大量的系统硬件信息) 导出到用户空间(/sys/firmware/dmi/). 以允许 [dmidecode](http://blog.sina.com.cn/s/blog_4152a9f50100wh48.html) 工具无需访问 / dev/mem 设备 (需要 root 权限) 即可将这些信息显示出来.")]),t._v(" "),e("dt",[t._v("iSCSI Boot Firmware Table Attributes\nCONFIG_ISCSI_IBFT_FIND")]),t._v(" "),e("dd",[t._v('使内核能定位 iBFT([iSCSI](http://zh.wikipedia.org/wiki/ISCSI) Boot Firmware Table) 在内存中的位置. 目的是为了能够从 iSCSI 驱动器中启动操作系统. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("iSCSI Boot Firmware Table Attributes module\nCONFIG_ISCSI_IBFT")]),t._v(" "),e("dd",[t._v('将 iBFT([iSCSI](http://baike.baidu.com/view/120148.htm) Boot Firmware Table) 的内容通过 sysfs 导出到用户空间. 如果你想在系统引导过程中动态检测 iSCSI 引导参数, 可以选 "Y", 否则应选 "N".')])])]),t._v(" "),e("dt",[t._v("Google Firmware Drivers\nCONFIG_GOOGLE_FIRMWARE")]),t._v(" "),e("dd",[t._v("仅用于 Google 自家的服务器")]),t._v(" "),e("dt",[t._v("EFI (Extensible Firmware Interface) Support")]),t._v(" "),e("dd",[t._v("[EFI/UEFI](http://www.intel.cn/content/www/cn/zh/architecture-and-technology/unified-extensible-firmware-interface/efi-homepage-general-technology.html)([统一可扩展固件接口](http://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2)) 支持. 2010 年之后, UEFI 已经基本全线取代了 BIOS.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("EFI Variable Support via sysfs\nCONFIG_EFI_VARS")]),t._v(" "),e("dd",[t._v('通过 sysfs 接口操作 (读 / 写 / 新建 / 删除)EFI 变量的老旧方式, 并且可能与新方式(CONFIG_EFIVAR_FS) 冲突. 应该选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Register efivars backend for pstore\nCONFIG_EFI_VARS_PSTORE")]),t._v(" "),e("dd",[t._v("将 efivars 模块 (CONFIG_EFI_VARS) 用作 pstore 文件系统 (CONFIG_PSTORE) 的后端. 这样就可以向 EFI 变量中写入各种 pstore 支持的信息, 例如, 控制台消息, 崩溃转储, 等等.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Disable using efivars as a pstore backend by default\nCONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE")]),t._v(" "),e("dd",[t._v("禁止默认将 efivars 模块 (CONFIG_EFI_VARS) 用作 pstore 文件系统 (CONFIG_PSTORE) 的后端.")])])]),t._v(" "),e("dt",[t._v("Enable EFI fake memory map\nCONFIG_EFI_FAKE_MEMMAP")]),t._v(" "),e("dd",[t._v('选 "Y" 等价于使用 "efi_fake_mem" 内核引导参数, 仅供调试使用.')])])])])])]),t._v(" "),e("h2",{attrs:{id:"file-systems"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#file-systems"}},[t._v("#")]),t._v(" File systems")]),t._v(" "),e("p",[t._v("文件系统")]),t._v(" "),e("dl",[e("dt",[t._v("Second extended fs support\nCONFIG_EXT2_FS")]),t._v(" "),e("dd",[t._v('Ext2 文件系统, 无日志. 详见 "[Documentation/filesystems/ext2.txt](https://www.kernel.org/doc/Documentation/filesystems/ext2.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Ext2 extended attributes\nCONFIG_EXT2_FS_XATTR")]),t._v(" "),e("dd",[t._v('Ext2 文件系统[扩展属性](http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7) (与 inode 关联的 name:value 对) 支持. 详见 [attr](http://www.bestbits.at/acl/man/man5/attr.txt) 手册. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Ext2 POSIX Access Control Lists\nCONFIG_EXT2_FS_POSIX_ACL")]),t._v(" "),e("dd",[t._v('POSIX [ACL](http://www.ibm.com/developerworks/cn/linux/l-acl/)(访问控制列表) 支持, 这是一种超越 "owner/group/world" 的权限管理方式, 可以更精细的针对每个用户进行访问控制. 详见 [acl](http://www.bestbits.at/acl/man/man5/acl.txt) 手册. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Ext2 Security Labels\nCONFIG_EXT2_FS_SECURITY")]),t._v(" "),e("dd",[t._v('"安全标签" 允许选择使用不同安全模块 (如 SELinux) 实现的访问控制模型, 如果你没有使用需要扩展属性的安全模块, 可以选 "N".')])])]),t._v(" "),e("dt",[t._v("Ext2 execute in place support\nCONFIG_EXT2_FS_XIP")]),t._v(" "),e("dd",[t._v("[芯片内执行](http://blog.chinaunix.net/uid-26404697-id-3152290.html) ([execute in place](http://en.wikipedia.org/wiki/Execute_in_place)) 的意思是程序在写入存储介质时就已经分配好运行时的地址, 因此不需要载入内存即可在芯片内执行, 一般仅在嵌入式系统上才使用这种技术.")])])]),t._v(" "),e("dt",[t._v("Ext3 journalling file system support\nCONFIG_EXT3_FS")]),t._v(" "),e("dd",[t._v('Ext3 日志型文件系统. 详见 "[Documentation/filesystems/ext3.txt](https://www.kernel.org/doc/Documentation/filesystems/ext3.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Default to 'data=ordered' in ext3\nCONFIG_EXT3_DEFAULTS_TO_ORDERED")]),t._v(" "),e("dd",[t._v('选 "Y" 表示将默认的日志模式设为 "data=ordered"(更安全), 选 "N" 表示将默认的日志模式设为 "data=writeback"(更危险). 选 "Y", 仅在你确实明白 "data=writeback" 的风险, 以及确实有充足的理由的时候, 才能选 "N".')]),t._v(" "),e("dt",[t._v("Ext3 extended attributes\nCONFIG_EXT3_FS_XATTR")]),t._v(" "),e("dd",[t._v('Ext3 文件系统[扩展属性](http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7) (与 inode 关联的 name:value 对) 支持. 详见 [attr](http://www.bestbits.at/acl/man/man5/attr.txt) 手册. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Ext3 POSIX Access Control Lists\nCONFIG_EXT3_FS_POSIX_ACL")]),t._v(" "),e("dd",[t._v('POSIX [ACL](http://www.ibm.com/developerworks/cn/linux/l-acl/)(访问控制列表) 支持, 这是一种超越 "owner/group/world" 的权限管理方式, 可以更精细的针对每个用户进行访问控制. 详见 [acl](http://www.bestbits.at/acl/man/man5/acl.txt) 手册. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Ext3 Security Labels\nCONFIG_EXT3_FS_SECURITY")]),t._v(" "),e("dd",[t._v('"安全标签" 允许选择使用不同安全模块 (如 SELinux) 实现的访问控制模型, 如果你没有使用需要扩展属性的安全模块, 可以选 "N".')])])])])]),t._v(" "),e("dt",[t._v("The Extended 4 (ext4) filesystem\nCONFIG_EXT4_FS")]),t._v(" "),e("dd",[t._v('Ext4 日志型文件系统. 详见 "[Documentation/filesystems/ext4.txt](https://www.kernel.org/doc/Documentation/filesystems/ext4.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Use ext4 for ext2/ext3 file systems\nCONFIG_EXT4_USE_FOR_EXT23")]),t._v(" "),e("dd",[t._v("在 ext2/ext3 文件系统上使用 ext4 驱动. 这样可以对 ext2/ext3/ext4 三种文件系统只使用同一个驱动. 主要目的是减少内核尺寸.")]),t._v(" "),e("dt",[t._v("Ext4 POSIX Access Control Lists\nCONFIG_EXT4_FS_POSIX_ACL")]),t._v(" "),e("dd",[t._v('POSIX [ACL](http://www.ibm.com/developerworks/cn/linux/l-acl/)(访问控制列表) 支持, 这是一种超越 "owner/group/world" 的权限管理方式, 可以更精细的针对每个用户进行访问控制. 详见 [acl](http://www.bestbits.at/acl/man/man5/acl.txt) 手册. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Ext4 Security Labels\nCONFIG_EXT4_FS_SECURITY")]),t._v(" "),e("dd",[t._v('"安全标签" 允许选择使用不同安全模块 (如 SELinux) 实现的访问控制模型, 如果你没有使用需要扩展属性的安全模块, 可以选 "N".')]),t._v(" "),e("dt",[t._v("EXT4 debugging support\nCONFIG_EXT4_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")])])]),t._v(" "),e("dt",[t._v("JBD (ext3) debugging support\nCONFIG_JBD_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("JBD2 (ext4) debugging support\nCONFIG_JBD2_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Reiserfs support\nCONFIG_REISERFS_FS")]),t._v(" "),e("dd",[t._v("曾经的明星文件系统, 特别擅长处理大量小文件的场合, 由于其创始人入狱, 前景不明.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable reiserfs debug mode\nCONFIG_REISERFS_CHECK")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Stats in /proc/fs/reiserfs\nCONFIG_REISERFS_PROC_INFO")]),t._v(" "),e("dd",[t._v("在 / proc/fs/reiserfs 文件中显示 Reiserfs 文件系统的状态, 仅供调试使用")]),t._v(" "),e("dt",[t._v("ReiserFS extended attributes\nCONFIG_REISERFS_FS_XATTR")]),t._v(" "),e("dd",[t._v('ReiserFS 文件系统[扩展属性](http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7) (与 inode 关联的 name:value 对) 支持. 详见 [attr](http://www.bestbits.at/acl/man/man5/attr.txt) 手册. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("ReiserFS POSIX Access Control Lists\nCONFIG_REISERFS_FS_POSIX_ACL")]),t._v(" "),e("dd",[t._v('POSIX [ACL](http://www.ibm.com/developerworks/cn/linux/l-acl/)(访问控制列表) 支持, 这是一种超越 "owner/group/world" 的权限管理方式, 可以更精细的针对每个用户进行访问控制. 详见 [acl](http://www.bestbits.at/acl/man/man5/acl.txt) 手册. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("ReiserFS Security Labels\nCONFIG_REISERFS_FS_SECURITY")]),t._v(" "),e("dd",[t._v('"安全标签" 允许选择使用不同安全模块 (如 SELinux) 实现的访问控制模型, 如果你没有使用需要扩展属性的安全模块, 可以选 "N".')])])])])]),t._v(" "),e("dt",[t._v("JFS filesystem support\nCONFIG_JFS_FS")]),t._v(" "),e("dd",[t._v('JFS 日志型文件系统. 详见 "[Documentation/filesystems/jfs.txt](https://www.kernel.org/doc/Documentation/filesystems/jfs.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("JFS POSIX Access Control Lists\nCONFIG_JFS_POSIX_ACL")]),t._v(" "),e("dd",[t._v('POSIX [ACL](http://www.ibm.com/developerworks/cn/linux/l-acl/)(访问控制列表) 支持, 这是一种超越 "owner/group/world" 的权限管理方式, 可以更精细的针对每个用户进行访问控制. 详见 [acl](http://www.bestbits.at/acl/man/man5/acl.txt) 手册. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("JFS Security Labels\nCONFIG_JFS_SECURITY")]),t._v(" "),e("dd",[t._v('"安全标签" 允许选择使用不同安全模块 (如 SELinux) 实现的访问控制模型, 如果你没有使用需要扩展属性的安全模块, 可以选 "N".')]),t._v(" "),e("dt",[t._v("JFS debugging\nCONFIG_JFS_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("JFS statistics\nCONFIG_JFS_STATISTICS")]),t._v(" "),e("dd",[t._v("在 / proc/fs/jfs / 目录中显示 JFS 文件系统的统计信息")])])]),t._v(" "),e("dt",[t._v("XFS filesystem support\nCONFIG_XFS_FS")]),t._v(" "),e("dd",[t._v('[XFS](http://zh.wikipedia.org/wiki/XFS) 日志型文件系统是一个高性能的文件系统 (笔者的最爱), [擅长大文件和多线程](http://os.51cto.com/art/201202/315553.htm). 详见 "[Documentation/filesystems/](https://www.kernel.org/doc/Documentation/filesystems/)"目录中"xfs*.txt" 系列文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("XFS Quota support\nCONFIG_XFS_QUOTA")]),t._v(" "),e("dd",[t._v("[XFS 磁盘配额](http://www.ibm.com/developerworks/cn/linux/l-lpic1-v3-104-4/index.html) (使用专用的 [xfs_quota](http://linux.die.net/man/8/xfs_quota) 工具)比通用磁盘配额模块 (CONFIG_QUOTA) 拥有更高级的特性, 它不但能够控制用户或组的磁盘用量, 还能控制项目 (文件夹) 的磁盘用量(无论哪个用户在项目的文件夹中创建文件), 但是不能同时使用组配额和项目配额. 此外, 对 XFS 来说, 配额数据记录在文件系统元数据中, 而不是像 CONFIG_QUOTA 那样记录在 aquota.user 和 aquota.group 文件中. 最后, XFS 配额和通用磁盘配额是两个相互独立的系统, 可以同时并存.")]),t._v(" "),e("dt",[t._v("XFS POSIX ACL support\nCONFIG_XFS_POSIX_ACL")]),t._v(" "),e("dd",[t._v('POSIX [ACL](http://www.ibm.com/developerworks/cn/linux/l-acl/)(访问控制列表) 支持, 这是一种超越 "owner/group/world" 的权限管理方式, 可以更精细的针对每个用户进行访问控制. 详见 [acl](http://www.bestbits.at/acl/man/man5/acl.txt) 手册. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("XFS Realtime subvolume support\nCONFIG_XFS_RT")]),t._v(" "),e("dd",[t._v('"实时子卷" 是专门存储文件数据的卷, 可以允许将日志与数据分开在不同的磁盘上, 例如将大块头的流媒体文件存储在高速磁盘组成的实时子卷上. 详见 [xfs](http://linux.die.net/man/5/xfs) 手册页.')]),t._v(" "),e("dt",[t._v("XFS Verbose Warnings\nCONFIG_XFS_WARN")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("XFS Debugging support\nCONFIG_XFS_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")])])]),t._v(" "),e("dt",[t._v("GFS2 file system support\nCONFIG_GFS2_FS")]),t._v(" "),e("dd",[t._v('[GFS2](https://access.redhat.com/site/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html/Global_File_System_2/ch-overview-GFS2.html) 可用于[搭建高可用集群文件系统](http://dreamfire.blog.51cto.com/418026/1219221), 由红帽公司开发, 允许所有集群节点并行访问, 同时又能够完美的保持文件系统的一致性: 一个节点对文件系统的任何修改都立即对所有其他节点可见. 详见 "[Documentation/filesystems/](https://www.kernel.org/doc/Documentation/filesystems/)"目录中"gfs*.txt" 系列文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("GFS2 DLM locking\nCONFIG_GFS2_FS_LOCKING_DLM")]),t._v(" "),e("dd",[t._v('GFS2 分布式锁管理器 ([DLM](https://access.redhat.com/site/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html/Global_File_System_2/s1-ov-lockbounce.html)). 务必选 "Y", 除非你知道自己在做什么.')])])]),t._v(" "),e("dt",[t._v("OCFS2 file system support\nCONFIG_OCFS2_FS")]),t._v(" "),e("dd",[t._v('[OCFS2](http://www.oracle.com/us/technologies/linux/025995.htm)([Oracle 集群文件系统](http://wenku.baidu.com/view/2ee98027192e45361066f5d1.html)) 的目标是成为一种通用文件系统. OCFS2 能使集群中的所有节点并发的通过标准文件系统接口来访问存储备. 要使用 OCFS2 还需要 [ocfs2-tools](http://oss.oracle.com/projects/ocfs2-tools) 的帮助. 详见 "[Documentation/filesystems/ocfs2.txt](https://www.kernel.org/doc/Documentation/filesystems/ocfs2.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("O2CB Kernelspace Clustering\nCONFIG_OCFS2_FS_O2CB")]),t._v(" "),e("dd",[t._v("O2CB(OCFS2 Cluster Base) 是位于内核空间的集群服务结构. 具体包括: NM(节点管理器, 监控所有节点),HB(心跳服务),TCP(控制节点间的通讯),DLM(分布式锁管理器),CONFIGFS(用户配置文件系统驱动, 挂载点是 / config),DLMFS(用户空间和内核空间 DLM 的接口). 开启此项后, 将只需要很少量的用户空间组件 (也就是 [ocfs2-tools](http://oss.oracle.com/projects/ocfs2-tools)),OCFS2 就可以转起来了. 但它只能玩转 OCFS2 自身, 玩不了其他集群.")]),t._v(" "),e("dt",[t._v("OCFS2 Userspace Clustering\nCONFIG_OCFS2_FS_USERSPACE_CLUSTER")]),t._v(" "),e("dd",[t._v("为用户空间的集群服务提供支持. 目的是为了配合 CONFIG_DLM 模块一起使用.")]),t._v(" "),e("dt",[t._v("OCFS2 statistics\nCONFIG_OCFS2_FS_STATS")]),t._v(" "),e("dd",[t._v("允许对 OCFS2 的使用状况进行一些统计. 开启后会增加内存占用.")]),t._v(" "),e("dt",[t._v("OCFS2 logging support\nCONFIG_OCFS2_DEBUG_MASKLOG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("OCFS2 expensive checks\nCONFIG_OCFS2_DEBUG_FS")]),t._v(" "),e("dd",[t._v("以性能为代价提供了存储一致性检测, 仅供调试使用")])])]),t._v(" "),e("dt",[t._v("Btrfs filesystem support\nCONFIG_BTRFS_FS")]),t._v(" "),e("dd",[t._v('[Btrfs](http://www.ibm.com/developerworks/cn/linux/l-cn-btrfs/) 是由 Oracle 于 2007 年宣布的支持写时复制 (COW) 的文件系统. 拥有众多抢眼球的特性: 软 RAID 管理, 卷管理, 克隆 / 快照, 压缩功能, 支持跨多块磁盘动态增大或收缩卷. 其目标是成为[下一代 Linux 标准文件系统](http://os.51cto.com/art/201004/195096.htm). 详见 "[Documentation/filesystems/btrfs.txt](https://www.kernel.org/doc/Documentation/filesystems/btrfs.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Btrfs POSIX Access Control Lists\nCONFIG_BTRFS_FS_POSIX_ACL")]),t._v(" "),e("dd",[t._v('POSIX [ACL](http://www.ibm.com/developerworks/cn/linux/l-acl/)(访问控制列表) 支持, 这是一种超越 "owner/group/world" 的权限管理方式, 可以更精细的针对每个用户进行访问控制. 详见 [acl](http://www.bestbits.at/acl/man/man5/acl.txt) 手册. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Btrfs with integrity check tool compiled in (DANGEROUS)\nCONFIG_BTRFS_FS_CHECK_INTEGRITY")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Btrfs will run sanity tests upon loading\nCONFIG_BTRFS_FS_RUN_SANITY_TESTS")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Btrfs debugging support\n")]),t._v(" "),e("dd",[t._v("仅供调试使用")])])]),t._v(" "),e("dt",[t._v("NILFS2 file system support\nCONFIG_NILFS2_FS")]),t._v(" "),e("dd",[t._v('[NILFS2](http://www.ibm.com/developerworks/cn/linux/l-cn-nilfs2/index.html) 是一种非常前卫的 "log-structured" 文件系统, 是 [Linux 下一代文件系统](http://www.ibm.com/developerworks/cn/linux/l-nilfs-exofs/)的有力竞争者. NILFS2 将底层设备当作一种只能追加写 (append) 的设备, 文件系统的任何修改都只以顺序追加的方式写入磁盘 (而是不覆盖旧数据), 从而避免耗时的寻道(seek) 操作, 从而大幅提升写入性能 (因为文件系统的整体效率主要由写操作的效率决定). 此种思路带来了一系列靓瞎眼的特性: 自动不间断快照(可以迅速恢复被删除的文件或者回到先前某个特定的时间点), 快速崩溃恢复(比大多数日志型文件系统还要快), 高性能(在 SSD 上更有绝对优势). 但也带来了一个新问题: 需要垃圾收集机制以清理旧数据, 造成垃圾收集时的性能降低(可以通过合理安排垃圾收集时间来避免).NILFS2 目前不支持如下功能: atime(访问时间),POSIX ACL, 扩展属性. 不过考虑到 SSD(固态硬盘) 即将成为主流, 假以时日, 前途大大的啊!. 详见 "[Documentation/filesystems/nilfs2.txt](https://www.kernel.org/doc/Documentation/filesystems/nilfs2.txt)" 文档.')]),t._v(" "),e("dt",[t._v("F2FS filesystem support\nCONFIG_F2FS_FS")]),t._v(" "),e("dd",[t._v('[F2FS](http://blog.chinaunix.net/uid-28989651-id-3878690.html) 也是一种非常前卫的 "log-structured" 文件系统, 针对基于 NAND 闪存的存储设备进行了特别设计, 使之更加适应新的存储介质 (也就是闪存), 据称它[是目前 SSD 上性能最好的文件系统](http://www.linuxidc.com/Linux/2015-04/116189.htm).')]),t._v(" "),e("dt",[t._v("Direct Access (DAX) support\nCONFIG_FS_DAX")]),t._v(" "),e("dd",[t._v('DAX(Direct Access)的含义是绕过内存缓冲直接访问块设备. 选 "Y" 后, 就可以用 "mount -o dax" 方式挂载块设备以避免使用 pagecache 作为 I/O 缓冲. 例如将持续性非易失内存 (断电内容不丢失) 作磁盘用时, 或者挂载内存盘时, 使用此特性便恰到好处. 还有一种用法是在虚拟机内使用 "mount -o dax" 方式挂载已经缓存在宿主机内存中的块设备文件(或者倒过来也可以).')]),t._v(" "),e("dt",[t._v("Enable POSIX file locking API\nCONFIG_FILE_LOCKING")]),t._v(" "),e("dd",[t._v('POSIX 标准文件锁定 API 支持. NFS 之类的网络文件系统和给文件加锁与解锁的 [flock()](http://blog.sina.com.cn/s/blog_484102dd0101385h.html) 系统调用需要它. 不确定的选 "Y".')]),t._v(" "),e("dt",[t._v("Dnotify support\nCONFIG_DNOTIFY")]),t._v(" "),e("dd",[t._v('旧式的基于目录的文件变化的通知机制 (已被 Inotify 取代), 目前仅有 NFSv4 以及少量古董程序依赖它. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Inotify support for userspace\nCONFIG_INOTIFY_USER")]),t._v(" "),e("dd",[t._v('用户空间的 Inotify 支持.[Inotify](http://zh.wikipedia.org/zh-cn/Inotify) 是替代 Dnotify 的文件系统变化通知机制. 建议选 "Y".[提示] 如果你使用了 [systemd](http://zh.wikipedia.org/wiki/Systemd) 作为 init, 那就必须选 "Y".')]),t._v(" "),e("dt",[t._v("Filesystem wide access notification\nCONFIG_FANOTIFY")]),t._v(" "),e("dd",[t._v('[fanotify](http://www.ibm.com/developerworks/cn/linux/l-cn-fanotify/) 是一种打算取代 Inotify 的文件系统变化通知机制, 不过, 由于目前 [Fanotify 比 inotify](http://blog.yikuyiku.com/?p=2885) 支持的文件系统事件类型少很多, 完全取代 Inotify 还不现实. Udev 的 "[Predictable Network Interface Names](http://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/)"功能依赖于它. 建议选"Y".[提示] 如果你使用了 [systemd](http://zh.wikipedia.org/wiki/Systemd) 作为 init, 那就必须选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("fanotify permissions checking\nCONFIG_FANOTIFY_ACCESS_PERMISSIONS")]),t._v(" "),e("dd",[t._v('允许 fanotify 的监听器 (listener) 对文件系统事件进行权限检查. 这样, 监听器就可以在系统访问某个文件之前, 首先扫描此文件. 某些防病毒程序以及[分级存储管理](http://www.searchstorage.com.cn/whatis/word_2112.htm)系统可能需要此特性. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("Quota support\nCONFIG_QUOTA")]),t._v(" "),e("dd",[t._v("通用的磁盘配额支持 (限制某个用户或者某组用户的磁盘占用空间). 需要配合 [quota-tools](http://sourceforge.net/projects/linuxquota/) 工具使用.")]),t._v(" "),e("dt",[t._v("Report quota messages through netlink interface\nCONFIG_QUOTA_NETLINK_INTERFACE")]),t._v(" "),e("dd",[t._v('通过 [netlink](http://zh.wikipedia.org/wiki/Netlink) 接口报告 QUOTA 的警告信息 (例如 "到达限额"). 不确定的选 "Y".')]),t._v(" "),e("dt",[t._v("Print quota warnings to console (OBSOLETE)\nCONFIG_PRINT_QUOTA_WARNING")]),t._v(" "),e("dd",[t._v('将 QUOTA 的警告信息直接显示在控制台上. 反对使用, 未来会移除此项. 选 "N".')]),t._v(" "),e("dt",[t._v("Additional quota sanity checks\nCONFIG_QUOTA_DEBUG")]),t._v(" "),e("dd",[t._v('对 quota 内部结构进行额外的完整性检查. 主要用于调试目的. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Old quota format support\nCONFIG_QFMT_V1")]),t._v(" "),e("dd",[t._v('老旧的 v1 版配额格式 (linux-2.4.22 之前使用的格式) 支持. 选 "N".')]),t._v(" "),e("dt",[t._v("Quota format vfsv0 and vfsv1 support\nCONFIG_QFMT_V2")]),t._v(" "),e("dd",[t._v("vfsv0/vfsv1 配额格式支持. 两者都支持 32 位的 UID/GID, 而 vfsv1 还支持 64 位的 inode/block 配额. 建议开启.")]),t._v(" "),e("dt",[t._v("Kernel automounter version 4 support (also supports v3)\nCONFIG_AUTOFS4_FS")]),t._v(" "),e("dd",[t._v('第四版内核按需自动挂载文件系统的支持 (也支持 v3). 此特性需要配合用户空间工具 ([autofs](https://www.kernel.org/pub/linux/daemons/autofs/v5/) 或 [Systemd](http://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html)) 使用, 以实现仅在某个文件系统挂载点真正被访问到的时候才触发挂载操作.[提示] 使用了 [systemd](http://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html) 的系统建议选 "Y".')]),t._v(" "),e("dt",[t._v("FUSE (Filesystem in Userspace) support\nCONFIG_FUSE_FS")]),t._v(" "),e("dd",[t._v('[FUSE](http://zh.wikipedia.org/wiki/FUSE) 允许在用户空间实现一个全功能的文件系统, 还有一个与之对应的 [libfuse2](http://fuse.sourceforge.net/) 库和相关工具. 详见 "[Documentation/filesystems/fuse.txt](https://www.kernel.org/doc/Documentation/filesystems/fuse.txt)" 文档. 如果你打算开发一个自己的文件系统或者使用一个基于 FUSE 的文件系统 (例如 [NTFS-3G](https://wiki.archlinux.org/index.php/NTFS-3G_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29) 或 [ZFS-FUSE](http://www.ibm.com/developerworks/cn/linux/l-zfs/index.html) 或 [GlusterFS](http://my.oschina.net/uvwxyz/blog/176839)), 可以选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Character device in Userspace support\nCONFIG_CUSE")]),t._v(" "),e("dd",[t._v("这是一个 FUSE 扩展, 用于在用户空间实现字符设备支持.")])])]),t._v(" "),e("dt",[t._v("Overlay filesystem support\nCONFIG_OVERLAY_FS")]),t._v(" "),e("dd",[t._v("[overlay](http://www.udpwork.com/item/6821.html) 的含意是以层叠的方式组合上下两个文件系统层, 常和容器技术配合使用. 详见 [Documentation/filesystems/overlayfs.txt](https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt) 文档.")]),t._v(" "),e("dt",[t._v("Caches")]),t._v(" "),e("dd",[t._v("文件系统缓存")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("General filesystem local caching manager\nCONFIG_FSCACHE")]),t._v(" "),e("dd",[t._v('通用文件系统本地缓存管理器. 它为各种不同的文件系统 (例如网络文件系统) 提供了统一的本地缓存框架. 这样各种缓存实现可以作为插件添加进来. 详见 "[Documentation/filesystems/caching/fscache.txt](https://www.kernel.org/doc/Documentation/filesystems/caching/fscache.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Gather statistical information on local caching\nCONFIG_FSCACHE_STATS")]),t._v(" "),e("dd",[t._v("收集本地缓存的统计信息 (这会增加系统运行负载), 并通过 / proc/fs/fscache/stats 文件导出到用户空间. 主要用于调试目的.")]),t._v(" "),e("dt",[t._v("Gather latency information on local caching\nCONFIG_FSCACHE_HISTOGRAM")]),t._v(" "),e("dd",[t._v("收集本地缓存的延迟信息 (这会增加系统运行负载), 并通过 / proc/fs/fscache/histogram 文件导出到用户空间. 主要用于调试目的.")]),t._v(" "),e("dt",[t._v("Debug FS-Cache\nCONFIG_FSCACHE_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Maintain global object list for debugging purposes\nCONFIG_FSCACHE_OBJECT_LIST")]),t._v(" "),e("dd",[t._v("在 / proc/fs/fscache/objects 文件中维护一个活动缓存对象的全局列表. 仅用于调试目的.")]),t._v(" "),e("dt",[t._v("Filesystem caching on files\nCONFIG_CACHEFILES")]),t._v(" "),e("dd",[t._v("将一个已挂载的文件系统用作另一个文件系统的缓存. 例如将一个本地磁盘分区挂载为一个远程网络文件系统的缓存, 或者将一个高速设备 (例如 SSD) 用作一个低速设备 (例如普通硬盘) 的缓存.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Debug CacheFiles\nCONFIG_CACHEFILES_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Gather latency information on CacheFiles\nCONFIG_CACHEFILES_HISTOGRAM")]),t._v(" "),e("dd",[t._v("收集本地缓存的延迟信息 (这会增加系统运行负载), 并通过 / proc/fs/cachefiles/histogram 文件导出到用户空间. 主要用于调试目的.")])])])])])])]),t._v(" "),e("dt",[t._v("CD-ROM/DVD Filesystems")]),t._v(" "),e("dd",[t._v("CD-ROM/DVD [光盘文件系统](http://blog.chinaunix.net/uid-11647316-id-2858441.html)")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("ISO 9660 CDROM file system support\nCONFIG_ISO9660_FS")]),t._v(" "),e("dd",[t._v('[ISO9660](http://zh.wikipedia.org/wiki/ISO_9660) 是所有 CD/DVD 光盘通用的标准文件系统. 建议选 "Y". 详见 "[Documentation/filesystems/isofs.txt](https://www.kernel.org/doc/Documentation/filesystems/isofs.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Microsoft Joliet CDROM extensions\nCONFIG_JOLIET")]),t._v(" "),e("dd",[t._v('Microsoft 对 ISO9660 文件系统的 [Joliet 扩展](http://baike.baidu.com/view/32493.htm), 允许在文件名中使用 Unicode 字符, 也允许长文件名. 建议选 "Y".')]),t._v(" "),e("dt",[t._v("Transparent decompression extension\nCONFIG_ZISOFS")]),t._v(" "),e("dd",[t._v('Linux 对 ISO9660 文件系统的扩展, 允许将数据透明的压缩存储在 CD 上. 使用并不广泛, 不确定的可以选 "N".')])])]),t._v(" "),e("dt",[t._v("UDF file system support\nCONFIG_UDF_FS")]),t._v(" "),e("dd",[t._v('[UDF](http://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%85%89%E7%A2%9F%E6%A0%BC%E5%BC%8F) 被设计为可擦写格式 (其实质是管理增量写入), 其目标是取代 ISO9660, 现已经广泛地用于大容量 DVD 光盘上 (特别是刻录盘). 建议选 "Y". 详见 "[Documentation/filesystems/udf.txt](https://www.kernel.org/doc/Documentation/filesystems/udf.txt)" 文档.')])])]),t._v(" "),e("dt",[t._v("DOS/FAT/NT Filesystems")]),t._v(" "),e("dd",[t._v("DOS/FAT/NTFS 文件系统")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("MSDOS fs support\nCONFIG_MSDOS_FS")]),t._v(" "),e("dd",[t._v("古老的 MSDOS 文件系统 (FAT16), 基本绝种了")]),t._v(" "),e("dt",[t._v("VFAT (Windows-95) fs support\nCONFIG_VFAT_FS")]),t._v(" "),e("dd",[t._v('从 Win95 开始使用的 VFAT 文件系统 (FAT32). 如果你要使用基于 UEFI 平台的电脑, 并且使用 GPT 磁盘分区, 则必须选 "Y". 详见 "[Documentation/filesystems/vfat.txt](https://www.kernel.org/doc/Documentation/filesystems/vfat.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Default codepage for FAT\nCONFIG_FAT_DEFAULT_CODEPAGE")]),t._v(" "),e("dd",[t._v('在 FAT 系列文件系统上,"8.3" 格式的短文件名以特定的[代码页](http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A0%81%E9%A1%B5)进行存储 (可以通过 chcp 命令查看), 但长文件名却以 Unicode 进行存储. 此选项的作用就是指定将长文件名转换为短文件名时使用的默认代码页. 可以通过 "codepage" 挂载选项进行修改. 简体中文通常使用 "936", 繁体中文通常使用 "950".')]),t._v(" "),e("dt",[t._v("Default iocharset for FAT\nCONFIG_FAT_DEFAULT_IOCHARSET")]),t._v(" "),e("dd",[t._v('指定默认以什么[字符集](http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81)显示文件名, 这个值可以通过 "iocharset" 挂载选项修改. 但必须与系统的 locale 设置保持一致. 例如在 "zh_CN.UTF-8" 或 "en_US.UTF-8" 的情况下应该使用 "utf8".[注意] 应谨慎使用 "iocharset=utf8", 因为它会导致 FAT 文件系统上的文件名变得大小写敏感.')])])]),t._v(" "),e("dt",[t._v("exFAT fs support\nCONFIG_EXFAT_FS")]),t._v(" "),e("dd",[t._v("[exfat-nofuse](https://github.com/dorimanx/exfat-nofuse/) 开源项目提供的内核级 exFAT,FAT12,FAT16,FAT32(vfat) 文件系统支持[补丁](https://github.com/dorimanx/exfat-nofuse/archive/master.zip). 此补丁是取代前面两个内核自带的 FAT 驱动的更优秀替代品.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("enable discard support\nCONFIG_EXFAT_DISCARD")]),t._v(" "),e("dd",[t._v('"discard" 挂载选项支持. 在 U 盘或者 SSD 上使用此文件系统的用户必选 "Y".')]),t._v(" "),e("dt",[t._v("enable delayed sync\nCONFIG_EXFAT_DELAYED_SYNC")]),t._v(" "),e("dd",[t._v('延迟刷写磁盘脏数据, 可提高文件系统性能. 有电池的笔记本或者有 UPS 的台式机建议选 "Y".')]),t._v(" "),e("dt",[t._v("enable kernel debug features via ioctl\nCONFIG_EXFAT_KERNEL_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用.")]),t._v(" "),e("dt",[t._v("print debug messages\nCONFIG_EXFAT_DEBUG_MSG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("Default codepage for exFAT\nCONFIG_EXFAT_DEFAULT_CODEPAGE")]),t._v(" "),e("dd",[t._v('在 FAT 系列文件系统上,"8.3" 格式的短文件名以特定的[代码页](http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A0%81%E9%A1%B5)进行存储 (可以通过 chcp 命令查看), 但长文件名却以 Unicode 进行存储. 此选项的作用就是指定将长文件名转换为短文件名时使用的默认代码页. 可以通过 "codepage" 挂载选项进行修改. 简体中文通常使用 "936", 繁体中文通常使用 "950".')]),t._v(" "),e("dt",[t._v("Default iocharset for exFAT\nCONFIG_EXFAT_DEFAULT_IOCHARSET")]),t._v(" "),e("dd",[t._v('指定默认以什么[字符集](http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81)显示文件名, 这个值可以通过 "iocharset" 挂载选项修改. 但必须与系统的 locale 设置保持一致. 例如在 "zh_CN.UTF-8" 或 "en_US.UTF-8" 的情况下应该使用 "utf8".[注意] 应谨慎使用 "iocharset=utf8", 因为它会导致 FAT 文件系统上的文件名变得大小写敏感.')])])]),t._v(" "),e("dt",[t._v("NTFS file system support\nCONFIG_NTFS_FS")]),t._v(" "),e("dd",[t._v('NTFS 文件系统. 仅选中此项表示仅支持只读 (不支持 NTFS 压缩或加密文件), 不支持写入. 详见 "[Documentation/filesystems/ntfs.txt](https://www.kernel.org/doc/Documentation/filesystems/ntfs.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("NTFS debugging support\nCONFIG_NTFS_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("NTFS write support\nCONFIG_NTFS_RW")]),t._v(" "),e("dd",[t._v('由于微软没有公开 NTFS 的技术标准, 所以内核只能支持非常残缺的写入功能: 仅能覆盖已存在的文件但不能改变其长度, 不能创建文件或目录. 建议选 "N".[提示] 在 Linux 环境下写入 NTFS 始终是一件危险的事情, 即使对于 [NTFS-3G](http://www.oschina.net/question/12_4941) 也是如此, 除了不支持压缩或加密文件之外, 网上还有不少[血的教训](http://bbs.cfanclub.net/thread-497916-1-1.html), 有兴趣可以搜搜.')])])])])]),t._v(" "),e("dt",[t._v("Pseudo filesystems")]),t._v(" "),e("dd",[t._v("伪文件系统")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("/proc file system support\nCONFIG_PROC_FS")]),t._v(" "),e("dd",[t._v('显示系统状态的虚拟文件系统 (进程信息, irq 设置, 内存使用, 设备驱动, 网络状态等), 通常挂载到 "[/proc](http://www.ibm.com/developerworks/cn/linux/l-proc.html)"目录. 许多程序依赖于它, systemd 也依赖于它. 选"Y", 除非你知道自己在做什么. 详见"[Documentation/filesystems/proc.txt](https://www.kernel.org/doc/Documentation/filesystems/proc.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("/proc/kcore support\nCONFIG_PROC_KCORE")]),t._v(" "),e("dd",[t._v('系统物理内存的映象. 建议选 "N".')]),t._v(" "),e("dt",[t._v("/proc/vmcore support\nCONFIG_PROC_VMCORE")]),t._v(" "),e("dd",[t._v("以 ELF 格式转储的已崩溃内核镜像, 仅供调试使用")]),t._v(" "),e("dt",[t._v("Sysctl support (/proc/sys)\nCONFIG_PROC_SYSCTL")]),t._v(" "),e("dd",[t._v('显示各种不同的内核调节参数, 并让 root 用户能通过 / proc/sys / 目录交互地更改其中的某些内容. 必选 "Y", 除非你是嵌入式系统并且知道自己在做什么. 详见 "[Documentation/sysctl/](https://www.kernel.org/doc/Documentation/sysctl/)" 目录中的文档.')]),t._v(" "),e("dt",[t._v("Enable /proc page monitoring\nCONFIG_PROC_PAGE_MONITOR")]),t._v(" "),e("dd",[t._v("用于监视进程内存占用的接口 (/proc/"),e("pid",[t._v('/{smaps,clear_refs,pagemap} 和 / proc/{kpagecount,kpageflags}). 建议选 "Y".')])],1)])]),t._v(" "),e("dt",[t._v("sysfs file system support\nCONFIG_SYSFS")]),t._v(" "),e("dd",[t._v('导出内核内部对象及其属性和对象之间的相互关系的文件系统, 通常挂载到 "[/sys](http://www.ibm.com/developerworks/cn/linux/l-cn-sysfs/index.html)"目录, sysfs 把连接在系统上的设备和总线以及驱动程序等组织成为一个分级的文件, 并允许通过该文件系统调整某些内核子系统以及设备的参数. 内核启动时依靠它挂载类似"/dev/sda1"这样形式的根分区, 禁用 sysfs 后必须在内核引导参数中使用设备号指定根分区 (类似"root=03:01"这样).systemd 依赖于它. 选"Y", 除非你知道自己在做什么. 详见"[Documentation/filesystems/](https://www.kernel.org/doc/Documentation/filesystems/)"目录中"sysfs*.txt" 系列文档.')]),t._v(" "),e("dt",[t._v("Tmpfs virtual memory file system support (former shm fs)\nCONFIG_TMPFS")]),t._v(" "),e("dd",[t._v('[tmpfs](http://baike.baidu.com/view/1511292.htm) 文件系统 (以前叫 shm[共享内存] 文件系统), 大多数系统的正常运行都依赖于它(例如 [Udev](http://zh.wikipedia.org/wiki/Udev) 使用的 "/dev/" 目录通常挂载为 tmpfs). 选 "Y", 除非你知道自己在做什么. 详见 "[Documentation/filesystems/tmpfs.txt](https://www.kernel.org/doc/Documentation/filesystems/tmpfs.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Tmpfs POSIX Access Control Lists\nCONFIG_TMPFS_POSIX_ACL")]),t._v(" "),e("dd",[t._v('POSIX [ACL](http://www.ibm.com/developerworks/cn/linux/l-acl/)(访问控制列表) 支持, 这是一种超越 "owner/group/world" 的权限管理方式, 可以更精细的针对每个用户进行访问控制. 详见 [acl](http://www.bestbits.at/acl/man/man5/acl.txt) 手册. 许多发行版都要求 / dev / 目录支持 ACL(例如让 ALSA 相关的文件可以正常工作), 并且 systemd 也建议开启它. 不确定的选 "Y".')]),t._v(" "),e("dt",[t._v("Tmpfs extended attributes\nCONFIG_TMPFS_XATTR")]),t._v(" "),e("dd",[t._v('TMPFS 文件系统[扩展属性](http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7) (与 inode 关联的 name:value 对) 支持 (仅支持 trusted.* 和 security.* 命名空间). 详见 [attr](http://www.bestbits.at/acl/man/man5/attr.txt) 手册. 由于它被 CONFIG_TMPFS_POSIX_ACL 依赖, 并且 systemd 也建议开启它. 建议选 "Y".')])])]),t._v(" "),e("dt",[t._v("HugeTLB file system support\nCONFIG_HUGETLBFS")]),t._v(" "),e("dd",[t._v('这是使用大内存页的传统方式, 需要专门进行配置以及应用程序的特别支持. 推荐使用较新的[透明大内存页](http://blog.chinaunix.net/uid-26489617-id-3205109.html) (CONFIG_TRANSPARENT_HUGEPAGE). 选 "N".')]),t._v(" "),e("dt",[t._v("Userspace-driven configuration filesystem\nCONFIG_CONFIGFS_FS")]),t._v(" "),e("dd",[t._v('[configfs](http://lwn.net/Articles/148973/) 是一个基于内存的虚拟文件系统, 与 sysfs 类似但又有不同: configfs 用于从用户空间查看 / 修改 / 创建 / 删除内核对象, 而 sysfs 仅能查看 / 修改由内核负责创建和删除的对象. 通常挂载到 "/config" 目录. 详见 "[Documentation/configfs/](https://www.kernel.org/doc/Documentation/configfs/)"目录中的文档. 不确定的选"N".')])])]),t._v(" "),e("dt",[t._v("Miscellaneous filesystems\nCONFIG_MISC_FILESYSTEMS")]),t._v(" "),e("dd",[t._v("各种非主流的杂项文件系统, 有些是专用于嵌入式系统, 有些是来自于其他操作系统, 还有些专用于某些特定场合.")]),t._v(" "),e("dd",[e("dl",[e("dt",{staticClass:"omit"},[t._v("{此处省略哪些非常非主流的文件系统}")]),t._v(" "),e("dt",[t._v("eCrypt filesystem layer support\nCONFIG_ECRYPT_FS")]),t._v(" "),e("dd",[t._v("[eCryptfs](http://www.ibm.com/developerworks/cn/linux/l-cn-ecryptfs/) 是一个符合 POSIX 标准的企业级文件系统加密栈 (加密 / 解密转换层), 工作在 [VFS](http://www.ibm.com/developerworks/cn/linux/l-virtual-filesystem-switch/)(虚拟文件系统) 层, 可以在各种普通文件系统上使用 (需要 [ecryptfs-utils](http://ecryptfs.org/) 工具).eCryptfs 将加密元数据保存在每个文件的首部, 从而允许文件在不同主机之间任意移动, 同时又能确保仅在内核密钥环中拥有正确密钥的时候才能解密文件的内容. 此外, eCryptfs 还支持高级密匙管理和配置策略.[提示] [使用 eCryptfs](http://wiki.ubuntu.org.cn/Ecryptfs%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F) 之后, 读操作性能最大可下降 1/3 左右, 写操作性能则普遍下降一个数量级.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable notifications for userspace key wrap/unwrap\nCONFIG_ECRYPT_FS_MESSAGING")]),t._v(" "),e("dd",[t._v('允许 ecryptfsd 守护进程操作 / dev/ecryptfs 设备. 这将允许用户空间使用其他后端 (例如 OpenSSL) 加密 / 解密 FEK(file encryption key). 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("SquashFS 4.0 - Squashed file system support\nCONFIG_SQUASHFS")]),t._v(" "),e("dd",[t._v("[SquashFS](http://www.ibm.com/developerworks/cn/linux/1306_qinzl_squashfs/) 是一种高压缩率的只读文件系统, 可以使用多种压缩算法 (例如 zlib,xz,lzo).[SquashFS](http://squashfs.sourceforge.net/) 常用于嵌入式设备和 LiveCD 系统.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Squashfs XATTR support\nCONFIG_SQUASHFS_XATTR")]),t._v(" "),e("dd",[t._v('Squashfs 文件系统[扩展属性](http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7) (与 inode 关联的 name:value 对) 支持. 详见 [attr](http://www.bestbits.at/acl/man/man5/attr.txt) 手册. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Include support for ZLIB compressed file systems\nCONFIG_SQUASHFS_ZLIB")]),t._v(" "),e("dd",[t._v("ZLIB 是 Squashfs 默认的标准压缩算法. 在压缩率和性能之间达到了最佳的平衡.")]),t._v(" "),e("dt",[t._v("Include support for LZO compressed file systems\nCONFIG_SQUASHFS_LZO")]),t._v(" "),e("dd",[t._v("LZO 是性能最佳的压缩算法 (CPU 和内存占用都很低), 但是压缩率确是最差的. 常用于资源有限的嵌入式系统.")]),t._v(" "),e("dt",[t._v("Include support for XZ compressed file systems\nCONFIG_SQUASHFS_XZ")]),t._v(" "),e("dd",[t._v("XZ 是压缩率最佳的压缩算法, 但其 CPU 和内存占用都最高. 可用于 PC 环境.")]),t._v(" "),e("dt",[t._v("Use 4K device block size?\nCONFIG_SQUASHFS_4K_DEVBLK_SIZE")]),t._v(" "),e("dd",[t._v('出于降低潜伏时间的考虑, Squashfs 默认使用 1K 大小的块. 但是在 [MTD NAND](http://www.cnblogs.com/hnrainll/archive/2011/05/17/2048288.html) 设备上, 使用 4K 大小的块才可以获得最佳性能. 此外, 在大多数设备上, 使用 4K 大小的块才能获得最佳连续读取性能. 如果你的 Squashfs 位于闪存设备上, 建议选 "Y". 否则建议选 "N".')]),t._v(" "),e("dt",[t._v("Additional option for memory-constrained systems\nCONFIG_SQUASHFS_EMBEDDED")]),t._v(" "),e("dd",[t._v('允许强制指定缓存大小. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Number of fragments cached\nCONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE")]),t._v(" "),e("dd",[t._v('SquashFS 默认缓存最后 3 个从文件系统上读取的片段. 降低此值 (最小值是 "1", 不能设为 "0") 可以降低内存的占用, 但是会增加底层物理设备的读取次数. 增加此值则正好相反.[提示]按一般经验, 大于 "3" 的值并不能带来显著的性能提升.')])])])])]),t._v(" "),e("dt",[t._v("EFI Variable filesystem\nCONFIG_EFIVAR_FS")]),t._v(" "),e("dd",[t._v('efivarfs 是访问 "EFI 变量" 的新方式, 意在取代传统的 sysfs(CONFIG_EFI_VARS) 方式, 其主要优点是可以突破 sysfs 中变量值不能超出 1024 字节的限制. 开启后可支持各种[操作 EFI 变量的工具](https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface#Userspace_Tools):[efivar‎](https://github.com/vathpela/efivar),[efibootmgr](http://linux.dell.com/efibootmgr/),[vathpela/efibootmgr](https://github.com/vathpela/efibootmgr),[uefivars](https://github.com/fpmurphy/Various),[efitools](http://git.kernel.org/cgit/linux/kernel/git/jejb/efitools.git),[fwts](https://wiki.ubuntu.com/Kernel/Reference/fwts)(Firmware Test Suite).systemd 依赖于它. 建议选 "Y".')])])]),t._v(" "),e("dt",[t._v("Network File Systems\nCONFIG_NETWORK_FILESYSTEMS")]),t._v(" "),e("dd",[t._v("网络文件系统")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("NFS client support\nCONFIG_NFS_FS")]),t._v(" "),e("dd",[t._v("[NFS](http://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F)(Network File System) 客户端支持, 这样就可以使用 [nfs-utils](http://linux-nfs.org/) 包中的 [mount.nfs](http://linux.die.net/man/8/mount.nfs) 工具挂载远程服务器提供的 NFS 文件系统. 详见 [nfs](http://linux.die.net/man/5/nfs) 手册页.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("NFS client support for NFS version 2\nCONFIG_NFS_V2")]),t._v(" "),e("dd",[t._v("NFSv2(RFC 1094) 版本协议支持")]),t._v(" "),e("dt",[t._v("NFS client support for NFS version 3\nCONFIG_NFS_V3")]),t._v(" "),e("dd",[t._v("NFSv3(RFC 1813) 版本协议支持")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("NFS client support for the NFSv3 ACL protocol extension\nCONFIG_NFS_V3_ACL")]),t._v(" "),e("dd",[t._v('为 NFSv3 添加 POSIX ACL 支持 (Solaris NFSv3 ACL). 大多数 NFS 服务器都不支持这个扩展. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("NFS client support for NFS version 4\nCONFIG_NFS_V4")]),t._v(" "),e("dd",[t._v("NFSv4(RFC 3530) 版本协议支持")]),t._v(" "),e("dt",[t._v("Provide swap over NFS support\nCONFIG_NFS_SWAP")]),t._v(" "),e("dd",[t._v("允许将 NFS 文件系统用做 swap 分区.")])])]),t._v(" "),e("dt",[t._v("NFS client support for NFSv4.1\nCONFIG_NFS_V4_1")]),t._v(" "),e("dd",[t._v("[NFSv4.1](http://stor-age.zdnet.com.cn/stor-age/2008/0331/786932.shtml)(RFC 5661) 版本协议客户端支持, 这样就可以使用 [nfs-utils](http://linux-nfs.org/) 包中的 [mount.nfs](http://linux.die.net/man/8/mount.nfs) 工具挂载远程服务器提供的 NFS 文件系统. 详见 [nfs](http://linux.die.net/man/5/nfs) 手册页以及 [NFS 各个版本之间的比较](http://blog.csdn.net/ycnian/article/details/8515517).")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("NFSv4.1 Implementation ID Domain\nCONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN")]),t._v(" "),e("dd",[t._v('NFSv4.1 规范新引入了[会话机制](http://www.cnblogs.com/zhenjing/archive/2011/05/29/NFS4_1_session.html), 该选项定义在建立会话过程中使用在 EXCHANGE_ID 指令中的 "domain" 部分的值. 这个值必须是个标准的 DNS 域名格式. 如果你没有修改内核的 NFS 客户端代码, 那么请保持默认值 "kernel.org".')])])]),t._v(" "),e("dt",[t._v("Root file system on NFS\nCONFIG_ROOT_NFS")]),t._v(" "),e("dd",[t._v('允许将 NFS 挂载为根文件系统 (root=/dev/nfs), 通常用于没有本地存储设备的无盘工作站 (还必须开启 CONFIG_IP_PNP 以及至少一个子项). 详见 "[Documentation/filesystems/nfs/nfsroot.txt](https://www.kernel.org/doc/Documentation/filesystems/nfs/nfsroot.txt)" 文档.')]),t._v(" "),e("dt",[t._v("Provide NFS client caching support\nCONFIG_NFS_FSCACHE")]),t._v(" "),e("dd",[t._v("为 NFS 提供本地缓存支持, 也就是利用 CONFIG_FSCACHE 选项的功能.")]),t._v(" "),e("dt",[t._v("Use the legacy NFS DNS resolver\nCONFIG_NFS_USE_LEGACY_DNS")]),t._v(" "),e("dd",[t._v('内核现在有自己的 DNS 解析实现, 如果你依然想使用老式的 DNS 解析脚本, 可以选 "Y". 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("NFS server support\nCONFIG_NFSD")]),t._v(" "),e("dd",[t._v("NFS 服务器端支持. 要实现此功能, 还需要 [nfs-utils](http://linux-nfs.org/) 软件包的支持. 详见 [nfs](http://linux.die.net/man/5/nfs) 手册页. 这里也有一个 [NFS 文章系列](http://blog.csdn.net/ycnian/article/category/1320297)可以看看. 此选项内嵌了 NFSv2 协议支持.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("NFS server support for NFS version 3\nCONFIG_NFSD_V3")]),t._v(" "),e("dd",[t._v("NFSv3(RFC 1813) 版本协议支持")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("NFS server support for the NFSv3 ACL protocol extension\nCONFIG_NFSD_V3_ACL")]),t._v(" "),e("dd",[t._v("为 NFSv3 添加 POSIX ACL 支持 (Solaris NFSv3 ACL). 此扩展并不属于 NFSv3 协议的官方内容.")])])]),t._v(" "),e("dt",[t._v("NFS server support for NFS version 4\nCONFIG_NFSD_V4")]),t._v(" "),e("dd",[t._v("NFSv4(RFC 3530) 版本协议支持")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("NFS server manual fault injection\nCONFIG_NFSD_FAULT_INJECTION")]),t._v(" "),e("dd",[t._v("仅供调试使用")])])])])]),t._v(" "),e("dt",[t._v("Secure RPC: Kerberos V mechanism\nCONFIG_RPCSEC_GSS_KRB5")]),t._v(" "),e("dd",[t._v("为使用 [Kerberos](http://zh.wikipedia.org/wiki/Kerberos) V5 GSS-API 身份验证机制 (RFC1964) 的[安全 RPC](http://docs.oracle.com/cd/E19253-01/819-7061/auth-2/index.html) 提供支持. 要实现此功能, 还需要 [nfs-utils](http://linux-nfs.org/) 软件包以及用户空间的 [Kerberos](http://zhumeng8337797.blog.163.com/blog/static/10076891420104410573960/) 支持.")]),t._v(" "),e("dt",[t._v("RPC: Enable dprintk debugging\nCONFIG_SUNRPC_DEBUG")]),t._v(" "),e("dd",[t._v('允许使用 rpcdebug 工具调试 RPC 故障, 如果选 "N" 会让故障调试特别困难.')]),t._v(" "),e("dt",[t._v("Ceph distributed file system\nCONFIG_CEPH_FS")]),t._v(" "),e("dd",[t._v('允许挂载 [Ceph](http://ceph.newdream.net/) 分布式文件系统. 不确定的选 "N". 详见 "[Documentation/filesystems/ceph.txt](https://www.kernel.org/doc/Documentation/filesystems/ceph.txt)" 文档.')]),t._v(" "),e("dt",[t._v("CIFS support (advanced network filesystem, SMBFS successor)\nCONFIG_CIFS")]),t._v(" "),e("dd",[t._v('[CIFS](http://baike.baidu.com/view/1034390.htm)(Common Internet File System) 协议客户端支持. CIFS 主要用于 Linux 与 Windows 之间共享文件系统. 如果你打算挂载 [Windows 的共享文件夹](http://www.microsoft.com/china/windowsxp/pro/using/itpro/managing/filesharing.mspx), 或者由 [Samba](http://linux.vbird.org/linux_server/0370samba.php) 提供的文件系统, 就选 "Y". 详见 "[Documentation/filesystems/cifs.txt](https://www.kernel.org/doc/Documentation/filesystems/cifs.txt)" 文档.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("CIFS statistics\nCONFIG_CIFS_STATS")]),t._v(" "),e("dd",[t._v("在 / proc/fs/cifs/Stats 文件中显示每个被挂载的 CIFS 文件系统的统计信息")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Extended statistics\nCONFIG_CIFS_STATS2")]),t._v(" "),e("dd",[t._v('在 / proc/fs/cifs / 目录下显示更详细的统计信息. 对运行性能和内存占用都有些影响. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("Support legacy servers which use weaker LANMAN security\nCONFIG_CIFS_WEAK_PW_HASH")]),t._v(" "),e("dd",[t._v('选 "N", 除非你确实知道自己在干什么.')]),t._v(" "),e("dt",[t._v("Kerberos/SPNEGO advanced session setup\nCONFIG_CIFS_UPCALL")]),t._v(" "),e("dd",[t._v('Kerberos/[SPNEGO](http://baike.baidu.com/view/5160766.htm) 高级会话支持. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("CIFS extended attributes\nCONFIG_CIFS_XATTR")]),t._v(" "),e("dd",[t._v('CIFS 文件系统[扩展属性](http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7) (与 inode 关联的 name:value 对) 支持. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("CIFS POSIX Extensions\nCONFIG_CIFS_POSIX")]),t._v(" "),e("dd",[t._v('CIFS POSIX 扩展. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Provide CIFS ACL support\nCONFIG_CIFS_ACL")]),t._v(" "),e("dd",[t._v('允许从服务器抓取 CIFS/NTFS ACL. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("Enable CIFS debugging routines\nCONFIG_CIFS_DEBUG")]),t._v(" "),e("dd",[t._v("仅供调试使用")]),t._v(" "),e("dt",[t._v("DFS feature support\nCONFIG_CIFS_DFS_UPCALL")]),t._v(" "),e("dd",[t._v('[DFS](http://technet.microsoft.com/library/Cc960860)(Distributed File System) 支持. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("SMB2 network file system support\nCONFIG_CIFS_SMB2")]),t._v(" "),e("dd",[t._v("仅供开发与调试使用")])])]),t._v(" "),e("dt",[t._v("Provide CIFS client caching support\nCONFIG_CIFS_FSCACHE")]),t._v(" "),e("dd",[t._v("为 CIFS 提供本地缓存支持, 也就是利用 CONFIG_FSCACHE 选项的功能.")]),t._v(" "),e("dt",[t._v("NCP file system support (to mount NetWare volumes)\nCONFIG_NCP_FS")]),t._v(" "),e("dd",[t._v('NCP(NetWare Core Protocol) 协议支持. 这东西早就销声匿迹了, 选 "N".')]),t._v(" "),e("dt",[t._v("Coda file system support (advanced network fs)\nCONFIG_CODA_FS")]),t._v(" "),e("dd",[t._v('[Coda](http://zh.wikipedia.org/wiki/Coda) 是一种比 NFS 更先进的分布式集群文件系统.[LVS](http://zh.linuxvirtualserver.org/)(Linux Virtual Server) 就采用了 [Coda 分布式文件系统](http://www.bsdmap.com/diary/coda.php). 详见 "[Documentation/filesystems/coda.txt](https://www.kernel.org/doc/Documentation/filesystems/coda.txt)" 文档.')]),t._v(" "),e("dt",[t._v("Andrew File System support\nCONFIG_AFS_FS")]),t._v(" "),e("dd",[t._v('[AFS](http://zh.wikipedia.org/wiki/%E5%AE%89%E5%BE%B7%E9%AD%AF%E6%AA%94%E6%A1%88%E7%B3%BB%E7%B5%B1)(Andrew File System) 文件系统的实验性支持, 目前仅支持只读访问. 详见 "[Documentation/filesystems/afs.txt](https://www.kernel.org/doc/Documentation/filesystems/afs.txt)" 文档.')]),t._v(" "),e("dt",[t._v("Provide AFS client caching support\nCONFIG_AFS_FSCACHE")]),t._v(" "),e("dd",[t._v("为 AFS 提供本地缓存支持, 也就是利用 CONFIG_FSCACHE 选项的功能.")]),t._v(" "),e("dt",[t._v("Plan 9 Resource Sharing Support (9P2000)\nCONFIG_9P_FS")]),t._v(" "),e("dd",[t._v('9P2000 协议是 [Plan 9](http://baike.baidu.com/view/1597745.htm) 概念网络操作系统上使用的资源共享协议. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("Native language support\nCONFIG_NLS")]),t._v(" "),e("dd",[t._v("本地语言支持. 仅在你使用 FAT/NTFS/JOLIET 文件系统的情况下才需要这个东西.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Default NLS Option\nCONFIG_NLS_DEFAULT")]),t._v(" "),e("dd",[t._v('挂载文件系统时, 控制台的默认本地语言 (不是文件系统用于存储文件名的语言), 建议设为 "utf8"(因为控制台的默认编码是 "utf8":vt.default_utf8=1).')]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{此处省略的各种字符集请按需选择}")])])]),t._v(" "),e("dt",[t._v("Distributed Lock Manager (DLM)\nCONFIG_DLM")]),t._v(" "),e("dd",[t._v("通用的分布式锁管理器 ([DLM](http://en.wikipedia.org/wiki/Distributed_lock_manager)). 用于为各种分布式文件系统提供通用的锁定支持. 集群强烈依赖于这个驱动.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("DLM debugging\nCONFIG_DLM_DEBUG")]),t._v(" "),e("dd",[t._v("仅供开发与调试使用")])])])]),t._v(" "),e("h2",{attrs:{id:"kernel-hacking"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#kernel-hacking"}},[t._v("#")]),t._v(" Kernel hacking")]),t._v(" "),e("p",[t._v("内核 hack 选项")]),t._v(" "),e("dl",[e("dt",[t._v("Show timing information on printks\nCONFIG_PRINTK_TIME")]),t._v(" "),e("dd",[t._v('在控制台和 syslog() 系统调用的输出中包含 printk() 消息的时间戳, 以便于直接显示内核启动过程中各步骤所用的时间. 注意: 无论此项是否开启, 时间戳总会被记录在 / dev/kmsg 中, 开启此项仅相当于使用 "printk.time=1" 内核引导参数.')]),t._v(" "),e("dt",[t._v("Default message log level (1-7)\nCONFIG_DEFAULT_MESSAGE_LOGLEVEL")]),t._v(" "),e("dd",[t._v("printk() 内核消息日志的默认级别, 取值范围是 [1,7]. 任何由 printk 显示的字符串通常记录在 / var/log/messages 文件里. 数值越大显示的消息就越详细: 1=ALERT,2=CRIT,3=ERR,4=WARNING,5=NOTICE,6=INFO,7=DEBUG.")]),t._v(" "),e("dt",[t._v("Enable __deprecated logic\nCONFIG_ENABLE_WARN_DEPRECATED")]),t._v(" "),e("dd",[t._v('编译时开启 "反对使用" 逻辑检查, 关闭此项将不会显示类似 "warning:\'foo\'is deprecated (declared at kernel/power/somefile.c:1234)" 这样的警告消息.')]),t._v(" "),e("dt",[t._v("Enable __must_check logic\nCONFIG_ENABLE_MUST_CHECK")]),t._v(" "),e("dd",[t._v('编译时开启 "必须检查" 逻辑检查, 关闭此项将不会显示类似 "warning: ignoring return value of\'foo\', declared with attribute warn_unused_result" 这样的警告消息.')]),t._v(" "),e("dt",[t._v("Warn for stack frames larger than (needs gcc 4.4)\nCONFIG_FRAME_WARN")]),t._v(" "),e("dd",[t._v('堆栈帧大小警告阈值, 设置过小会导致编译时警告太多, 设为 "0" 可以关闭警告, 需要 GCC-4.4 或更高版本')]),t._v(" "),e("dt",[t._v("Strip assembler-generated symbols during link\nCONFIG_STRIP_ASM_SYMS")]),t._v(" "),e("dd",[t._v("连接时剥离汇编器产生的内部符号 (类似'.Lxxx'), 这样可以净化 get_wchan() 之类的输出, 同时还可以减小内核尺寸. 建议开启.")]),t._v(" "),e("dt",[t._v("Magic SysRq key\nCONFIG_MAGIC_SYSRQ")]),t._v(" "),e("dd",[t._v('开启 " [魔法键](http://www.docin.com/p-188851857.html) "([SysRq](http://www.ibm.com/developerworks/cn/linux/l-cn-sysrq/), 允许用户按下 Alt+PrintScreen 后发送给内核特殊的命令) 支持 (可以通过 "echo 0> /proc/sys/kernel/sysrq" 关闭). 由于 SysRq 会带来安全隐患 (允许未经登录的操作), 所以你应该仅在确实需要的场合开启. 更多详情参见 "[Documentation/sysrq.txt](https://www.kernel.org/doc/Documentation/sysrq.txt)" 文档')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable magic SysRq key functions by default\nCONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE")]),t._v(" "),e("dd",[t._v('设置默认开启哪些魔法键. 设为 "1" 表示开启所有魔法键, 设为 "0" 表示禁用所有魔法键. 或者按照 "[Documentation/sysrq.txt](https://www.kernel.org/doc/Documentation/sysrq.txt)" 文档的指引设置特定的码位.')])])]),t._v(" "),e("dt",[t._v("Generate readable assembler code\nCONFIG_READABLE_ASM")]),t._v(" "),e("dd",[t._v("生成人类易读的汇编输出, 以方便内核调试. 这会禁用一些编译优化措施, 也会降低内核的运行速度.")]),t._v(" "),e("dt",[t._v("Enable unused/obsolete exported symbols\nCONFIG_UNUSED_SYMBOLS")]),t._v(" "),e("dd",[t._v("导出无用和废弃的符号, 这将使内核不必要的增大. 建议关闭.")]),t._v(" "),e("dt",[t._v("Debug Filesystem\nCONFIG_DEBUG_FS")]),t._v(" "),e("dd",[t._v("debugfs 是内核开发者用来存储调试信息的虚拟文件系统. 不搞内核开发就别选")]),t._v(" "),e("dt",[t._v("Run 'make headers_check' when building vmlinux\nCONFIG_HEADERS_CHECK")]),t._v(" "),e("dd",[t._v("在编译内核时运行'make headers_check'命令检查内核头文件的正确性, 当你修改了与用户空间相关的内核头文件后应该启用该选项")]),t._v(" "),e("dt",[t._v("Enable full Section mismatch analysis\nCONFIG_DEBUG_SECTION_MISMATCH")]),t._v(" "),e("dd",[t._v("在编译时检查无效的引用. 仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Make section mismatch errors non-fatal\nCONFIG_SECTION_MISMATCH_WARN_ONLY")]),t._v(" "),e("dd",[t._v('若选 "N", 那么一旦出现 "section mismatch", 将会直接导致编译失败 (而不是仅仅抛出警告). 建议选 "N".')]),t._v(" "),e("dt",[t._v("Kernel debugging\nCONFIG_DEBUG_KERNEL")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用.[提示] 如果你开启了 CONFIG_EXPERT, 此项会被强制选中, 如果这不是你想要的, 可以到内核源码树的根目录下使用 \"sed -i'/select DEBUG_KERNEL/d'usr/src/linux/init/Kconfig\" 命令去掉这个依赖.")]),t._v(" "),e("dt",[t._v("Panic on Oops\nCONFIG_PANIC_ON_OOPS")]),t._v(" "),e("dd",[t._v('当内核 [oops](http://www.cnblogs.com/wwang/archive/2010/11/14/1876735.html) 时, 直接 [panic](http://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8%E9%94%99%E8%AF%AF) 掉 (相当于 Windows 蓝屏死机), 这样可以确保内核停止工作, 避免导致无法预料的后果. 等价于使用 "oops=panic" 内核引导参数. 不确定的选 "Y".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("panic timeout\nCONFIG_PANIC_TIMEOUT")]),t._v(" "),e("dd",[t._v('如何处理内核崩溃 (panic):(1) 若设为 "0" 则表示无限等待, 不做任何处理;(2)若设为正整数则表示等待设定的秒数之后重启;(3)若设为负整数则表示立即重启.')])])]),t._v(" "),e("dt",[t._v("Enable extra timekeeping sanity checking\nCONFIG_DEBUG_TIMEKEEPING")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Detect Hung Tasks\nCONFIG_DETECT_HUNG_TASK")]),t._v(" "),e("dd",[t._v('探测挂起的任务 (进程被锁住或者冻结了, 处于不可中断的 "D" 状态). 由于仅能检测, 不能做进一步的处理, 所以仅用于帮助内核调试.')]),t._v(" "),e("dt",[t._v("Collect scheduler debugging info\nCONFIG_SCHED_DEBUG")]),t._v(" "),e("dd",[t._v('提供一个 "/proc/sched_debug" 文件以帮助调试调度程序. 仅供内核开发以及调试调度程序使用.')]),t._v(" "),e("dt",[t._v("Collect scheduler statistics\nCONFIG_SCHEDSTATS")]),t._v(" "),e("dd",[t._v('收集调度程序的统计信息, 并展示在 "/proc/schedstat" 文件中. 可以用于调试调度程序, 或者调整特定的应用程序. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Collect kernel timers statistics\nCONFIG_TIMER_STATS")]),t._v(" "),e("dd",[t._v('收集内核计时器的统计信息, 并展示在 "/proc/timer_stats" 文件中. 使用 "echo 1 > /proc/timer_stats" 开启统计, 使用 "echo 0 > /proc/timer_stats" 关闭统计. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Debug object operations\nCONFIG_DEBUG_OBJECTS")]),t._v(" "),e("dd",[t._v("跟踪各种对象的生命周期 (life time), 并校验对这些对象的各种操作. 仅供内核调试.")]),t._v(" "),e("dt",[t._v("Debug slab memory allocations\nCONFIG_DEBUG_SLAB")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("SLUB debugging on by default\nCONFIG_SLUB_DEBUG_ON")]),t._v(" "),e("dd",[t._v("默认开启 SLUB 内存分配器调试功能. 仅供调试, 切勿用于生产环境.")]),t._v(" "),e("dt",[t._v("Enable SLUB performance statistics\nCONFIG_SLUB_STATS")]),t._v(" "),e("dd",[t._v("收集 SLUB 内存分配器的性能统计信息. 仅供调试, 切勿用于生产环境.")]),t._v(" "),e("dt",[t._v("Kernel memory leak detector\nCONFIG_DEBUG_KMEMLEAK")]),t._v(" "),e("dd",[t._v("内核内存泄漏检测. 仅供内核调试.")]),t._v(" "),e("dt",[t._v("Debug preemptible kernel\nCONFIG_DEBUG_PREEMPT")]),t._v(" "),e("dd",[t._v("对内核的主动抢占特性进行调试. 仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("RT Mutex debugging, deadlock detection\nCONFIG_DEBUG_RT_MUTEXES")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Built-in scriptable tester for rt-mutexes\nCONFIG_RT_MUTEX_TESTER")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Spinlock and rw-lock debugging: basic checks\nCONFIG_DEBUG_SPINLOCK")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Mutex debugging: basic checks\nCONFIG_DEBUG_MUTEXES")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Lock debugging: detect incorrect freeing of live locks\nCONFIG_DEBUG_LOCK_ALLOC")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Lock debugging: prove locking correctness\nCONFIG_PROVE_LOCKING")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Lock usage statistics\nCONFIG_LOCK_STAT")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Lock dependency engine debugging\nCONFIG_DEBUG_LOCKDEP")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Sleep inside atomic section checking\nCONFIG_DEBUG_ATOMIC_SLEEP")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Locking API boot-time self-tests\nCONFIG_DEBUG_LOCKING_API_SELFTESTS")]),t._v(" "),e("dd",[t._v("在内核启动时运行一个简短的加锁 / 解锁函数 (spinlocks,rwlocks,mutexes,rwsems) 自我测试. 仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Stack utilization instrumentation\nCONFIG_DEBUG_STACK_USAGE")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("kobject debugging\nCONFIG_DEBUG_KOBJECT")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Verbose BUG() reporting (adds 70K)\nCONFIG_DEBUG_BUGVERBOSE")]),t._v(" "),e("dd",[t._v("在内核 panic 时让 BUG() 函数报告更详细的信息. 内核将会增大 70-100K.")]),t._v(" "),e("dt",[t._v("Compile the kernel with debug info\nCONFIG_DEBUG_INFO")]),t._v(" "),e("dd",[t._v("以调试方式编译内核 (gcc -g). 仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Debug VM\nCONFIG_DEBUG_VM")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Debug VM translations\nCONFIG_DEBUG_VIRTUAL")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Debug filesystem writers count\nCONFIG_DEBUG_WRITECOUNT")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Debug memory initialisation\nCONFIG_DEBUG_MEMORY_INIT")]),t._v(" "),e("dd",[t._v('在内存初始化时增加额外的合理性检查. 不确定的选 "Y".')]),t._v(" "),e("dt",[t._v("Debug linked list manipulation\nCONFIG_DEBUG_LIST")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Linked list sorting test\nCONFIG_TEST_LIST_SORT")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Debug SG table operations\nCONFIG_DEBUG_SG")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Debug notifier call chains\nCONFIG_DEBUG_NOTIFIERS")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Debug credential management\nCONFIG_DEBUG_CREDENTIALS")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Compile the kernel with frame pointers\nCONFIG_FRAME_POINTER")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Delay each boot printk message by N milliseconds\nCONFIG_BOOT_PRINTK_DELAY")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Stack backtrace support\nCONFIG_STACKTRACE")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用.")]),t._v(" "),e("dt",[t._v("RCU Debugging")]),t._v(" "),e("dd",[t._v('仅供内核开发者使用. 建议所有子项全选 "N".')]),t._v(" "),e("dt",[t._v("Kprobes sanity tests\nCONFIG_KPROBES_SANITY_TEST")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Self test for the backtrace code\nCONFIG_BACKTRACE_SELF_TEST")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Force extended block device numbers and spread them\nCONFIG_DEBUG_BLOCK_EXT_DEVT")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Force weak per-cpu definitions\nCONFIG_DEBUG_FORCE_WEAK_PER_CPU")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Debug access to per_cpu maps\nCONFIG_DEBUG_PER_CPU_MAPS")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Linux Kernel Dump Test Tool Module\nCONFIG_LKDTM")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Notifier error injection\nCONFIG_NOTIFIER_ERROR_INJECTION")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Fault-injection framework\nCONFIG_FAULT_INJECTION")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Latency measuring infrastructure\nCONFIG_LATENCYTOP")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Strict user copy size checks\nCONFIG_DEBUG_STRICT_USER_COPY_CHECKS")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Debug page memory allocations\nCONFIG_DEBUG_PAGEALLOC")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Tracers\nCONFIG_FTRACE")]),t._v(" "),e("dd",[t._v('仅供内核开发者使用. 建议选 "N".')]),t._v(" "),e("dt",[t._v("Runtime Testing")]),t._v(" "),e("dd",[t._v('运行时自我检查. 建议子项全选 "N".')]),t._v(" "),e("dt",[t._v("Red-Black tree test\nCONFIG_RBTREE_TEST")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Interval tree test\nCONFIG_INTERVAL_TREE_TEST")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Remote debugging over FireWire early on boot\nCONFIG_PROVIDE_OHCI1394_DMA_INIT")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Remote debugging over FireWire with firewire-ohci\nCONFIG_FIREWIRE_OHCI_REMOTE_DMA")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Build targets in Documentation/ tree\nCONFIG_BUILD_DOCSRC")]),t._v(" "),e("dd",[t._v('编译内核源码树下 "Documentation" 目录中的目标. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Enable dynamic printk() support\nCONFIG_DYNAMIC_DEBUG")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Enable debugging of DMA-API usage\nCONFIG_DMA_API_DEBUG")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Perform an atomic64_t self-test at boot\nCONFIG_ATOMIC64_SELFTEST")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Self test for hardware accelerated raid6 recovery\nCONFIG_ASYNC_RAID6_TEST")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Sample kernel code\nCONFIG_SAMPLES")]),t._v(" "),e("dd",[t._v("内核示例代码. 仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("KGDB: kernel debugger\nCONFIG_KGDB")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("kmemcheck: trap use of uninitialized memory\nCONFIG_KMEMCHECK")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Test functions located in the string_helpers module at runtime\nCONFIG_TEST_STRING_HELPERS")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Test kstrto*() family of functions at runtime\nCONFIG_TEST_KSTRTOX")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Filter access to /dev/mem\nCONFIG_STRICT_DEVMEM")]),t._v(" "),e("dd",[t._v('如果选 "N", 那么用户空间的 root 用户将可以通过 [/dev/mem](http://blog.csdn.net/skyflying2012/article/details/47611399) 访问所有内存空间 (包括用户空间与内核空间), 以方便调试内核. 如果选 "Y", 那么内核空间除了 PCI 和 BIOS 部分以及数据区之外, 都禁止访问, 以保护系统安全. 不确定的选 "Y".')]),t._v(" "),e("dt",[t._v("Enable verbose x86 bootup info messages\nCONFIG_X86_VERBOSE_BOOTUP")]),t._v(" "),e("dd",[t._v('在启动时显示额外 bzimage 解压消息, 显示详细的内核引导信息. 建议选 "N" 使引导过程更安静 (依然会显示错误信息).')]),t._v(" "),e("dt",[t._v("Early printk\nCONFIG_EARLY_PRINTK")]),t._v(" "),e("dd",[t._v("将内核日志直接输出到 VGA 缓冲或串口. 这有助于调试那些在控制台尚未完成初始化之前就造成系统崩溃的 bug.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Early printk via EHCI debug port\nCONFIG_EARLY_PRINTK_DBGP")]),t._v(" "),e("dd",[t._v('支持将内核日志直接通过 EHCI 调试端口输出. 选 "N", 除非你想调试内核.')])])]),t._v(" "),e("dt",[t._v("Dump the EFI pagetable\nCONFIG_EFI_PGT_DUMP")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Check for stack overflows\nCONFIG_DEBUG_STACKOVERFLOW")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Export kernel pagetable layout to userspace via debugfs\nCONFIG_X86_PTDUMP")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Write protect kernel read-only data structures\nCONFIG_DEBUG_RODATA")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Set loadable kernel module data as NX and text as RO\nCONFIG_DEBUG_SET_MODULE_RONX")]),t._v(" "),e("dd",[t._v('将内核模块的数据区标记为 NX(不可执行), 文本段标记为 RO(只读), 以防止不良模块 (例如被植入病毒的模块) 对系统的破坏, 也能预防某些类型的内核入侵. 这需要 CPU 支持 [NX 位](http://zh.wikipedia.org/wiki/NX%E4%BD%8D%E5%85%83) (CPU flags 中要含有 "nx" 标志). 但是这也有副作用: 会与运行时代码补丁冲突, 还会导致动态内核跟踪失效. 建议选 "Y", 除非你需要调试内核, 或者需要为运行中的模块打补丁.')]),t._v(" "),e("dt",[t._v("Testcase for the NX non-executable stack feature\nCONFIG_DEBUG_NX_TEST")]),t._v(" "),e("dd",[t._v("对处理器的 NX 的测试用例. 仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Set upper limit of TLB entries to flush one-by-one\nCONFIG_DEBUG_TLBFLUSH")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Enable doublefault exception handler\nCONFIG_DOUBLEFAULT")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Enable IOMMU debugging\nCONFIG_IOMMU_DEBUG")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Enable IOMMU stress-test mode\nCONFIG_IOMMU_STRESS")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("IOMMU leak tracing\nCONFIG_IOMMU_LEAK")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("x86 instruction decoder selftest\nCONFIG_X86_DECODER_SELFTEST")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("IO delay type")]),t._v(" "),e("dd",[t._v("IO 延迟方式")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("port 0x80 based port-IO delay\nCONFIG_IO_DELAY_0X80")]),t._v(" "),e("dd",[t._v("传统的 Linux IO 延迟方式, 久经考验, 也是最安全的默认值.")]),t._v(" "),e("dt",[t._v("port 0xed based port-IO delay\nCONFIG_IO_DELAY_0XED")]),t._v(" "),e("dd",[t._v("基于 0xed 端口的 IO 延迟方式, 主要是为了避免和基于 0x80 端口的[主板诊断卡](http://baike.baidu.com/view/288235.htm)冲突. 绝大多数人都没有主板诊断卡, 除非那些专门维修主板的硬件工程师.")]),t._v(" "),e("dt",[t._v("udelay based port-IO delay\nCONFIG_IO_DELAY_UDELAY")]),t._v(" "),e("dd",[t._v("使用内核端 udelay() 函数作为延迟方法 (简单的延迟 2 微秒). 可以不占用任何 IO 端口空间.")]),t._v(" "),e("dt",[t._v("no port-IO delay\nCONFIG_IO_DELAY_NONE")]),t._v(" "),e("dd",[t._v("不使用任何 port-IO 延迟机制. 只要你的机器不是老古董, 建议选择此项.")])])]),t._v(" "),e("dt",[t._v("Debug boot parameters\nCONFIG_DEBUG_BOOT_PARAMS")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("CPA self-test code\nCONFIG_CPA_DEBUG")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("Allow gcc to uninline functions marked 'inline'\nCONFIG_OPTIMIZE_INLINING")]),t._v(" "),e("dd",[t._v('允许 GCC 将标记为内联 (inline) 的函数变成非内联(uninline). 选 "Y" 后将完全无视代码中的 "inline" 标记, 完全由 GCC 自行决定是否应该将函数内联. 由于 GCC4.x 系列更新了判断函数是否应该内联的算法, 选 "Y" 后, 编译出的内核体积会减小(但运行速度未必提升). 建议选 "Y".')]),t._v(" "),e("dt",[t._v("NMI Selftest\nCONFIG_DEBUG_NMI_SELFTEST")]),t._v(" "),e("dd",[t._v("对不可屏蔽中断 (Non Maskable Interrupt) 进行自检, 仅供内核开发者使用")]),t._v(" "),e("dt",[t._v("ATOM Punit debug driver\nCONFIG_PUNIT_ATOM_DEBUG")]),t._v(" "),e("dd",[t._v("仅供内核开发者使用")])]),t._v(" "),e("h2",{attrs:{id:"security-options"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#security-options"}},[t._v("#")]),t._v(" Security options")]),t._v(" "),e("p",[t._v("安全选项\n这里的选项不明白的建议不要选, 否则有可能弄巧成拙.")]),t._v(" "),e("dl",[e("dt",[t._v("Enable access key retention support\nCONFIG_KEYS")]),t._v(" "),e("dd",[t._v('在内核中保留认证令牌 ([authentication token](http://en.wikipedia.org/wiki/Security_token))和访问密钥 (access key).eCryptfs(CONFIG_ECRYPT_FS) 与 Docker 依赖于它. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("TRUSTED KEYS\nCONFIG_TRUSTED_KEYS")]),t._v(" "),e("dd",[t._v('"TRUSTED KEY" 的意思是由 [TPM](http://security.ctocio.com.cn/wpsummary/141/8692641.shtml)([可信赖平台模块](http://baike.baidu.com/view/1130324.htm)) 用 [RSA 算法](http://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95)封装的一对随机数. 开启此项后, 内核将可以为创建 / 封装 / 解封 "TRUSTED KEY" 提供支持. 如果引导 PCR(平台配置寄存器) 和各种条件都匹配, 那么 TPM 只解封密钥. 用户空间永远只能看到加密过后的二进制内容. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("ENCRYPTED KEYS\nCONFIG_ENCRYPTED_KEYS")]),t._v(" "),e("dd",[t._v('"ENCRYPTED KEY" 的意思是由内核封装的一对随机数, 该对随机数可以用一个 "主密钥" 使用对称加密算法进行加密和解密. 开启此项后, 内核将可以为创建 / 加密 / 解密 "ENCRYPTED KEY" 提供支持."主密钥" 既可以是 "TRUSTED KEY" 也可以是 "user-key"(用户选择的密钥). 用户空间永远只能看到 / 存储加密过后的二进制内容. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Enable the /proc/keys file by which keys may be viewed\nCONFIG_KEYS_DEBUG_PROC_KEYS")]),t._v(" "),e("dd",[t._v('开启 "/proc/keys" 文件支持, 该文件中保存了系统上所有可见的密钥. 注意,[LSM](http://www.ibm.com/developerworks/cn/linux/l-lsm/part1/)(Linux 安全模块) 安全检查仍然是必须的. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("Restrict unprivileged access to the kernel syslog\nCONFIG_SECURITY_DMESG_RESTRICT")]),t._v(" "),e("dd",[t._v('禁止非特权用户访问内核日志 ([dmesg](http://baike.baidu.com/view/712946.htm)), 相当于 "echo 1 > /proc/sys/kernel/dmesg_restrict". 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Enable different security models\nCONFIG_SECURITY")]),t._v(" "),e("dd",[t._v('允许内核选择不同的 [LSM](http://www.ibm.com/developerworks/cn/linux/l-lsm/part1/)([Linux 安全模块](https://linux.cn/article-2198-1.html)), 如果未选中则内核将使用默认的安全模块 ("Default security module"). 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Enable the securityfs filesystem\nCONFIG_SECURITYFS")]),t._v(" "),e("dd",[t._v('securityfs 安全文件系统支持. 当前仅被 TPM bios 字符设备驱动以及 IMA(完整性提供者) 使用. 它与 SELinux 或 SMACK 之类没有关系. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Socket and Networking Security Hooks\nCONFIG_SECURITY_NETWORK")]),t._v(" "),e("dd",[t._v('允许安全模块通过 Security Hook 对 Socket 与 Networking 进行访问控制. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("XFRM (IPSec) Networking Security Hooks\nCONFIG_SECURITY_NETWORK_XFRM")]),t._v(" "),e("dd",[t._v('为 XFRM(IPSec) 启用安全 Hook. 这样安全模块可以通过这些 hook, 根据 IPSec 策略标签, 实现针对每个网络包的访问控制. 非 IPSec 通信则被当做 "无标签" 处理, 仅允许那些被明确批准可以不使用策略标签的 socket 才能不通过 IPSec 进行通信. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("Security hooks for pathname based access control\nCONFIG_SECURITY_PATH")]),t._v(" "),e("dd",[t._v('此安全钩子程序可以让各种安全模块实现基于路径的访问控制. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Enable Intel(R) Trusted Execution Technology (Intel(R) TXT)\nCONFIG_INTEL_TXT")]),t._v(" "),e("dd",[t._v('支持使用[可信引导](http://blog.csdn.net/trustbo/article/details/9292011) ([Trusted Boot](http://wenku.baidu.com/view/8bccb8335a8102d276a22faf.html)) 技术引导内核 (需要使用 [tboot](http://tboot.sourceforge.net) 模块). 这将使用英特尔 [TXT](http://baike.baidu.com/view/4060870.htm)([可信任执行技术](http://baike.baidu.com/view/1553859.htm)) 来引导内核. 在不支持 [TXT](http://www.intel.com/content/www/us/en/architecture-and-technology/trusted-execution-technology/malware-reduction-general-technology.html) 的平台上开启此项没有效果. 详见 "[Documentation/intel_txt.txt](https://www.kernel.org/doc/Documentation/intel_txt.txt)"文档. 不确定的选"N".')]),t._v(" "),e("dt",[t._v("Low address space for LSM to protect from user allocation\nCONFIG_LSM_MMAP_MIN_ADDR")]),t._v(" "),e("dd",[t._v('禁止用户空间分配的低位内存范围. 禁止用户写入低位内存有助于降低内核 NULL 指针漏洞造成的破坏 (参见 CONFIG_DEFAULT_MMAP_MIN_ADDR 选项). 建议保持默认值 "65536".')]),t._v(" "),e("dt",[t._v("NSA SELinux Support\nCONFIG_SECURITY_SELINUX")]),t._v(" "),e("dd",[t._v('[SELinux](http://www.ibm.com/developerworks/cn/linux/l-secure-linux-ru/index.html)(安全增强 Linux)是美国国家安全局 (NSA) 开发的 [Linux 安全模块](http://www.ibm.com/developerworks/cn/linux/l-lsm/part1/index.html), 它拥有一个灵活而强制性的访问控制结构, 可防御未知攻击, 相当于 B1 级的军事安全性能 (比微软所谓的 C2 等高得多). 应用 SELinux 后, 可以减轻恶意攻击或恶意软件带来的灾难, 对机密性和完整性有很高要求的信息, 亦可提供很高的安全保障. 但另一方面, 如果不深入[了解 SELinux 知识](http://www.ibm.com/developerworks/cn/views/linux/libraryview.jsp?site_id=10&contentarea_by=Linux&sort_by=Date&sort_order=2&topic_by=-1&type_by=所有类别&show_abstract=true&search_by=SELinux)而盲目使用, 则会弄巧成拙. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("NSA SELinux boot parameter\nCONFIG_SECURITY_SELINUX_BOOTPARAM")]),t._v(" "),e("dd",[t._v("添加 \"selinux\" 内核引导参数. 以允许在引导时使用'selinux=0'禁用 SELinux 或'selinux=1'启用 SELinux.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("NSA SELinux boot parameter default value\nCONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE")]),t._v(" "),e("dd",[t._v('"selinux" 内核引导参数的默认值.')])])]),t._v(" "),e("dt",[t._v("NSA SELinux runtime disable\nCONFIG_SECURITY_SELINUX_DISABLE")]),t._v(" "),e("dd",[t._v('允许在运行时禁用 SELinux. 建议选 "N".')]),t._v(" "),e("dt",[t._v("NSA SELinux Development Support\nCONFIG_SECURITY_SELINUX_DEVELOP")]),t._v(" "),e("dd",[t._v('SELinux 开发支持. 开启此项后, 除非明确使用 "enforcing=1" 引导参数让内核以 "强制模式" 运行, 否则内核将以 "许可模式" 运行 (记录所有事件, 同时允许所有操作). 主要用于测试 SELinux 以及策略开发. 此外, 开启此项后, 还可以在运行时通过 "/selinux/enforce" 让内核在 "强制模式" 与 "许可模式" 之间切换.')]),t._v(" "),e("dt",[t._v("NSA SELinux AVC Statistics\nCONFIG_SECURITY_SELINUX_AVC_STATS")]),t._v(" "),e("dd",[t._v("搜集访问向量缓存 (access vector cache) 的统计信息并在 / selinux/avc/cache_stats 中显示出来. 这些信息可以用 avcstat 之类的工具查看.")]),t._v(" "),e("dt",[t._v("NSA SELinux checkreqprot default value\nCONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE")]),t._v(" "),e("dd",[t._v('内核引导参数 "checkreqprot" 的默认值. 设为 "0" 表示默认检查内核要求执行的保护策略, 设为 "1" 表示默认检查应用程序要求执行的保护策略. 此值还可以在运行时通过 / selinux/checkreqprot 修改. 不确定的选 "1".')]),t._v(" "),e("dt",[t._v("NSA SELinux maximum supported policy format version\nCONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX")]),t._v(" "),e("dd",[t._v('将支持的策略格式的最高版本设置为一个特定的数值. 该数值将通过 / selinux/policyvers 向用户空间报告, 并在加载策略时被使用. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("NSA SELinux maximum supported policy format version value\n")]),t._v(" "),e("dd",[t._v('支持策略格式的最高版本的数值. 可以通过 "checkpolicy -V" 命令检查当前工具链支持的版本数值.')])])])])]),t._v(" "),e("dt",[t._v("Simplified Mandatory Access Control Kernel Support\nCONFIG_SECURITY_SMACK")]),t._v(" "),e("dd",[t._v('[Smack](http://en.wikipedia.org/wiki/Smack)(简化的强制访问控制内核) [内核安全模块](http://zh.wikipedia.org/wiki/Linux%E5%AE%89%E5%85%A8%E6%A8%A1%E7%B5%84).[Smack](http://blog.csdn.net/wangzhicheng1983/article/details/9221359) 是一种简单而有效的强制访问控制机制, 它的简单体现在安全策略的配置很简单, 它的有效体现在完全使用 LSM 作为其控制手段. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("TOMOYO Linux Support\nCONFIG_SECURITY_TOMOYO")]),t._v(" "),e("dd",[t._v('[TOMOYO Linux](http://en.wikipedia.org/wiki/TOMOYO_Linux) 是日本 NTT 数据公司开发的一种 Linux 安全模块. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("AppArmor support\nCONFIG_SECURITY_APPARMOR")]),t._v(" "),e("dd",[t._v('[AppArmor](http://blog.csdn.net/ustc_dylan/article/details/7944955)(应用盔甲) 是来自 Novell 的一种 Linux 安全模块. AppArmor 使用文件路径来跟踪程序限制, 是最容易配置的安全模块. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Yama support\nCONFIG_SECURITY_YAMA")]),t._v(" "),e("dd",[t._v('Yama(阎王) 是 3.4 版内核新引入的一种 Linux 安全模块. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Digital signature verification using multiple keyrings\nCONFIG_INTEGRITY_SIGNATURE")]),t._v(" "),e("dd",[t._v('允许使用多个[密钥环](http://book.51cto.com/art/200902/108112.htm) (keyring)进行数字签名验证, 也就允许为多个不同的使用场合 (evm,ima,module) 分别使用不同的 keyring. 看不懂的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable asymmetric keys support\nCONFIG_INTEGRITY_ASYMMETRIC_KEYS")]),t._v(" "),e("dd",[t._v("允许使用非对称密钥进行数字签名验证.")])])]),t._v(" "),e("dt",[t._v("Integrity Measurement Architecture(IMA)\nCONFIG_IMA")]),t._v(" "),e("dd",[t._v('[IMA](http://wiki.gentoo.org/wiki/Integrity_Measurement_Architecture)(完整性度量架构) 是一个在 [TCG](http://www.trustedcomputinggroup.org/cn)([可信计算](http://zh.wikipedia.org/wiki/%E5%8F%AF%E4%BF%A1%E8%AE%A1%E7%AE%97)工作组) 技术规范之上提出的完整性检查技术. IMA 维护着一个系统关键文件的哈希值列表, 从而可以检测这些关键文件是否被篡改. 如果系统上有 [TPM 安全芯片](http://baike.baidu.com/view/687208.htm), 那么 IMA 还会在 TPM 芯片内存储哈希值的集合. 这样的 TPM 芯片可以提供给第三方, 用于检查系统上的关键文件是否被篡改. 不确定的选 "N".')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enables auditing support\nCONFIG_IMA_AUDIT")]),t._v(" "),e("dd",[t._v('添加 "ima_audit" 内核引导参数支持. 当设为 "ima_audit=1" 时, 将允许显示完整性审计信息.')]),t._v(" "),e("dt",[t._v("Appraise integrity measurements\nCONFIG_IMA_APPRAISE")]),t._v(" "),e("dd",[t._v('本地完整性鉴定支持. 这样就可以在加载文件时检验它的完整性. 这要求系统配置 [EVM](http://wiki.gentoo.org/wiki/Using_Extended_Verification_Module_in_Gentoo) 支持. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("EVM support\nCONFIG_EVM")]),t._v(" "),e("dd",[t._v("[EVM](https://wiki.gentoo.org/wiki/Extended_Verification_Module) 通过保护文件的安全扩展属性来对抗完整性攻击.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("EVM HMAC version\nCONFIG_EVM_HMAC_VERSION")]),t._v(" "),e("dd",[t._v('支持的 EVM HMAC 版本:"1" 表示原始版本, 默认值 "2" 表示添加了文件系统 [UUID](http://zh.wikipedia.org/wiki/UUID) 支持的改进版本.')])])]),t._v(" "),e("dt",[t._v("Default security module")]),t._v(" "),e("dd",[t._v('内核默认的安全模块.[提示]"Unix Discretionary Access Controls" 是经典的 UNIX 基于目录的访问控制安全模型. 如果没有开启任何安全模块, 这将是默认值.')])]),t._v(" "),e("h2",{attrs:{id:"cryptographic-api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cryptographic-api"}},[t._v("#")]),t._v(" Cryptographic API")]),t._v(" "),e("p",[t._v("内核加密 API 支持\n这里的加密算法被广泛的应用于驱动程序通信协议等机制中. 子选项可以全不选, 内核中若有其他部分依赖它, 会自动选上. 使用内核树外的模块时可能需要手动选择.")]),t._v(" "),e("dl",[e("dt",[t._v("FIPS 200 compliance\nCONFIG_CRYPTO_FIPS")]),t._v(" "),e("dd",[t._v('"fips" 内核引导参数支持. 这是在 [FIPS200](http://book.2cto.com/201209/4003.html) 认证的系统中运行所必须的. 选 "N", 除非你确实知道自己在做什么.')]),t._v(" "),e("dt",[t._v("RSA algorithm\nCONFIG_CRYPTO_RSA")]),t._v(" "),e("dd",[t._v('"[RSA](http://baike.baidu.com/view/10613.htm)" 公钥加密算法. 能同时用于密钥交换和数字签名.')]),t._v(" "),e("dt",[t._v("Cryptographic algorithm manager\nCONFIG_CRYPTO_MANAGER")]),t._v(" "),e("dd",[t._v("创建默认的加密模版实例, 提供了操作内核的加密特性所需的软件.")]),t._v(" "),e("dt",[t._v("Userspace cryptographic algorithm configuration\nCONFIG_CRYPTO_USER")]),t._v(" "),e("dd",[t._v('允许用户空间配置内核加密实例. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Disable run-time self tests\nCONFIG_CRYPTO_MANAGER_DISABLE_TESTS")]),t._v(" "),e("dd",[t._v('禁止在注册算法时进行简单的自我检测. 不确定的选 "Y".')]),t._v(" "),e("dt",[t._v("GF(2^128) multiplication functions\nCONFIG_CRYPTO_GF128MUL")]),t._v(" "),e("dd",[t._v('由高效表格驱动的[伽罗瓦域 GF(2^128) 乘法器](http://wenku.baidu.com/view/503a96fa770bf78a65295425.html)支持. 某些加密模式需要它. 不确定的选 "N". 如果有其它模块需要此特性, 会被自动选中.')]),t._v(" "),e("dt",[t._v("Null algorithms\nCONFIG_CRYPTO_NULL")]),t._v(" "),e("dd",[t._v("NULL 加密算法 (什么也不做), 用于 IPsec 协议的封装安全载荷模块 (ESP)")]),t._v(" "),e("dt",[t._v("Parallel crypto engine\nCONFIG_CRYPTO_PCRYPT")]),t._v(" "),e("dd",[t._v("将任意加密算法转化成并行算法, 并在内核线程中执行.")]),t._v(" "),e("dt",[t._v("Software async crypto daemon\nCONFIG_CRYPTO_CRYPTD")]),t._v(" "),e("dd",[t._v("这是一个通用的软件异步加密守护进程, 可将任意的同步软件加密算法转换成在内核线程中执行的异步算法.")]),t._v(" "),e("dt",[t._v("Software async multi-buffer crypto daemon\nCONFIG_CRYPTO_MCRYPTD")]),t._v(" "),e("dd",[t._v("这是一个通用的软件异步加密守护进程, 可将任意的多缓冲加密算法转换成在内核线程中执行的异步多缓冲加密算法.")]),t._v(" "),e("dt",[t._v("Authenc support\nCONFIG_CRYPTO_AUTHENC")]),t._v(" "),e("dd",[t._v("用于 IPSec 组合模式的包装器: 认证加密并对 IPSec 提供多重加密.")]),t._v(" "),e("dt",[t._v("Testing module\nCONFIG_CRYPTO_TEST")]),t._v(" "),e("dd",[t._v("丑陋的加密测试模块. 仅供调试使用.")]),t._v(" "),e("dt",[t._v("CCM support\nCONFIG_CRYPTO_CCM")]),t._v(" "),e("dd",[t._v("[CBC-MAC](http://baike.baidu.com/view/3169861.htm) 计数器. IPsec 需要它.")]),t._v(" "),e("dt",[t._v("GCM/GMAC support\nCONFIG_CRYPTO_GCM")]),t._v(" "),e("dd",[t._v("GCM([Galois/Counter Mode](http://en.wikipedia.org/wiki/Galois/Counter_Mode)) 与 GMAC(Galois Message Authentication Code) 支持. IPsec 需要它.[注释]GCM 是一种对称加密算法的块密码工作模式, 使用 128 位块大小. [块密码工作模式](http://zh.wikipedia.org/wiki/%E5%9D%97%E5%AF%86%E7%A0%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F)可以分为加密模式, 认证模式, 认证加密模式. GCM 模式为认证模式的一种, 提供认证和加密两种功能.")]),t._v(" "),e("dt",[t._v("Sequence Number IV Generator\nCONFIG_CRYPTO_SEQIV")]),t._v(" "),e("dd",[t._v("序号初始向量 (IV) 生成器. 它基于一个序号与一个盐粒子 (salt) 的异或值生成一个向量. 此算法主要用于块密码的 CTR(计数模式).")]),t._v(" "),e("dt",[t._v("CBC support\nCONFIG_CRYPTO_CBC")]),t._v(" "),e("dd",[t._v("[块密码工作模式](http://msdn.microsoft.com/zh-cn/library/system.security.cryptography.ciphermode.aspx): 密码分组链接 (Cipher Block Chaining) 模式. IPSec 需要它.")]),t._v(" "),e("dt",[t._v("CTR support\nCONFIG_CRYPTO_CTR")]),t._v(" "),e("dd",[t._v("[块密码工作模式](http://msdn.microsoft.com/zh-cn/library/system.security.cryptography.ciphermode.aspx): 计数器 (Counter) 模式. IPSec 需要它.")]),t._v(" "),e("dt",[t._v("CTS support\nCONFIG_CRYPTO_CTS")]),t._v(" "),e("dd",[t._v("[块密码工作模式](http://msdn.microsoft.com/zh-cn/library/system.security.cryptography.ciphermode.aspx): 密文窃取 (Cipher Text Stealing) 模式. Kerberos gss 机制支持的 AES 加密需要它.")]),t._v(" "),e("dt",[t._v("ECB support\nCONFIG_CRYPTO_ECB")]),t._v(" "),e("dd",[t._v("[块密码工作模式](http://msdn.microsoft.com/zh-cn/library/system.security.cryptography.ciphermode.aspx)电子密码本 (Electronic CodeBook) 模式. 这是最简单的分组密码算法, 只是简单的分别加密每个块.")]),t._v(" "),e("dt",[t._v("LRW support\nCONFIG_CRYPTO_LRW")]),t._v(" "),e("dd",[t._v('[块密码工作模式](http://zh.wikipedia.org/wiki/%E5%9D%97%E5%AF%86%E7%A0%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F#.E5.85.B6.E5.AE.83.E6.A8.A1.E5.BC.8F.E5.92.8C.E5.AF.86.E7.A0.81.E5.AD.A6.E6.A6.82.E5.BF.B5):LRW(Liskov Rivest Wagner) 模式. 这个模式以三个人名命名. 这是一种小数据块加密模式, 加密后的数据保持与明文数据同样的长度, 专门用于 CONFIG_DM_CRYPT 模块加密磁盘区块 (使用 "aes-lrw-benbi" 指定).')]),t._v(" "),e("dt",[t._v("PCBC support\nCONFIG_CRYPTO_PCBC")]),t._v(" "),e("dd",[t._v("[块密码工作模式](http://zh.wikipedia.org/wiki/块密码的工作模式): 填充密码块链接 (Propagating Cipher Block Chaining) 模式. CONFIG_AF_RXRPC 需要它.")]),t._v(" "),e("dt",[t._v("XTS support\nCONFIG_CRYPTO_XTS")]),t._v(" "),e("dd",[t._v('[块密码工作模式](http://msdn.microsoft.com/zh-cn/library/system.security.cryptography.ciphermode.aspx):XTS 模式. 这是 IEEE1619/D16 规范制定的一种小数据块加密模式, 加密后的数据保持与明文数据同样的长度, 专门用于加密磁盘区块 (使用 "aes-xts-plain" 指定).')]),t._v(" "),e("dt",[t._v("CMAC support\nCONFIG_CRYPTO_CMAC")]),t._v(" "),e("dd",[t._v("NIST(美国国家标准与技术研究所) 制定的基于密文的[消息认证码](http://wenku.baidu.com/view/c0bb4078168884868762d6a1.html) ([Cipher-based Message Authentication Code](http://www.rfc-editor.org/rfc/rfc4493.txt))")]),t._v(" "),e("dt",[t._v("HMAC support\nCONFIG_CRYPTO_HMAC")]),t._v(" "),e("dd",[t._v("基于哈希的消息验证代码 ([RFC2104](http://blog.chinaunix.net/uid-20356525-id-1700433.html)). 在发送方和接收方共享机密密钥的前提下,[HMAC](http://baike.baidu.com/view/1136366.htm) 可用于确定通过不安全信道发送的消息是否被篡改. IPSec 需要它.")]),t._v(" "),e("dt",[t._v("XCBC support\nCONFIG_CRYPTO_XCBC")]),t._v(" "),e("dd",[t._v("基于哈希的加密算法 ([RFC3566](http://www.ietf.org/rfc/rfc3566.txt))")]),t._v(" "),e("dt",[t._v("VMAC support\nCONFIG_CRYPTO_VMAC")]),t._v(" "),e("dd",[t._v("[VMAC](http://fastcrypto.org/vmac) 是一种专用于 64 位 CPU 的高速消息认证算法")]),t._v(" "),e("dt",[t._v("CRC32c CRC algorithm\nCONFIG_CRYPTO_CRC32C")]),t._v(" "),e("dd",[t._v("[CRC32c](http://blog.csdn.net/codegame/article/details/6540965) 摘要算法是常见的 CRC32 [循环冗余校验](http://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97)的一个变种, 仅多项式常数不同, 算法完全一样. 常用于 iSCSI 和 SCTP 数据校验.")]),t._v(" "),e("dt",[t._v("CRC32c INTEL hardware acceleration\nCONFIG_CRYPTO_CRC32C_INTEL")]),t._v(" "),e("dd",[t._v('利用 [SSE4.2](http://en.wikipedia.org/wiki/SSE4) 指令集中专用的 "CRC32" 指令, 可以提高最少 10 倍的运算速度. 如果你的 CPU 支持 SSE4.2, 建议选 "Y".')]),t._v(" "),e("dt",[t._v("CRC32 CRC algorithm\nCONFIG_CRYPTO_CRC32")]),t._v(" "),e("dd",[t._v("经典的 CRC32 [循环冗余校验](http://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97)算法.")]),t._v(" "),e("dt",[t._v("CRC32 PCLMULQDQ hardware acceleration\nCONFIG_CRYPTO_CRC32_PCLMUL")]),t._v(" "),e("dd",[t._v('使用处理器的 PCLMULQDQ 指令 (又称 [CLMUL](http://en.wikipedia.org/wiki/CLMUL_instruction_set) 指令集, 其实只有一条指令) 加速 CRC32 的运算. PCLMULQDQ 是从 Intel [Westmere](http://zh.wikipedia.org/wiki/Intel_Nehalem#Nehalen.E8.A3.BD.E7.A8.8B.E6.94.B9.E9.80.B2.E7.89.88.EF.BC.9AWestmere.E6.9E.B6.E6.A7.8B) 和 AMD [Bulldozer](http://zh.wikipedia.org/wiki/AMD_Bulldozer) 开始引入的指令 (隶属于 [AES 指令集](http://en.wikipedia.org/wiki/AES_instruction_set)). 可以大幅提升 CRC32 的运算速度. 如果你的 CPU 支持 AES 指令集 (grep aes /proc/cpuinfo), 建议选 "Y".')]),t._v(" "),e("dt",[t._v("CRCT10DIF algorithm\nCONFIG_CRYPTO_CRCT10DIF")]),t._v(" "),e("dd",[t._v("CRC T10 DIF(Data Integrity Field) 算法可用于保障 T10/SCSI 设备的端到端的数据完整性.")]),t._v(" "),e("dt",[t._v("CRCT10DIF PCLMULQDQ hardware acceleration\nCONFIG_CRYPTO_CRCT10DIF_PCLMUL")]),t._v(" "),e("dd",[t._v('使用处理器的 PCLMULQDQ 指令 (又称 [CLMUL](http://en.wikipedia.org/wiki/CLMUL_instruction_set) 指令集, 其实只有一条指令) 加速 CRC T10 DIF 的运算. PCLMULQDQ 是从 Intel [Westmere](http://zh.wikipedia.org/wiki/Intel_Nehalem#Nehalen.E8.A3.BD.E7.A8.8B.E6.94.B9.E9.80.B2.E7.89.88.EF.BC.9AWestmere.E6.9E.B6.E6.A7.8B) 和 AMD [Bulldozer](http://zh.wikipedia.org/wiki/AMD_Bulldozer) 开始引入的指令 (隶属于 [AES 指令集](http://en.wikipedia.org/wiki/AES_instruction_set)). 可以大幅提升 CRC T10 DIF 的运算速度. 如果你的 CPU 支持 AES 指令集 (grep aes /proc/cpuinfo), 建议选 "Y".')]),t._v(" "),e("dt",[t._v("GHASH digest algorithm\nCONFIG_CRYPTO_GHASH")]),t._v(" "),e("dd",[t._v("[GHASH](http://wenku.baidu.com/view/c5d3a56c783e0912a3162a07.html) 是用于 GCM(Galois/Counter Mode) 的消息摘要算法.")]),t._v(" "),e("dt",[t._v("MD4 digest algorithm\nCONFIG_CRYPTO_MD4")]),t._v(" "),e("dd",[t._v("老旧的 [MD4](http://baike.baidu.com/view/444142.htm)(RFC1320) 摘要算法, 已经被淘汰.")]),t._v(" "),e("dt",[t._v("MD5 digest algorithm\nCONFIG_CRYPTO_MD5")]),t._v(" "),e("dd",[t._v("广泛使用的 [MD5](http://zh.wikipedia.org/wiki/MD5)(RFC1321) 摘要算法, 128 位. 已经被发现可以快速找到碰撞, 正逐渐淘汰中.")]),t._v(" "),e("dt",[t._v("Michael MIC keyed digest algorithm\nCONFIG_CRYPTO_MICHAEL_MIC")]),t._v(" "),e("dd",[t._v("Michael MIC 是仅用于 [TKIP](http://baike.baidu.com/view/755337.htm)(IEEE 802.11i) 的摘要算法. 不能用于其它场合, 因为它存在一些缺陷.")]),t._v(" "),e("dt",[t._v("RIPEMD-128 digest algorithm\nCONFIG_CRYPTO_RMD128")]),t._v(" "),e("dd",[t._v("RIPEMD-128(ISO/IEC 10118-3:2004)128 位摘要算法. 安全性不高, 不建议使用.")]),t._v(" "),e("dt",[t._v("RIPEMD-160 digest algorithm\nCONFIG_CRYPTO_RMD160")]),t._v(" "),e("dd",[t._v("[RIPEMD](http://baike.baidu.com/view/260854.htm)-160(ISO/IEC 10118-3:2004)160 位摘要算法. 是替代各种 128 位摘要算法 (RIPEMD-128,MD5,MD4) 的首选. 其运算速度和 SHA1 相当, 但是目前尚无已知有效的攻击方法.")]),t._v(" "),e("dt",[t._v("RIPEMD-256 digest algorithm\nCONFIG_CRYPTO_RMD256")]),t._v(" "),e("dd",[t._v("RIPEMD-256 在本质上和 RIPEMD-128 是一样的. 因为 RIPEMD 的设计者们根本就没有真正设计 256 和 320 位这两种标准, 他们只是在 128 位和 160 位的基础上, 修改了初始参数和 s-box 来达到输出为 256 和 320 位的目的. 所以, 256 位的强度和 128 相当, 而 320 位的强度和 160 位相当.")]),t._v(" "),e("dt",[t._v("RIPEMD-320 digest algorithm\nCONFIG_CRYPTO_RMD320")]),t._v(" "),e("dd",[t._v("RIPEMD-320 在本质上和 RIPEMD-160 是一样的. 因为 RIPEMD 的设计者们根本就没有真正设计 256 和 320 位这两种标准, 他们只是在 128 位和 160 位的基础上, 修改了初始参数和 s-box 来达到输出为 256 和 320 位的目的. 所以, 256 位的强度和 128 相当, 而 320 位的强度和 160 位相当.")]),t._v(" "),e("dt",[t._v("SHA1 digest algorithm\nCONFIG_CRYPTO_SHA1")]),t._v(" "),e("dd",[t._v("目前使用最广泛的 SHA-1(FIPS 180-1/DFIPS 180-2)160 位摘要算法是 [SHA 家族](http://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F)中的一员, 在许多安全协议中广为使用 (TLS,SSL,PGP,SSH,S/MIME,IPsec 等).SHA-1 曾被视为是 MD5 的后继者, 但由于出现了针对 SHA-1 的理论上破解的方法 (不等于实践中被破解), 有些人已经开始改用其它的替代算法 (例如 [SHA-3](http://www.oschina.net/translate/keccak-the-new-sha-3-encryption-standard)).")]),t._v(" "),e("dt",[t._v("SHA1 digest algorithm (SSSE3/AVX)\nCONFIG_CRYPTO_SHA1_SSSE3")]),t._v(" "),e("dd",[t._v('使用 [SSSE3](http://en.wikipedia.org/wiki/SSSE3)/[AVX](http://en.wikipedia.org/wiki/Advanced_Vector_Extensions) 指令集加速 SHA-1 的计算. 如果你的 CPU 支持 SSSE3/AVX 指令集, 建议选 "Y".')]),t._v(" "),e("dt",[t._v("SHA256 digest algorithm (SSSE3/AVX/AVX2)\nCONFIG_CRYPTO_SHA256_SSSE3")]),t._v(" "),e("dd",[t._v("使用 [SSSE3](http://en.wikipedia.org/wiki/SSSE3)/[AVX](http://en.wikipedia.org/wiki/Advanced_Vector_Extensions)/[AVX2](http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2) 指令集加速 SHA-256 的计算.")]),t._v(" "),e("dt",[t._v("SHA512 digest algorithm (SSSE3/AVX/AVX2)\nCONFIG_CRYPTO_SHA512_SSSE3")]),t._v(" "),e("dd",[t._v("使用 [SSSE3](http://en.wikipedia.org/wiki/SSSE3)/[AVX](http://en.wikipedia.org/wiki/Advanced_Vector_Extensions)/[AVX2](http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2) 指令集加速 SHA-512 的计算.")]),t._v(" "),e("dt",[t._v("SHA224 and SHA256 digest algorithm\nCONFIG_CRYPTO_SHA256")]),t._v(" "),e("dd",[t._v('SHA-224 和 SHA-256 摘要算法, 速度较 SHA1 稍慢, 都属于 "SHA-2" 系列, 目前尚无已知的有效攻击方法. 但并未被广泛使用.')]),t._v(" "),e("dt",[t._v("SHA384 and SHA512 digest algorithms\nCONFIG_CRYPTO_SHA512")]),t._v(" "),e("dd",[t._v('SHA-384 和 SHA-512 摘要算法, 速度大约只有 SHA1 的 40-50%, 都属于 "SHA-2" 系列, 目前尚无已知的有效攻击方法. 但并未被广泛使用.')]),t._v(" "),e("dt",[t._v("Tiger digest algorithms\nCONFIG_CRYPTO_TGR192")]),t._v(" "),e("dd",[t._v("Tiger 号称是最快的哈希算法, 专门为 64 位机器做了优化.")]),t._v(" "),e("dt",[t._v("Whirlpool digest algorithms\nCONFIG_CRYPTO_WP512")]),t._v(" "),e("dd",[t._v("[Whirlpool](http://blog.csdn.net/simb/article/details/1266177) 是一种 512 位的摘要算法, 利用了已有的 AES 分组密码算法构造 Hash 函数, 拥有相当高的安全性, 已经被列入了 ISO 标准, 目前最新版本为 3.0(2003 年发布).")]),t._v(" "),e("dt",[t._v("GHASH digest algorithm (CLMUL-NI accelerated)\nCONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL")]),t._v(" "),e("dd",[t._v("使用 CPU 的 [CLMUL](http://en.wikipedia.org/wiki/CLMUL_instruction_set) 指令集 (包含在 [AES 指令集](http://en.wikipedia.org/wiki/AES_instruction_set)中) 加速 GHASH 摘要算法.")]),t._v(" "),e("dt",[t._v("AES cipher algorithms\nCONFIG_CRYPTO_AES")]),t._v(" "),e("dd",[t._v('[AES](http://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86)(FIPS-197) 又称 "Rijndael", 是目前最佳的[对称加密](http://zh.wikipedia.org/wiki/%E5%B0%8D%E7%AD%89%E5%8A%A0%E5%AF%86)算法, 快速且节省内存, 可以使用 128/192/256 位密钥, 是目前使用最广泛的对称加密算法.')]),t._v(" "),e("dt",[t._v("AES cipher algorithms (x86_64)\nCONFIG_CRYPTO_AES_X86_64")]),t._v(" "),e("dd",[t._v("针对 x86_64 架构的 AES 实现.")]),t._v(" "),e("dt",[t._v("AES cipher algorithms (AES-NI)\nCONFIG_CRYPTO_AES_NI_INTEL")]),t._v(" "),e("dd",[t._v('使用 [AES 指令集](http://en.wikipedia.org/wiki/AES_instruction_set)加速 AES 的计算. 如果你的 CPU 支持 AES 指令集 (grep aes /proc/cpuinfo), 建议选 "Y".')]),t._v(" "),e("dt",[t._v("Anubis cipher algorithm\nCONFIG_CRYPTO_ANUBIS")]),t._v(" "),e("dd",[t._v("Anubis 是一种分组密码算法. 分组长度为 128 位, 密钥长度可变 (最低 128 位), 圈数可变 (最低 12 圈). 是欧洲于 2000 年 1 月 1 日启动的 [NESSIE 计划 17 个候选分组加密算法](http://wenku.baidu.com/view/23e92c0e7cd184254b3535fb.html)之一.")]),t._v(" "),e("dt",[t._v("ARC4 cipher algorithm\nCONFIG_CRYPTO_ARC4")]),t._v(" "),e("dd",[t._v("一种脆弱的流对称加密算法, 仅用于已经被淘汰的 [WEP](http://baike.baidu.com/view/32853.htm).")]),t._v(" "),e("dt",[t._v("Blowfish cipher algorithm\nCONFIG_CRYPTO_BLOWFISH")]),t._v(" "),e("dd",[t._v("[Blowfish](http://zh.wikipedia.org/wiki/Blowfish_(%E5%AF%86%E7%A0%81%E5%AD%A6)) 对称加密算法, 一种又老又慢的对称加密算法.")]),t._v(" "),e("dt",[t._v("Blowfish cipher algorithm (x86_64)\nCONFIG_CRYPTO_BLOWFISH_X86_64")]),t._v(" "),e("dd",[t._v("针对 x86_64 架构的 Blowfish 实现")]),t._v(" "),e("dt",[t._v("Blowfish cipher algorithm (x86_64/AVX2)\nCONFIG_CRYPTO_BLOWFISH_AVX2_X86_64")]),t._v(" "),e("dd",[t._v("使用 [AVX2](http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2) 指令集加速 Blowfish 的计算.")]),t._v(" "),e("dt",[t._v("Camellia cipher algorithms\nCONFIG_CRYPTO_CAMELLIA")]),t._v(" "),e("dd",[t._v("[Camellia](http://zh.wikipedia.org/wiki/Camellia) 是欧盟 NESSIE 项目的选定算法, 也是日本 CRYPTREC 项目的推荐算法. 可以使用 128/192/256 位密钥, 具有与 AES 同等级的安全强度及运算速度.")]),t._v(" "),e("dt",[t._v("Camellia cipher algorithm (x86_64)\nCONFIG_CRYPTO_CAMELLIA_X86_64")]),t._v(" "),e("dd",[t._v("针对 x86_64 架构的 Camellia 实现")]),t._v(" "),e("dt",[t._v("Camellia cipher algorithm (x86_64/AES-NI/AVX)\nCONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64")]),t._v(" "),e("dd",[t._v("使用 [AES 指令集](http://en.wikipedia.org/wiki/AES_instruction_set) /[AVX 指令集](http://en.wikipedia.org/wiki/Advanced_Vector_Extensions)加速 Camellia 的计算.")]),t._v(" "),e("dt",[t._v("Camellia cipher algorithm (x86_64/AES-NI/AVX2)\nCONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64")]),t._v(" "),e("dd",[t._v("使用 [AES 指令集](http://en.wikipedia.org/wiki/AES_instruction_set) /[AVX2 指令集](http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2)加速 Camellia 的计算.")]),t._v(" "),e("dt",[t._v("CAST5 (CAST-128) cipher algorithm\nCONFIG_CRYPTO_CAST5")]),t._v(" "),e("dd",[t._v("老旧的 CAST5(CAST-128) 对称加密算法")]),t._v(" "),e("dt",[t._v("CAST5 (CAST-128) cipher algorithm (x86_64/AVX)\nCONFIG_CRYPTO_CAST5_AVX_X86_64")]),t._v(" "),e("dd",[t._v("使用 [AVX 指令集](http://en.wikipedia.org/wiki/Advanced_Vector_Extensions)加速 CAST5 的计算.")]),t._v(" "),e("dt",[t._v("CAST6 (CAST-256) cipher algorithm\nCONFIG_CRYPTO_CAST6")]),t._v(" "),e("dd",[t._v("老旧的 CAST6(CAST-256) 对称加密算法")]),t._v(" "),e("dt",[t._v("CAST6 (CAST-256) cipher algorithm (x86_64/AVX)\nCONFIG_CRYPTO_CAST6_AVX_X86_64")]),t._v(" "),e("dd",[t._v("使用 [AVX 指令集](http://en.wikipedia.org/wiki/Advanced_Vector_Extensions)加速 CAST6 的计算.")]),t._v(" "),e("dt",[t._v("DES and Triple DES EDE cipher algorithms\nCONFIG_CRYPTO_DES")]),t._v(" "),e("dd",[t._v("老旧的 DES 和三重 DES 对称加密算法.")]),t._v(" "),e("dt",[t._v("FCrypt cipher algorithm\nCONFIG_CRYPTO_FCRYPT")]),t._v(" "),e("dd",[t._v("FCrypt 对称加密算法仅用于 CONFIG_AF_RXRPC")]),t._v(" "),e("dt",[t._v("Khazad cipher algorithm\nCONFIG_CRYPTO_KHAZAD")]),t._v(" "),e("dd",[t._v("[Khazad](http://en.wikipedia.org/wiki/KHAZAD) 是一种最终进入 NESSIE 决赛的对称加密算法, 专为 64 位 CPU 设计, 支持 128 位密钥.")]),t._v(" "),e("dt",[t._v("Salsa20 stream cipher algorithm\nCONFIG_CRYPTO_SALSA20")]),t._v(" "),e("dd",[t._v("[Salsa20](http://en.wikipedia.org/wiki/Salsa20) 是一种[流密码算法](http://wenku.baidu.com/view/a431d1125f0e7cd184253620.html), 也是 [eSTREAM](http://www.ecrypt.eu.org/stream/) 工程最终胜选算法之一.")]),t._v(" "),e("dt",[t._v("Salsa20 stream cipher algorithm (x86_64)\nCONFIG_CRYPTO_SALSA20_X86_64")]),t._v(" "),e("dd",[t._v("针对 x86_64 架构的 Salsa20 实现")]),t._v(" "),e("dt",[t._v("SEED cipher algorithm\nCONFIG_CRYPTO_SEED")]),t._v(" "),e("dd",[t._v("SEED(RFC4269) 对称分组加密算法, 采用 128 位密钥, 是韩国的国家标准.")]),t._v(" "),e("dt",[t._v("Serpent cipher algorithm\nCONFIG_CRYPTO_SERPENT")]),t._v(" "),e("dd",[t._v("[Serpent](http://en.wikipedia.org/wiki/Serpent_(cipher)) 对称加密算法曾经是 AES 的最终 5 个候选算法之一, 因为速度较 Rijndael 慢而最终得票数次之. 目前尚未发现针对 Serpent 的有效攻击, 因此被认为是一种强安全算法 (甚至被认为比 Rijndael 更安全).")]),t._v(" "),e("dt",[t._v("Serpent cipher algorithm (x86_64/SSE2)\nCONFIG_CRYPTO_SERPENT_SSE2_X86_64")]),t._v(" "),e("dd",[t._v("使用 [SSE2](http://zh.wikipedia.org/wiki/SSE2) 指令集加速 Serpent 的计算.")]),t._v(" "),e("dt",[t._v("Serpent cipher algorithm (x86_64/AVX)\nCONFIG_CRYPTO_SERPENT_AVX_X86_64")]),t._v(" "),e("dd",[t._v("使用 [AVX 指令集](http://en.wikipedia.org/wiki/Advanced_Vector_Extensions)加速 Serpent 的计算.")]),t._v(" "),e("dt",[t._v("Serpent cipher algorithm (x86_64/AVX2)\nCONFIG_CRYPTO_SERPENT_AVX2_X86_64")]),t._v(" "),e("dd",[t._v("使用 [AVX2 指令集](http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2)加速 Serpent 的计算.")]),t._v(" "),e("dt",[t._v("TEA, XTEA and XETA cipher algorithms\nCONFIG_CRYPTO_TEA")]),t._v(" "),e("dd",[t._v("较弱的几种对称加密算法")]),t._v(" "),e("dt",[t._v("Twofish cipher algorithm\nCONFIG_CRYPTO_TWOFISH")]),t._v(" "),e("dd",[t._v("[Twofish](http://zh.wikipedia.org/wiki/%E5%8F%8C%E9%B1%BC%E7%AE%97%E6%B3%95) 是派生自 Blowfish 的对称加密算法, 曾经是 AES 的最终 5 个候选算法之一, 最终得票数第三.")]),t._v(" "),e("dt",[t._v("Twofish cipher algorithm (x86_64)\nCONFIG_CRYPTO_TWOFISH_X86_64")]),t._v(" "),e("dd",[t._v("针对 x86_64 架构的 Twofish 实现")]),t._v(" "),e("dt",[t._v("Twofish cipher algorithm (x86_64, 3-way parallel)\nCONFIG_CRYPTO_TWOFISH_X86_64_3WAY")]),t._v(" "),e("dd",[t._v("针对 x86_64 架构的三路并行 Twofish 实现. 能够充分利用[乱序执行](http://zh.wikipedia.org/wiki/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C) CPU 的指令周期.")]),t._v(" "),e("dt",[t._v("Twofish cipher algorithm (x86_64/AVX)\nCONFIG_CRYPTO_TWOFISH_AVX_X86_64")]),t._v(" "),e("dd",[t._v("使用 [AVX 指令集](http://en.wikipedia.org/wiki/Advanced_Vector_Extensions)加速 Twofish 的计算.")]),t._v(" "),e("dt",[t._v("Twofish cipher algorithm (x86_64/AVX2)\nCONFIG_CRYPTO_TWOFISH_AVX2_X86_64")]),t._v(" "),e("dd",[t._v("使用 [AVX2 指令集](http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2)加速 Twofish 的计算.")]),t._v(" "),e("dt",[t._v("Deflate compression algorithm\nCONFIG_CRYPTO_DEFLATE")]),t._v(" "),e("dd",[t._v("[Deflate](http://zh.wikipedia.org/wiki/DEFLATE)(RFC1951) 无损数据压缩算法. 当在 IPSec 中使用 [IPCOMP](http://wenku.baidu.com/view/082419c00c22590102029d2d.html) 协议时才需要.")]),t._v(" "),e("dt",[t._v("Zlib compression algorithm\nCONFIG_CRYPTO_ZLIB")]),t._v(" "),e("dd",[t._v("[zlib](http://zh.wikipedia.org/wiki/Zlib) 无损数据压缩算法是一种事实上的业界标准. 被广泛应用.")]),t._v(" "),e("dt",[t._v("LZO compression algorithm\nCONFIG_CRYPTO_LZO")]),t._v(" "),e("dd",[t._v("[LZO](http://zh.wikipedia.org/wiki/LZO) 是致力于解压速度的一种无损数据压缩算法.")]),t._v(" "),e("dt",[t._v("Pseudo Random Number Generation for Cryptographic modules\nCONFIG_CRYPTO_ANSI_CPRNG")]),t._v(" "),e("dd",[t._v("符合 ANSI(美国国家标准学会)X9.31-1998 附录 A.2.4 所描述的伪随机数发生器 (基于 3DES). 这是一种较老的算法, 生成的随机数质量不高.")]),t._v(" "),e("dt",[t._v("NIST SP800-90A DRBG\nCONFIG_CRYPTO_DRBG_MENU")]),t._v(" "),e("dd",[t._v('符合 NIST(美国国家标准技术局)[SP800-90A](https://en.wikipedia.org/wiki/NIST_SP_800-90A) 标准的伪随机数发生器 (DRBG).[SP800-90A](https://nakedsecurity.sophos.com/zh/2013/12/22/the-openssl-software-bug-that-saves-you-from-surveillance/) 是美国政府 [FIPS 140-2](http://baike.baidu.com/view/9738638.htm) 安全认证强制推广的加密标准, 其中包含了生成强随机数的算法. 这是一种较新的算法, 生成的随机数质量较高. 建议选 "Y". 选中此项后, 还需选中至少一个子项.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Enable Hash DRBG\nCONFIG_CRYPTO_DRBG_HASH")]),t._v(" "),e("dd",[t._v('符合 NIST SP800-90A 标准的 Hash DRBG 变种算法 (基于 SHA256). 建议选 "Y".')]),t._v(" "),e("dt",[t._v("Enable CTR DRBG\nCONFIG_CRYPTO_DRBG_CTR")]),t._v(" "),e("dd",[t._v('符合 NIST SP800-90A 标准的 CTR DRBG 变种算法 (基于 AES). 建议选 "Y".')])])]),t._v(" "),e("dt",[t._v("Jitterentropy Non-Deterministic Random Number Generator\nCONFIG_CRYPTO_JITTERENTROPY")]),t._v(" "),e("dd",[t._v("JitterEntropy 伪随机数生成器以 CPU 执行时间的抖动作为熵源, 这是一种高质量的熵源, 可作为其他随机数生成器 ([/dev/urandom](http://www.tinylab.org/myths-about-urandom/)) 的种子. 这样就无需在系统启动时从磁盘上加载已经保存的种子文件了.")]),t._v(" "),e("dt",[t._v("User-space interface for hash algorithms\nCONFIG_CRYPTO_USER_API_HASH")]),t._v(" "),e("dd",[t._v('哈希算法的用户空间接口. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("User-space interface for symmetric key cipher algorithms\nCONFIG_CRYPTO_USER_API_SKCIPHER")]),t._v(" "),e("dd",[t._v('对称加密算法的用户空间接口. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("User-space interface for random number generator algorithms\nCONFIG_CRYPTO_USER_API_RNG")]),t._v(" "),e("dd",[t._v('随机数发生器算法的用户空间接口. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("User-space interface for AEAD cipher algorithms\nCONFIG_CRYPTO_USER_API_AEAD")]),t._v(" "),e("dd",[t._v('[AEAD](http://blog.helong.info/blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/)(Authenticated-Encryption with Addtional Data) 加密算法的用户空间接口. AEAD 是当前最好的加密模式. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Hardware crypto devices\nCONFIG_CRYPTO_HW")]),t._v(" "),e("dd",[t._v("硬件加密设备支持")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Support for VIA PadLock ACE\nCONFIG_CRYPTO_DEV_PADLOCK")]),t._v(" "),e("dd",[t._v("带有 [PadLock](http://www.viatech.com.cn/cn/initiatives/padlock/index.jsp) 技术的 VIA 系列处理器支持")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("PadLock driver for AES algorithm\nCONFIG_CRYPTO_DEV_PADLOCK_AES")]),t._v(" "),e("dd",[t._v("利用 PadLock 技术[加速 AES 运算](http://www.viatech.com.cn/cn/initiatives/padlock/features.jsp#aes).VIA C3 及以上的 CPU 都支持.")]),t._v(" "),e("dt",[t._v("PadLock driver for SHA1 and SHA256 algorithms\nCONFIG_CRYPTO_DEV_PADLOCK_SHA")]),t._v(" "),e("dd",[t._v("利用 PadLock 技术[加速 SHA1 和 SHA256 运算](http://www.viatech.com.cn/cn/initiatives/padlock/features.jsp#sha).VIA C7 及以上的 CPU 都支持.")])])]),t._v(" "),e("dt",[t._v("Support for AMD Cryptographic Coprocessor\nCONFIG_CRYPTO_DEV_CCP")]),t._v(" "),e("dd",[t._v("AMD 密码协处理器支持.")]),t._v(" "),e("dt",[t._v("Support for Intel(R) DH895xCC\nCONFIG_CRYPTO_DEV_QAT_DH895xCC")]),t._v(" "),e("dd",[t._v("支持 [QuickAssist 技术](http://server.it168.com/server/2008-03-26/200803260936276.shtml)的 Intel DH895xcc 芯片.[Skylake 的服务器平台的部分 CPU 型号支持 QuickAssist 技术](http://news.mydrivers.com/1/435/435453.htm).")]),t._v(" "),e("dt",[t._v("Support for Intel(R) DH895xCC Virtual Function\nCONFIG_CRYPTO_DEV_QAT_DH895xCCVF")]),t._v(" "),e("dd",[t._v("支持 [QuickAssist 技术](http://server.it168.com/server/2008-03-26/200803260936276.shtml)的 Intel DH895xcc 芯片.[Skylake 的服务器平台的部分 CPU 型号支持 QuickAssist 技术](http://news.mydrivers.com/1/435/435453.htm).")])])]),t._v(" "),e("dt",[t._v("Asymmetric (public-key cryptographic) key type\nCONFIG_ASYMMETRIC_KEY_TYPE")]),t._v(" "),e("dd",[t._v("[非对称加密算法](http://baike.baidu.com/view/1490349.htm) ([公钥加密算法](http://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86))")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("Asymmetric public-key crypto algorithm subtype\nCONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE")]),t._v(" "),e("dd",[t._v("非对称公钥加密算法子类型. 如果需要生成或者校验签名, 那就还必须配合哈希算法一起使用.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("RSA public-key algorithm\nCONFIG_PUBLIC_KEY_ALGO_RSA")]),t._v(" "),e("dd",[t._v("[RSA](http://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95) 算法 ([PKCS#1](http://wenku.baidu.com/view/168e67175f0e7cd18425369a.html), RFC3447) 支持")]),t._v(" "),e("dt",[t._v("X.509 certificate parser\nCONFIG_X509_CERTIFICATE_PARSER")]),t._v(" "),e("dd",[t._v("[X.509](http://baike.baidu.com/view/156016.htm) 证书解析支持")])])])])]),t._v(" "),e("dt",[t._v("Certificates for signature checking")]),t._v(" "),e("dd",[t._v("用于检查签名有效性的证书:(1)用于检查内核模块的签名,(2)用于检查全局密钥环 (keyring) 中的密钥的可靠性.")])]),t._v(" "),e("h2",{attrs:{id:"virtualization"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#virtualization"}},[t._v("#")]),t._v(" Virtualization")]),t._v(" "),e("p",[t._v("虚拟化支持\n仅在将此内核用作宿主机 (host) 的情况下才需要开启这里的子项")]),t._v(" "),e("dl",[e("dt",[t._v("Kernel-based Virtual Machine (KVM) support\nCONFIG_KVM")]),t._v(" "),e("dd",[t._v('[KVM](http://www.ibm.com/developerworks/cn/linux/l-linux-kvm/index.html)([内核虚拟机](http://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA)) 是一种基于 Linux 内核的[全虚拟化技术](http://www.ibm.com/developerworks/cn/linux/l-cn-vt/), 需要 CPU 支持 [x86 硬件虚拟化技术](http://zh.wikipedia.org/wiki/X86%E8%99%9A%E6%8B%9F%E5%8C%96) (Intel VT 或 AMD-V). 开启此项后, 将可以通过字符文件 "/dev/kvm" 使用虚拟机.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("KVM for Intel processors support\nCONFIG_KVM_INTEL")]),t._v(" "),e("dd",[t._v('[Intel VT](http://baike.baidu.com/view/2236017.htm) 技术支持. 也就是 cpu-flags 中有 "vmx" 标记.')]),t._v(" "),e("dt",[t._v("KVM for AMD processors support\nCONFIG_KVM_AMD")]),t._v(" "),e("dd",[t._v('[AMD-V](http://sites.amd.com/cn/business/it-solutions/virtualization/Pages/amd-v.aspx) 技术支持. 也就是 cpu-flags 中有 "svm" 标记.')]),t._v(" "),e("dt",[t._v("Audit KVM MMU\nCONFIG_KVM_MMU_AUDIT")]),t._v(" "),e("dd",[t._v('添加一个 "kvm.mmu_audit" 内核参数, 用于控制是否允许在运行时对 KVM MMU 进行审计."0" 表示禁止审计,"1" 表示允许审计. 主要用于调试目的. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("KVM legacy PCI device assignment support\nCONFIG_KVM_DEVICE_ASSIGNMENT")]),t._v(" "),e("dd",[t._v('通过 KVM 支持传统的 PCI 设备分配. 内核目前还通过 VFIO(CONFIG_VFIO) 支持一个全功能的[用户空间设备驱动框架](http://www.linux-kvm.com/content/pci-device-assignment-driver-coming-linux-36-vfio), 可以取代这里的功能. 不确定的选 "N".')])])]),t._v(" "),e("dt",[t._v("Host kernel accelerator for virtio net\nCONFIG_VHOST_NET")]),t._v(" "),e("dd",[t._v('在宿主机内核中开启此项后, 可以加速客户机的网络操作速度 (客户机内核需要加载 virtio_net 模块 (CONFIG_VIRTIO_NET)). 建议选 "Y".')]),t._v(" "),e("dt",[t._v("VHOST_SCSI TCM fabric driver\nCONFIG_VHOST_SCSI")]),t._v(" "),e("dd",[t._v('Say M here to enable the vhost_scsi TCM fabric module for use with virtio-scsi guests. 看不懂的选 "N".')]),t._v(" "),e("dt",[t._v("Cross-endian support for vhost\nCONFIG_VHOST_CROSS_ENDIAN_LEGACY")]),t._v(" "),e("dd",[t._v('允许宿主机支持不同大小端顺序的客户机中老旧的 virtio 设备. 仅在宿主机与客户机的大小端顺序不一致的场合 (ppc64/arm64) 才有意义. 不确定的选 "N".')])]),t._v(" "),e("h2",{attrs:{id:"library-routines"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#library-routines"}},[t._v("#")]),t._v(" Library routines")]),t._v(" "),e("p",[t._v("库子程序\n子选项可以全不选, 内核中若有其他部分依赖它, 会自动选上. 使用内核树外的模块时可能需要手动选择.")]),t._v(" "),e("dl",[e("dt",[t._v("CRC-CCITT functions\nCONFIG_CRC_CCITT")]),t._v(" "),e("dd",[t._v("为内核树外的模块提供 [CRC-CCITT](http://djb69.blog.163.com/blog/static/6776323420100158391490/) 循环验证算法支持.")]),t._v(" "),e("dt",[t._v("CRC16 functions\nCONFIG_CRC16")]),t._v(" "),e("dd",[t._v("为内核树外的模块提供 [CRC16](http://blog.csdn.net/kwbin/article/details/3323836) 循环验证算法支持.")]),t._v(" "),e("dt",[t._v("CRC calculation for the T10 Data Integrity Field\nCONFIG_CRC_T10DIF")]),t._v(" "),e("dd",[t._v("为内核树外的模块提供 [CRC](http://zh.wikipedia.org/zh/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97) 循环验证算法支持. 从而允许内核树外的 SCSI 模块利用 [T10/SCSI Data Integrity Field](http://www.ibm.com/developerworks/cn/aix/library/au-T10E2E/) 保障[端到端的数据完整性](http://alanwu.blog.51cto.com/3652632/1093600).")]),t._v(" "),e("dt",[t._v("CRC ITU-T V.41 functions\nCONFIG_CRC_ITU_T")]),t._v(" "),e("dd",[t._v("为内核树外的模块提供 CRC ITU-T V.41 循环验证算法支持.")]),t._v(" "),e("dt",[t._v("CRC32/CRC32c functions\nCONFIG_CRC32")]),t._v(" "),e("dd",[t._v("为内核树外的模块提供 CRC32/CRC32c 循环验证算法支持.")]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("CRC32 perform self test on init\nCONFIG_CRC32_SELFTEST")]),t._v(" "),e("dd",[t._v('在 CRC32 算法初始化的时候进行一个简单的自我测试. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("CRC32 implementation")]),t._v(" "),e("dd",[t._v('选择 CRC32 算法的实现方式. 不确定的请保持默认值 "Slice by 8 bytes", 除非你知道自己在做什么.')])])]),t._v(" "),e("dt",[t._v("CRC7 functions\nCONFIG_CRC7")]),t._v(" "),e("dd",[t._v("为内核树外的模块提供 CRC7 循环验证算法支持.")]),t._v(" "),e("dt",[t._v("CRC32c (Castagnoli, et al) Cyclic Redundancy-Check\nCONFIG_LIBCRC32C")]),t._v(" "),e("dd",[t._v("为内核树外的模块提供 CRC32c 循环验证算法支持.")]),t._v(" "),e("dt",[t._v("CRC8 function\nCONFIG_CRC8")]),t._v(" "),e("dd",[t._v("为内核树外的模块提供 CRC8 循环验证算法支持.")]),t._v(" "),e("dt",[t._v("XZ decompression support\nCONFIG_XZ_DEC")]),t._v(" "),e("dd",[t._v('为内核树外的模块提供 XZ 解压支持. 详见 "[Documentation/xz.txt](https://www.kernel.org/doc/Documentation/xz.txt)"文档. 子项是针对不同平台的"BCJ filter decoder". 按需选择即可.')]),t._v(" "),e("dt",[t._v("XZ decompressor tester\nCONFIG_XZ_DEC_TEST")]),t._v(" "),e("dd",[t._v('XZ 解压测试程序. 不确定的选 "N".')]),t._v(" "),e("dt",[t._v("Averaging functions\nCONFIG_AVERAGE")]),t._v(" "),e("dd",[t._v("为内核树外的模块提供 averaging 函数支持")]),t._v(" "),e("dt",[t._v("CORDIC algorithm\nCONFIG_CORDIC")]),t._v(" "),e("dd",[t._v("为内核树外的模块提供 [CORDIC](http://en.wikipedia.org/wiki/CORDIC) 算法支持")]),t._v(" "),e("dt",[t._v("JEDEC DDR data\nCONFIG_DDR")]),t._v(" "),e("dd",[t._v("为内核树外的 DDR SDRAM 内存控制器驱动提供获取 [JEDEC](http://zh.wikipedia.org/wiki/JEDEC) 数据支持.")]),t._v(" "),e("dt",[t._v("Select compiled-in fonts\nCONFIG_FONTS")]),t._v(" "),e("dd",[t._v('选择内嵌到内核中的字体 (点阵字库, 仅包含 [ASCII 字符](http://images.cnblogs.com/cnblogs_com/skynet/201105/2011050311372042.png)和[扩展 ASCII 字符](http://images.cnblogs.com/cnblogs_com/skynet/201105/201105031137219627.png), 共 256 个). 选 "N" 表示内嵌自动选择的默认字体, 选 "Y" 表示可以手动选择内嵌的字体.[提示] 可到 drivers/video/console 目录下找到相应的 "font_*.c" 文件, 将其中的 "0" 全部替换为空格, 即可看到点阵字符.')]),t._v(" "),e("dd",[e("dl",[e("dt",[t._v("VGA 8x8 font\nCONFIG_FONT_8x8")]),t._v(" "),e("dd",[t._v("这是传统上高分辨率 (高于 80x50) 下使用的字体. 因为点阵太小, 所以显示的字体质量非常低劣.")]),t._v(" "),e("dt",[t._v("VGA 8x16 font\nCONFIG_FONT_8x16")]),t._v(" "),e("dd",[t._v("这是传统上的标准字体 (用于 80x25), 也是默认内嵌的字体, 最为常见.")]),t._v(" "),e("dt",{staticClass:"omit"},[t._v("{其它字体省略}")]),t._v(" "),e("dt",[t._v("console 16x16 CJK font (cover BMP)\nCONFIG_FONT_16x16_CJK")]),t._v(" "),e("dd",[t._v('[CJKTTY](https://github.com/gentoo-zh/linux-cjktty/) 开源项目提供的中文字体支持 (仅支持 UTF-8 字符) [补丁](https://github.com/gentoo-zh/linux-cjktty/compare/4.4-utf8.diff). 如果你希望能够直接在控制台上显示中文, 那么请将此项选 "Y", 并同时将其他字体选项全部选 "N". [如何改造 Linux 虚拟终端显示中文](http://www.ibm.com/developerworks/cn/linux/l-cn-termi-hanzi/)一文讲解了此补丁的原理.')])])])]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("| "),e("Select",[t._v(" | "),e("Exit",[t._v(" | "),e("Help",[t._v(" | "),e("Save",[t._v(" | "),e("Load",[t._v(" |\n| 确定 | 退出 | 帮助 | 保存配置 | 读入配置 |")])],1)],1)],1)],1)],1),t._v(" "),e("hr"),t._v(" "),e("p",[e("img",{attrs:{src:"http://note.youdao.com/yws/images/webclipper/loading.gif",alt:""}})]),t._v(" "),e("form",{attrs:{id:"_YNoteContentForm","http:":"","note.youdao.com":"",yws:"",mapi:"","wcp?method":'putfile&keyfrom=wcp&from=chrome&vendor=ChromeStore&vn=2"',target:"1ContentFrame&ChromeStore",enctype:"multipart/form-data",method:"POST"}},[e("input",{attrs:{type:"text"}}),e("input",{attrs:{type:"text"}}),e("textarea"),e("input",{attrs:{type:"text"}}),e("input",{attrs:{type:"text"}}),e("input",{attrs:{type:"text"}}),e("input",{attrs:{type:"text"}}),e("input",{attrs:{type:"text"}}),e("input",{attrs:{type:"text"}})])],1)}),[],!1,null,null,null);_.default=v.exports}}]);